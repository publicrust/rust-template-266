[
  {
    "HookSignature": "OnClientDisconnected(Network.Connection cn, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Connection cn)",
    "MethodSourseCode": "\n\tprotected void OnDisconnected(string strReason, Connection cn)\n\t{\n\t\tif (cn != null)\n\t\t{\n\t\t\tcn.connected = false;\n\t\t\tcn.active = false;\n\t\t\tif (callbackHandler != null)\n\t\t\t{\n\t\t\t\tcallbackHandler.OnDisconnected(strReason, cn);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnClientDisconnected\u0022, cn, strReason);\n\t\t\tRemoveConnection(cn);\n\t\t}\n\t}\n",
    "ClassName": "Server",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnNetworkSubscriptionsUpdate(Network.Networkable network.Networkable, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj)",
    "MethodSignature": "UpdateHighPrioritySubscriptions()",
    "MethodSourseCode": "\n\tpublic bool UpdateHighPrioritySubscriptions()\n\t{\n\t\tif (subscriber == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateHighPrioritySubscriptions\u0022))\n\t\t{\n\t\t\tList\u003CGroup\u003E obj = Pool.GetList\u003CGroup\u003E();\n\t\t\tList\u003CGroup\u003E obj2 = Pool.GetList\u003CGroup\u003E();\n\t\t\tsv.visibility.GetVisibleFromNear(this.group, obj2);\n\t\t\tAddVisibleFromNear(secondaryGroup, obj2);\n\t\t\tsubscriber.subscribed.Compare(obj2, obj, null, null);\n\t\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsUpdate\u0022, this, obj, null) == null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group = obj[i];\n\t\t\t\t\tsubscriber.Subscribe(group);\n\t\t\t\t\tif (handler != null)\n\t\t\t\t\t{\n\t\t\t\t\t\thandler.OnNetworkGroupEnter(group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeList(ref obj);\n\t\t\tPool.FreeList(ref obj2);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Networkable",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnNetworkSubscriptionsUpdate(Network.Networkable network.Networkable, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E obj2)",
    "MethodSignature": "UpdateSubscriptions(int removeLimit, int addLimit)",
    "MethodSourseCode": "\n\tpublic bool UpdateSubscriptions(int removeLimit, int addLimit)\n\t{\n\t\tif (!updateSubscriptions)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (subscriber == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateSubscriptions\u0022))\n\t\t{\n\t\t\tupdateSubscriptions = false;\n\t\t\tList\u003CGroup\u003E obj = Pool.GetList\u003CGroup\u003E();\n\t\t\tList\u003CGroup\u003E obj2 = Pool.GetList\u003CGroup\u003E();\n\t\t\tList\u003CGroup\u003E obj3 = Pool.GetList\u003CGroup\u003E();\n\t\t\tsv.visibility.GetVisibleFromFar(this.group, obj3);\n\t\t\tAddVisibleFromNear(secondaryGroup, obj3);\n\t\t\tsubscriber.subscribed.Compare(obj3, obj, obj2, null);\n\t\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsUpdate\u0022, this, obj, obj2) == null)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C obj2.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group = obj2[i];\n\t\t\t\t\tif (removeLimit \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubscriber.Unsubscribe(group);\n\t\t\t\t\t\tif (handler != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thandler.OnNetworkGroupLeave(group);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveLimit -= group.networkables.Count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateSubscriptions = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j \u003C obj.Count; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tGroup group2 = obj[j];\n\t\t\t\t\tif (addLimit \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubscriber.Subscribe(group2);\n\t\t\t\t\t\tif (handler != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thandler.OnNetworkGroupEnter(group2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddLimit -= group2.networkables.Count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateSubscriptions = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeList(ref obj);\n\t\t\tPool.FreeList(ref obj2);\n\t\t\tPool.FreeList(ref obj3);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Networkable",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnGroupPermissionGranted(string groupName, string permission)",
    "MethodSignature": "GrantGroupPermission(string groupName, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantGroupPermission\u0022)]\n\tpublic void GrantGroupPermission(string groupName, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner) || !GroupExists(groupName) || !groupsData.TryGetValue(groupName, out var groupData))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | groupData.Perms.Add(s));\n\t\t}\n\t\telse if (groupData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionGranted\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnUserGroupRemoved(string playerId, string groupName)",
    "MethodSignature": "RemoveUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveUserGroup\u0022)]\n\tpublic void RemoveUserGroup(string playerId, string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (groupName.Equals(\u0022*\u0022))\n\t\t{\n\t\t\tif (userData.Groups.Count \u003E 0)\n\t\t\t{\n\t\t\t\tuserData.Groups.Clear();\n\t\t\t}\n\t\t}\n\t\telse if (userData.Groups.Remove(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupRemoved\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "Init()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tforeach (string key in Hooks.Keys)\n\t\t{\n\t\t\tSubscribe(key);\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Init\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tif (base.Loader != null)\n\t\t\t{\n\t\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSPlugin",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnGroupCreated(string groupName, string groupTitle, int groupRank)",
    "MethodSignature": "CreateGroup(string groupName, string groupTitle, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022CreateGroup\u0022)]\n\tpublic bool CreateGroup(string groupName, string groupTitle, int groupRank)\n\t{\n\t\tif (GroupExists(groupName) || string.IsNullOrEmpty(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tGroupData value = new GroupData\n\t\t{\n\t\t\tTitle = groupTitle,\n\t\t\tRank = groupRank\n\t\t};\n\t\tgroupsData.Add(groupName, value);\n\t\tInterface.CallHook(\u0022OnGroupCreated\u0022, groupName, groupTitle, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnGroupDeleted(string groupName)",
    "MethodSignature": "RemoveGroup(string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RemoveGroup\u0022)]\n\tpublic bool RemoveGroup(string groupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = groupsData.Remove(groupName);\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (GroupData item in groupsData.Values.Where((GroupData g) =\u003E g.ParentGroup == groupName))\n\t\t\t{\n\t\t\t\titem.ParentGroup = string.Empty;\n\t\t\t}\n\t\t}\n\t\tif (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) =\u003E current | userData.Groups.Remove(groupName)))\n\t\t{\n\t\t\tSaveUsers();\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGroupDeleted\u0022, groupName);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupTitleSet(string groupName, string groupTitle)",
    "MethodSignature": "SetGroupTitle(string groupName, string groupTitle)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupTitle\u0022)]\n\tpublic bool SetGroupTitle(string groupName, string groupTitle)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Title == groupTitle)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Title = groupTitle;\n\t\tInterface.CallHook(\u0022OnGroupTitleSet\u0022, groupName, groupTitle);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnGroupPermissionRevoked(string groupName, string permission)",
    "MethodSignature": "RevokeGroupPermission(string groupName, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeGroupPermission\u0022)]\n\tpublic void RevokeGroupPermission(string groupName, string permission)\n\t{\n\t\tif (!GroupExists(groupName) || string.IsNullOrEmpty(permission) || !groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (value.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tvalue.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (value.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnGroupPermissionRevoked\u0022, groupName, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "LoadDefaultMessages()",
    "MethodSignature": "LoadDefaultMessages()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultMessages()\n\t{\n\t\tCallHook(\u0022LoadDefaultMessages\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGroupRankSet(string groupName, int groupRank)",
    "MethodSignature": "SetGroupRank(string groupName, int groupRank)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupRank\u0022)]\n\tpublic bool SetGroupRank(string groupName, int groupRank)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (value.Rank == groupRank)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvalue.Rank = groupRank;\n\t\tInterface.CallHook(\u0022OnGroupRankSet\u0022, groupName, groupRank);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)",
    "MethodSignature": "RegisterPermission(string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RegisterPermission\u0022)]\n\tpublic void RegisterPermission(string permission, Plugin owner)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (PermissionExists(permission))\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Duplicate permission registered \u0027{0}\u0027 (by plugin \u0027{1}\u0027)\u0022, permission, owner.Title);\n\t\t\treturn;\n\t\t}\n\t\tif (!registeredPermissions.TryGetValue(owner, out var value))\n\t\t{\n\t\t\tvalue = new HashSet\u003Cstring\u003E(StringComparer.OrdinalIgnoreCase);\n\t\t\tregisteredPermissions.Add(owner, value);\n\t\t\towner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);\n\t\t}\n\t\tvalue.Add(permission);\n\t\tInterface.CallHook(\u0022OnPermissionRegistered\u0022, permission, owner);\n\t\tif (!permission.StartsWith(owner.Name \u002B \u0022.\u0022, StringComparison.OrdinalIgnoreCase) \u0026\u0026 !owner.IsCorePlugin)\n\t\t{\n\t\t\tInterface.Oxide.LogWarning(\u0022Missing plugin name prefix \u0027{0}\u0027 for permission \u0027{1}\u0027 (by plugin \u0027{2}\u0027)\u0022, owner.Name.ToLower(), permission, owner.Title);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnUserPermissionRevoked(string playerId, string permission)",
    "MethodSignature": "RevokeUserPermission(string playerId, string permission)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022RevokeUserPermission\u0022)]\n\tpublic void RevokeUserPermission(string playerId, string permission)\n\t{\n\t\tif (string.IsNullOrEmpty(permission))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tif (userData.Perms.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tuserData.Perms.Clear();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuserData.Perms.RemoveWhere((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase));\n\t\t\t_ = 0;\n\t\t}\n\t\telse if (userData.Perms.Remove(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionRevoked\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnPluginLoaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "PluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\tpublic bool PluginLoaded(Plugin plugin)\n\t{\n\t\tplugin.OnError \u002B= plugin_OnError;\n\t\ttry\n\t\t{\n\t\t\tplugin.Loader?.PluginErrors.Remove(plugin.Name);\n\t\t\tRootPluginManager.AddPlugin(plugin);\n\t\t\tif (plugin.Loader != null \u0026\u0026 plugin.Loader.PluginErrors.ContainsKey(plugin.Name))\n\t\t\t{\n\t\t\t\tUnloadPlugin(plugin.Name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tplugin.IsLoaded = true;\n\t\t\tCallHook(\u0022OnPluginLoaded\u0022, plugin);\n\t\t\tLogInfo(\u0022Loaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tif (plugin.Loader != null)\n\t\t\t{\n\t\t\t\tplugin.Loader.PluginErrors[plugin.Name] = ex.Message;\n\t\t\t}\n\t\t\tLogException($\u0022Could not initialize plugin \u0027{plugin.Name} v{plugin.Version}\u0027\u0022, ex);\n\t\t\treturn false;\n\t\t}\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnUserGroupAdded(string playerId, string groupName)",
    "MethodSignature": "AddUserGroup(string playerId, string groupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022AddUserGroup\u0022)]\n\tpublic void AddUserGroup(string playerId, string groupName)\n\t{\n\t\tif (GroupExists(groupName) \u0026\u0026 GetUserData(playerId).Groups.Add(groupName))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserGroupAdded\u0022, playerId, groupName);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "LoadDefaultConfig()",
    "MethodSignature": "LoadDefaultConfig()",
    "MethodSourseCode": "\n\tprotected virtual void LoadDefaultConfig()\n\t{\n\t\tCallHook(\u0022LoadDefaultConfig\u0022, null);\n\t}\n",
    "ClassName": "Plugin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPEndPoint connectionUserEndPoint, string text, string[] array2)",
    "MethodSignature": "OnMessage(MessageEventArgs e, WebSocketContext connection)",
    "MethodSourseCode": "\n\tprivate void OnMessage(MessageEventArgs e, WebSocketContext connection)\n\t{\n\t\tif (covalence == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, Covalence is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tRemoteMessage message = RemoteMessage.GetMessage(e.Data);\n\t\tif (message == null)\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage is null\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (string.IsNullOrEmpty(message.Message))\n\t\t{\n\t\t\tInterface.Oxide.LogError(\u0022[Rcon] Failed to process command, RemoteMessage.Text is not set\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring[] array = CommandLine.Split(message.Message);\n\t\tstring text = array[0].ToLower();\n\t\tstring[] array2 = array.Skip(1).ToArray();\n\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, connection.UserEndPoint, text, array2) == null)\n\t\t{\n\t\t\tIServer obj = covalence.Server;\n\t\t\tobject[] args = array2;\n\t\t\tobj.Command(text, args);\n\t\t}\n\t}\n",
    "ClassName": "RemoteConsole",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnGroupParentSet(string groupName, string parentGroupName)",
    "MethodSignature": "SetGroupParent(string groupName, string parentGroupName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022SetGroupParent\u0022)]\n\tpublic bool SetGroupParent(string groupName, string parentGroupName)\n\t{\n\t\tif (!GroupExists(groupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!groupsData.TryGetValue(groupName, out var value))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (string.IsNullOrEmpty(parentGroupName))\n\t\t{\n\t\t\tvalue.ParentGroup = null;\n\t\t\treturn true;\n\t\t}\n\t\tif (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(value.ParentGroup) \u0026\u0026 value.ParentGroup.Equals(parentGroupName))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (HasCircularParent(groupName, parentGroupName))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvalue.ParentGroup = parentGroupName;\n\t\tInterface.CallHook(\u0022OnGroupParentSet\u0022, groupName, parentGroupName);\n\t\treturn true;\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnPluginUnloaded(Oxide.Core.Plugins.Plugin plugin)",
    "MethodSignature": "UnloadPlugin(string name)",
    "MethodSourseCode": "\n\tpublic bool UnloadPlugin(string name)\n\t{\n\t\tPlugin plugin = RootPluginManager.GetPlugin(name);\n\t\tif (plugin == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\textensionManager.GetPluginLoaders().SingleOrDefault((PluginLoader l) =\u003E l.LoadedPlugins.ContainsKey(name))?.Unloading(plugin);\n\t\tRootPluginManager.RemovePlugin(plugin);\n\t\tif (plugin.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022OnPluginUnloaded\u0022, plugin);\n\t\t}\n\t\tplugin.IsLoaded = false;\n\t\tLogInfo(\u0022Unloaded plugin {0} v{1} by {2}\u0022, plugin.Title, plugin.Version, plugin.Author);\n\t\treturn true;\n\t}\n",
    "ClassName": "OxideMod",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnUserPermissionGranted(string playerId, string permission)",
    "MethodSignature": "GrantUserPermission(string playerId, string permission, Plugin owner)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022GrantUserPermission\u0022)]\n\tpublic void GrantUserPermission(string playerId, string permission, Plugin owner)\n\t{\n\t\tif (!PermissionExists(permission, owner))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserData userData = GetUserData(playerId);\n\t\tif (permission.EndsWith(\u0022*\u0022))\n\t\t{\n\t\t\tHashSet\u003Cstring\u003E value;\n\t\t\tif (owner == null)\n\t\t\t{\n\t\t\t\tvalue = new HashSet\u003Cstring\u003E(registeredPermissions.Values.SelectMany((HashSet\u003Cstring\u003E v) =\u003E v));\n\t\t\t}\n\t\t\telse if (!registeredPermissions.TryGetValue(owner, out value))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (permission.Equals(\u0022*\u0022))\n\t\t\t{\n\t\t\t\tvalue.Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalue.Where((string p) =\u003E p.StartsWith(permission.TrimEnd(\u0027*\u0027), StringComparison.OrdinalIgnoreCase)).Aggregate(seed: false, (bool c, string s) =\u003E c | userData.Perms.Add(s));\n\t\t}\n\t\telse if (userData.Perms.Add(permission))\n\t\t{\n\t\t\tInterface.Call(\u0022OnUserPermissionGranted\u0022, playerId, permission);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnUserNameUpdated(string playerId, string lastSeenNickname, string obj)",
    "MethodSignature": "UpdateNickname(string playerId, string playerName)",
    "MethodSourseCode": "\n\t[LibraryFunction(\u0022UpdateNickname\u0022)]\n\tpublic void UpdateNickname(string playerId, string playerName)\n\t{\n\t\tif (UserExists(playerId))\n\t\t{\n\t\t\tUserData userData = GetUserData(playerId);\n\t\t\tstring lastSeenNickname = userData.LastSeenNickname;\n\t\t\tstring obj = playerName.Sanitize();\n\t\t\tuserData.LastSeenNickname = playerName.Sanitize();\n\t\t\tInterface.CallHook(\u0022OnUserNameUpdated\u0022, playerId, lastSeenNickname, obj);\n\t\t}\n\t}\n",
    "ClassName": "Permission",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "Internal(Arg arg)",
    "MethodSourseCode": "\n\tprivate static bool Internal(Arg arg)\n\t{\n\t\tif (arg.Invalid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022IOnServerCommand\u0022, arg);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!arg.HasPermission())\n\t\t{\n\t\t\targ.ReplyWith(\u0022You cannot run this command\u0022);\n\t\t\treturn false;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022ConsoleSystem: \u0022 \u002B arg.cmd.FullName))\n\t\t\t{\n\t\t\t\targ.cmd.Call(arg);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Error: \u0022 \u002B arg.cmd.FullName \u002B \u0022 - \u0022 \u002B ex.Message \u002B \u0022 (\u0022 \u002B ex.Source \u002B \u0022)\u0022);\n\t\t\tDebug.LogException(ex);\n\t\t\treturn false;\n\t\t}\n\t\tif (arg.cmd.Variable \u0026\u0026 arg.cmd.GetOveride != null \u0026\u0026 string.IsNullOrWhiteSpace(arg.Reply))\n\t\t{\n\t\t\tstring @string = arg.cmd.String;\n\t\t\tstring text = (arg.cmd.Variable ? arg.cmd.String : \u0022\u0022);\n\t\t\tif (text != @string)\n\t\t\t{\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\targ.ReplyWith($\u0022{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}\u0022);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "IOnRunCommandLine()",
    "MethodSignature": "UpdateValuesFromCommandLine()",
    "MethodSourseCode": "\n\tpublic static void UpdateValuesFromCommandLine()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRunCommandLine\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (KeyValuePair\u003Cstring, string\u003E @switch in Facepunch.CommandLine.GetSwitches())\n\t\t{\n\t\t\tstring text = @switch.Value;\n\t\t\tif (text == \u0022\u0022)\n\t\t\t{\n\t\t\t\ttext = \u00221\u0022;\n\t\t\t}\n\t\t\tstring strCommand = @switch.Key.Substring(1);\n\t\t\tRun(Option.Unrestricted, strCommand, text);\n\t\t}\n\t}\n",
    "ClassName": "ConsoleSystem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "Loaded()",
    "MethodSignature": "HandleAddedToManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleAddedToManager(PluginManager manager)\n\t{\n\t\tbase.HandleAddedToManager(manager);\n\t\tif (base.Filename != null)\n\t\t{\n\t\t\tWatcher.AddMapping(base.Name);\n\t\t}\n\t\tforeach (string key in pluginReferenceFields.Keys)\n\t\t{\n\t\t\tpluginReferenceFields[key].SetValue(this, manager.GetPlugin(key));\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tOnCallHook(\u0022Loaded\u0022, null);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tInterface.Oxide.LogException($\u0022Failed to initialize plugin \u0027{base.Name} v{base.Version}\u0027\u0022, ex);\n\t\t\tbase.Loader.PluginErrors[base.Name] = ex.Message;\n\t\t}\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnFrame(object[] args)",
    "MethodSignature": "OnFrame(float delta)",
    "MethodSourseCode": "\n\tprivate void OnFrame(float delta)\n\t{\n\t\tobject[] args = new object[1] { delta };\n\t\tforeach (KeyValuePair\u003Cstring, Plugin\u003E loadedPlugin in loader.LoadedPlugins)\n\t\t{\n\t\t\tif (loadedPlugin.Value is CSharpPlugin { HookedOnFrame: not false } cSharpPlugin)\n\t\t\t{\n\t\t\t\tcSharpPlugin.CallHook(\u0022OnFrame\u0022, args);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CSharpExtension",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "Unload()",
    "MethodSignature": "HandleRemovedFromManager(PluginManager manager)",
    "MethodSourseCode": "\n\tpublic override void HandleRemovedFromManager(PluginManager manager)\n\t{\n\t\tif (base.IsLoaded)\n\t\t{\n\t\t\tCallHook(\u0022Unload\u0022, null);\n\t\t}\n\t\tWatcher.RemoveMapping(base.Name);\n\t\tforeach (string key in pluginReferenceFields.Keys)\n\t\t{\n\t\t\tpluginReferenceFields[key].SetValue(this, null);\n\t\t}\n\t\tbase.HandleRemovedFromManager(manager);\n\t}\n",
    "ClassName": "CSharpPlugin",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMagazineReload(BaseProjectile baseProjectile, int desiredAmount, BasePlayer ownerPlayer)",
    "MethodSignature": "ReloadMagazine(int desiredAmount)",
    "MethodSourseCode": "\n\tprotected virtual void ReloadMagazine(int desiredAmount = -1)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif ((bool)ownerPlayer \u0026\u0026 Interface.CallHook(\u0022OnMagazineReload\u0022, this, desiredAmount, ownerPlayer) == null)\n\t\t{\n\t\t\tprimaryMagazine.Reload(ownerPlayer, desiredAmount);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItemManager.DoRemoves();\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnWorldPrefabSpawned(UnityEngine.GameObject gameObject, string category)",
    "MethodSignature": "Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)",
    "MethodSourseCode": "\n\tprivate static void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)\n\t{\n\t\tif (prefab != null \u0026\u0026 (bool)prefab.Object)\n\t\t{\n\t\t\tif (!Cached)\n\t\t\t{\n\t\t\t\tprefab.ApplyTerrainPlacements(position, rotation, scale);\n\t\t\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\n\t\t\t}\n\t\t\tGameObject gameObject = prefab.Spawn(position, rotation, scale);\n\t\t\tif ((bool)gameObject)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnWorldPrefabSpawned\u0022, gameObject, category);\n\t\t\t\tGameObjectEx.SetHierarchyGroup(gameObject, category);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "World",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnNpcTarget(HumanNPC humanNPC, BaseEntity player)",
    "MethodSignature": "GetBestTarget()",
    "MethodSourseCode": "\n\tpublic BaseEntity GetBestTarget()\n\t{\n\t\tBaseEntity result = null;\n\t\tfloat num = -1f;\n\t\tforeach (BaseEntity player in Brain.Senses.Players)\n\t\t{\n\t\t\tif (!(player == null) \u0026\u0026 !(player.Health() \u003C= 0f) \u0026\u0026 Interface.CallHook(\u0022OnNpcTarget\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tfloat value = Vector3.Distance(player.transform.position, base.transform.position);\n\t\t\t\tfloat num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);\n\t\t\t\tfloat value2 = Vector3.Dot((player.transform.position - eyes.position).normalized, eyes.BodyForward());\n\t\t\t\tnum2 \u002B= Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;\n\t\t\t\tnum2 \u002B= (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);\n\t\t\t\tif (num2 \u003E num)\n\t\t\t\t{\n\t\t\t\t\tresult = player;\n\t\t\t\t\tnum = num2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnFishingStopped(BaseFishingRod baseFishingRod, BaseFishingRod.FailReason reason)",
    "MethodSignature": "Server_Cancel(FailReason reason)",
    "MethodSourseCode": "\n\tprivate void Server_Cancel(FailReason reason)\n\t{\n\t\tif (GetItem() != null)\n\t\t{\n\t\t\tGetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);\n\t\t}\n\t\tSetFlag(Flags.Busy, b: false);\n\t\tUpdateFlags();\n\t\tCancelInvoke(CatchProcess);\n\t\tCurrentState = CatchState.None;\n\t\tSetFlag(Flags.Reserved1, b: false);\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tif (fishingBobber != null)\n\t\t{\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t}\n\t\tClientRPC(null, \u0022Client_ResetLine\u0022, (int)reason);\n\t\tInterface.CallHook(\u0022OnFishingStopped\u0022, this, reason);\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, CarvablePumpkin carvablePumpkin)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "CarvablePumpkin",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBigWheelWin(BigWheelGame bigWheelGame, Item slot, BigWheelBettingTerminal terminal, int num)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tGuid value = Guid.NewGuid();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tint amount = slot.amount;\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) == null)\n\t\t\t\t{\n\t\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (slot2 != null \u0026\u0026 Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) == null)\n\t\t\t\t{\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(null, \u0022WinOrLoseSound\u0022, flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnPlayerLootEnd(PlayerLoot playerLoot)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\tpublic void Clear()\n\t{\n\t\tif (!IsLooting())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerLootEnd\u0022, this);\n\t\tMarkDirty();\n\t\tif ((bool)entitySource)\n\t\t{\n\t\t\tentitySource.SendMessage(\u0022PlayerStoppedLooting\u0022, base.baseEntity, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tforeach (ItemContainer container in containers)\n\t\t{\n\t\t\tif (container != null)\n\t\t\t{\n\t\t\t\tcontainer.onDirty -= MarkDirty;\n\t\t\t}\n\t\t}\n\t\tcontainers.Clear();\n\t\tentitySource = null;\n\t\titemSource = null;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnFuelAmountCheck(EntityFuelSystem entityFuelSystem, Item fuelItem)",
    "MethodSignature": "GetFuelAmount()",
    "MethodSourseCode": "\n\tpublic int GetFuelAmount()\n\t{\n\t\tItem fuelItem = GetFuelItem();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelAmountCheck\u0022, this, fuelItem);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelItem == null || fuelItem.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn fuelItem.amount;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnNpcEquipWeapon(ScientistNPC scientistNPC, Item item)",
    "MethodSignature": "EquipWeapon(bool skipDeployDelay)",
    "MethodSourseCode": "\n\tpublic override void EquipWeapon(bool skipDeployDelay = false)\n\t{\n\t\tbase.EquipWeapon(skipDeployDelay);\n\t\tHeldEntity heldEntity = GetHeldEntity();\n\t\tif (!(heldEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item = heldEntity.GetItem();\n\t\tif (item == null || item.contents == null || Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0, 3) == 0)\n\t\t{\n\t\t\tItem item2 = ItemManager.CreateByName(\u0022weapon.mod.flashlight\u0022, 1, 0uL);\n\t\t\tif (!item2.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem2.Remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlightsOn = false;\n\t\t\tInvokeRandomized(base.LightCheck, 0f, 30f, 5f);\n\t\t\tLightCheck();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tItem item3 = ItemManager.CreateByName(\u0022weapon.mod.lasersight\u0022, 1, 0uL);\n\t\t\tif (!item3.MoveToContainer(item.contents))\n\t\t\t{\n\t\t\t\titem3.Remove();\n\t\t\t}\n\t\t\tLightToggle();\n\t\t\tlightsOn = true;\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnResearchCostDetermine(ItemDefinition info)",
    "MethodSignature": "ScrapForResearch(ItemDefinition info, ResearchType type)",
    "MethodSourseCode": "\n\tpublic static int ScrapForResearch(ItemDefinition info, ResearchType type)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, info);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint num = 0;\n\t\tif (info.rarity == Rarity.Common)\n\t\t{\n\t\t\tnum = 20;\n\t\t}\n\t\tif (info.rarity == Rarity.Uncommon)\n\t\t{\n\t\t\tnum = 75;\n\t\t}\n\t\tif (info.rarity == Rarity.Rare)\n\t\t{\n\t\t\tnum = 125;\n\t\t}\n\t\tif (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)\n\t\t{\n\t\t\tnum = 500;\n\t\t}\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null)\n\t\t{\n\t\t\tBaseGameMode.ResearchCostResult scrapCostForResearch = activeGameMode.GetScrapCostForResearch(info, type);\n\t\t\tif (scrapCostForResearch.Scale.HasValue)\n\t\t\t{\n\t\t\t\tnum = Mathf.RoundToInt((float)num * scrapCostForResearch.Scale.Value);\n\t\t\t}\n\t\t\telse if (scrapCostForResearch.Amount.HasValue)\n\t\t\t{\n\t\t\t\tnum = scrapCostForResearch.Amount.Value;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)",
    "MethodSignature": "AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)",
    "MethodSourseCode": "\n\tpublic void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);\n\t\tItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);\n\t\tif (!(itemDefinition == null) \u0026\u0026 !(itemDefinition2 == null))\n\t\t{\n\t\t\tcurrencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);\n\t\t\titemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);\n\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();\n\t\t\tsellOrder.ShouldPool = false;\n\t\t\tsellOrder.itemToSellID = itemToSellID;\n\t\t\tsellOrder.itemToSellAmount = itemToSellAmount;\n\t\t\tsellOrder.currencyID = currencyToUseID;\n\t\t\tsellOrder.currencyAmountPerItem = currencyAmount;\n\t\t\tsellOrder.currencyIsBP = bpState == 3 || bpState == 2;\n\t\t\tsellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;\n\t\t\tInterface.CallHook(\u0022OnAddVendingOffer\u0022, this, sellOrder);\n\t\t\tsellOrders.sellOrders.Add(sellOrder);\n\t\t\tRefreshSellOrderStockLevel(itemDefinition);\n\t\t\tUpdateMapMarker();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnFlameExplosion(FlameExplosive flameExplosive, UnityEngine.Collider component)",
    "MethodSignature": "FlameExplode(Vector3 surfaceNormal)",
    "MethodSourseCode": "\n\tpublic void FlameExplode(Vector3 surfaceNormal)\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = base.transform.position;\n\t\tif (blockCreateUnderwater \u0026\u0026 WaterLevel.Test(position))\n\t\t{\n\t\t\tbase.Explode();\n\t\t\treturn;\n\t\t}\n\t\tCollider component = GetComponent\u003CCollider\u003E();\n\t\tif ((bool)component)\n\t\t{\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t\tfor (int i = 0; (float)i \u003C numToCreate; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tfloat num = (float)i / numToCreate;\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);\n\t\t\t\tbaseEntity.transform.SetPositionAndRotation(position, Quaternion.LookRotation(modifiedAimConeDirection));\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tInterface.CallHook(\u0022OnFlameExplosion\u0022, this, component);\n\t\t\t\tVector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));\n\t\t\t\tFireBall component2 = baseEntity.GetComponent\u003CFireBall\u003E();\n\t\t\t\tif (component2 != null)\n\t\t\t\t{\n\t\t\t\t\tcomponent2.SetDelayedVelocity(vector);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseEntity.SetVelocity(vector);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbase.Explode();\n\t}\n",
    "ClassName": "FlameExplosive",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnExperimentStart(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnOvenCooked(BaseOven baseOven, Item item, BaseEntity slot)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null \u0026\u0026 !CanRunWithNoFuel)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in base.inventory.itemList)\n\t\t{\n\t\t\tif (item2.position \u003E= _inputSlotIndex \u0026\u0026 item2.position \u003C _inputSlotIndex \u002B inputSlots \u0026\u0026 !item2.HasFlag(Item.Flag.Cooking))\n\t\t\t{\n\t\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\n\t\t\t\titem2.MarkDirty();\n\t\t\t}\n\t\t}\n\t\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\tItemModBurnable component = item.info.GetComponent\u003CItemModBurnable\u003E();\n\t\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t\t{\n\t\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tif (item.fuel \u003C= 0f)\n\t\t\t{\n\t\t\t\tConsumeFuel(item, component);\n\t\t\t}\n\t\t}\n\t\tOnCooked();\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnMissionFailed(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)",
    "MethodSignature": "MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)",
    "MethodSourseCode": "\n\tpublic virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)\n\t{\n\t\tassignee.ChatMessage(\u0022You have failed the mission : \u0022 \u002B missionName.english);\n\t\tDoMissionEffect(failedEffect.resourcePath, assignee);\n\t\tFacepunch.Rust.Analytics.Server.MissionFailed(this, failReason);\n\t\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);\n\t\tinstance.status = MissionStatus.Failed;\n\t\tMissionEnded(instance, assignee);\n\t\tInterface.CallHook(\u0022OnMissionFailed\u0022, this, instance, assignee, failReason);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnMlrsFiringEnded(MLRS mLRS)",
    "MethodSignature": "EndFiring()",
    "MethodSourseCode": "\n\tpublic void EndFiring()\n\t{\n\t\tCancelInvoke(FireNextRocket);\n\t\trocketOwnerRef.Set(null);\n\t\tif (TryGetAimingModule(out var item))\n\t\t{\n\t\t\titem.LoseCondition(1f);\n\t\t}\n\t\tSetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate_Flags();\n\t\ttimeSinceBroken = 0f;\n\t\tInterface.CallHook(\u0022OnMlrsFiringEnded\u0022, this);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnVehicleModuleSelected(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItemId itemUID = msg.read.ItemID();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result))\n\t\t{\n\t\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container2))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 42
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tResetRemovalTime();\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamDisband(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tFacepunch.Pool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignUpdated(CarvablePumpkin carvablePumpkin, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanUpdateSign(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= paintableSources.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit() \u0026\u0026 !msg.player.IsAdmin)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022{msg.player} tried to upload a sign from a file but they aren\u0027t admin, ignoring\u0022);\n\t\t\treturn;\n\t\t}\n\t\tEnsureInitialized();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\n\t\t}\n\t\tLogEdit(msg.player);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t}\n",
    "ClassName": "CarvablePumpkin",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag2)",
    "MethodSignature": "SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tSleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);\n\t\tSleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) =\u003E x.ValidForPlayer(player2.userID, ignoreTimers: false) \u0026\u0026 x.net.ID == sleepingBag \u0026\u0026 x.unlockTime \u003C UnityEngine.Time.realtimeSinceStartup);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, player, sleepingBag2);\n\t\tif (obj is SleepingBag)\n\t\t{\n\t\t\tsleepingBag2 = (SleepingBag)obj;\n\t\t}\n\t\tif (sleepingBag2.IsOccupied())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tsleepingBag2.GetSpawnPos(out var pos, out var rot);\n\t\tplayer2.RespawnAt(pos, rot, sleepingBag2);\n\t\tsleepingBag2.PostPlayerSpawn(player2);\n\t\tSleepingBag[] array2 = array;\n\t\tfor (int i = 0; i \u003C array2.Length; i\u002B\u002B)\n\t\t{\n\t\t\tSetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnInventoryItemsTake(PlayerInventory playerInventory, System.Collections.Generic.List\u003CItem\u003E collect, int itemid, int amount)",
    "MethodSignature": "Take(List\u003CItem\u003E collect, int itemid, int amount)",
    "MethodSourseCode": "\n\tpublic int Take(List\u003CItem\u003E collect, int itemid, int amount)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemsTake\u0022, this, collect, itemid, amount);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint num = 0;\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tint num2 = containerMain.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num2;\n\t\t\tamount -= num2;\n\t\t}\n\t\tif (amount \u003C= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tint num3 = containerBelt.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num3;\n\t\t\tamount -= num3;\n\t\t}\n\t\tif (amount \u003C= 0)\n\t\t{\n\t\t\treturn num;\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tint num4 = containerWear.Take(collect, itemid, amount);\n\t\t\tnum \u002B= num4;\n\t\t\tamount -= num4;\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnClientDisconnect(Network.Connection packetConnection, string text)",
    "MethodSignature": "ReadDisconnectReason(Message packet)",
    "MethodSourseCode": "\n\tpublic void ReadDisconnectReason(Message packet)\n\t{\n\t\tstring text = packet.read.String(4096);\n\t\tstring text2 = packet.connection.ToString();\n\t\tif (!string.IsNullOrEmpty(text) \u0026\u0026 !string.IsNullOrEmpty(text2))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnClientDisconnect\u0022, packet.connection, text);\n\t\t\tDebugEx.Log(text2 \u002B \u0022 disconnecting: \u0022 \u002B text);\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnDispenserBonus(ResourceDispenser resourceDispenser, BasePlayer player, Item item)",
    "MethodSignature": "AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)",
    "MethodSourseCode": "\n\tpublic void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)\n\t{\n\t\tSendMessage(\u0022FinishBonusAssigned\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tif (fraction \u003C= 0f || finishBonus == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount finishBonu in finishBonus)\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));\n\t\t\tint num2 = CalculateGatherBonus(player, finishBonu, num);\n\t\t\tItem item = ItemManager.Create(finishBonu.itemDef, num \u002B num2, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnDispenserBonus\u0022, this, player, item);\n\t\t\t\tif (obj is Item)\n\t\t\t\t{\n\t\t\t\t\titem = (Item)obj;\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\n\t\t\t\tplayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnTurretToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetIsOnline(bool online)",
    "MethodSourseCode": "\n\tpublic void SetIsOnline(bool online)\n\t{\n\t\tif (online != HasFlag(Flags.On) \u0026\u0026 Interface.CallHook(\u0022OnTurretToggle\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, online);\n\t\t\tbooting = false;\n\t\t\tGetAttachedWeapon()?.SetLightsOn(online);\n\t\t\tSendNetworkUpdate();\n\t\t\tif (IsOffline())\n\t\t\t{\n\t\t\t\tSetTarget(null);\n\t\t\t\tisLootable = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tisLootable = false;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnXmasGiftsDistribute(XMasRefill xMasRefill, BasePlayer player)",
    "MethodSignature": "DistributeGiftsForPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool DistributeGiftsForPlayer(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnXmasGiftsDistribute\u0022, this, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tint num = GiftsPerPlayer();\n\t\tint num2 = GiftSpawnAttempts();\n\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t{\n\t\t\tif (num \u003C= 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tVector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();\n\t\t\tVector3 pos = player.transform.position \u002B new Vector3(vector.x, 10f, vector.y);\n\t\t\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\n\t\t\tif (DropToGround(ref pos))\n\t\t\t{\n\t\t\t\tstring resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);\n\t\t\t\tif ((bool)baseEntity)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity.Spawn();\n\t\t\t\t\tnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "XMasRefill",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemDropped(Item item, BaseEntity baseEntity)",
    "MethodSignature": "Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation)",
    "MethodSourseCode": "\n\tpublic BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))\n\t{\n\t\tRemoveFromWorld();\n\t\tBaseEntity baseEntity = null;\n\t\tif (vPos != Vector3.zero \u0026\u0026 !info.HasFlag(ItemDefinition.Flag.NoDropping))\n\t\t{\n\t\t\tbaseEntity = CreateWorldObject(vPos, rotation);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(vVelocity);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tRemove();\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemDropped\u0022, this, baseEntity);\n\t\tRemoveFromContainer();\n\t\treturn baseEntity;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "CanUseHelicopter(BasePlayer player, CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "AttemptMount(BasePlayer player, bool doMountChecks)",
    "MethodSourseCode": "\n\tpublic override void AttemptMount(BasePlayer player, bool doMountChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanUseHelicopter\u0022, player, this) == null)\n\t\t{\n\t\t\tbase.AttemptMount(player, doMountChecks);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcRadioChatter(ScientistNPC scientistNPC)",
    "MethodSignature": "PlayRadioChatter()",
    "MethodSourseCode": "\n\tpublic void PlayRadioChatter()\n\t{\n\t\tif (RadioChatterEffects.Length != 0)\n\t\t{\n\t\t\tif (base.IsDestroyed || base.transform == null)\n\t\t\t{\n\t\t\t\tCancelInvoke(PlayRadioChatter);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnNpcRadioChatter\u0022, this) == null)\n\t\t\t{\n\t\t\t\tEffect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t\t\tQueueRadioChatter();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnVehicleModuleSelect(Item vehicleItem, ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_SelectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_SelectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItemId itemUID = msg.read.ItemID();\n\t\tif (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem vehicleItem = carOccupant.GetVehicleItem(itemUID);\n\t\tif (vehicleItem == null || Interface.CallHook(\u0022OnVehicleModuleSelect\u0022, vehicleItem, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\n\t\tif (TryGetModuleForItem(vehicleItem, out var result))\n\t\t{\n\t\t\tif (result is VehicleModuleStorage vehicleModuleStorage)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container = vehicleModuleStorage.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (result is VehicleModuleCamper vehicleModuleCamper)\n\t\t\t{\n\t\t\t\tIItemContainerEntity container2 = vehicleModuleCamper.GetContainer();\n\t\t\t\tif (!ObjectEx.IsUnityNull(container2))\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.loot.AddContainer(container2.inventory);\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModuleSelected\u0022, vehicleItem, this, player);\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnAnalysisComplete(SurveyCrater surveyCrater, BasePlayer msgPlayer)",
    "MethodSignature": "AnalysisComplete(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AnalysisComplete(RPCMessage msg)\n\t{\n\t\tInterface.CallHook(\u0022OnAnalysisComplete\u0022, this, msg.player);\n\t}\n",
    "ClassName": "SurveyCrater",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnMapMarkerRemove(BasePlayer basePlayer, System.Collections.Generic.List\u003CProtoBuf.MapNote\u003E StatePointsOfInterest, int num)",
    "MethodSignature": "Server_RemovePointOfInterest(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(10uL)]\n\t[RPC_Server]\n\tpublic void Server_RemovePointOfInterest(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (State.pointsOfInterest != null \u0026\u0026 State.pointsOfInterest.Count \u003E num \u0026\u0026 num \u003E= 0 \u0026\u0026 Interface.CallHook(\u0022OnMapMarkerRemove\u0022, this, State.pointsOfInterest, num) == null)\n\t\t{\n\t\t\tState.pointsOfInterest[num].Dispose();\n\t\t\tState.pointsOfInterest.RemoveAt(num);\n\t\t\tDirtyPlayerState();\n\t\t\tSendMarkersToClient();\n\t\t\tTeamUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnMessagePlayer(string msg, BasePlayer basePlayer)",
    "MethodSignature": "ChatMessage(string msg)",
    "MethodSourseCode": "\n\tpublic void ChatMessage(string msg)\n\t{\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnMessagePlayer\u0022, msg, this) == null)\n\t\t{\n\t\t\tSendConsoleCommand(\u0022chat.add\u0022, 2, 0, msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSendModelState(BasePlayer basePlayer)",
    "MethodSignature": "SendModelState(bool force)",
    "MethodSourseCode": "\n\tpublic void SendModelState(bool force = false)\n\t{\n\t\tif (!force \u0026\u0026 (!wantsSendModelState || nextModelStateUpdate \u003E UnityEngine.Time.time))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\twantsSendModelState = false;\n\t\tnextModelStateUpdate = UnityEngine.Time.time \u002B 0.1f;\n\t\tif (!IsDead() \u0026\u0026 !IsSpectating())\n\t\t{\n\t\t\tmodelState.sleeping = IsSleeping();\n\t\t\tmodelState.mounted = isMounted;\n\t\t\tmodelState.relaxed = IsRelaxed();\n\t\t\tmodelState.onPhone = HasActiveTelephone \u0026\u0026 !activeTelephone.IsMobile;\n\t\t\tmodelState.crawling = IsCrawling();\n\t\t\tif (!base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSendModelState\u0022, this) == null)\n\t\t\t{\n\t\t\t\tClientRPC(null, \u0022OnModelState\u0022, modelState);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "CanUseWires(BasePlayer player)",
    "MethodSignature": "CanPlayerUseWires(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic static bool CanPlayerUseWires(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseWires\u0022, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CCollider\u003E obj2 = Facepunch.Pool.GetList\u003CCollider\u003E();\n\t\tGamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);\n\t\tbool result = obj2.All((Collider collider) =\u003E collider.gameObject.CompareTag(\u0022IgnoreWireCheck\u0022));\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\treturn result;\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCrateHackEnd(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "HackProgress()",
    "MethodSourseCode": "\n\tpublic void HackProgress()\n\t{\n\t\thackSeconds \u002B= 1f;\n\t\tif (hackSeconds \u003E requiredHackSeconds)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateHackEnd\u0022, this);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(OriginalHackerPlayer, this);\n\t\t\tRefreshDecay();\n\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\tisLootable = true;\n\t\t\tCancelInvoke(HackProgress);\n\t\t}\n\t\tClientRPC(null, \u0022UpdateHackProgress\u0022, (int)hackSeconds, (int)requiredHackSeconds);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnBonusItemDrop(Item item, BasePlayer basePlayer)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer) == null)\n\t\t\t{\n\t\t\t\t(item.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, ItemModDeployable modDeployable, BaseEntity baseEntity)",
    "MethodSignature": "DoDeploy_Regular(Deployable deployable, Ray ray)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Regular(Deployable deployable, Ray ray)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at player position!\u0022);\n\t\t}\n\t\telse if (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredAntiHack())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022AntiHack!\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tQuaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\tif (ownerPlayer.Distance(point) \u003E 3f)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Too far away!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at placement position!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tDebug.LogWarning(\u0022Couldn\u0027t create prefab:\u0022 \u002B modDeployable.entityPrefab.resourcePath);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tbaseEntity.SendMessage(\u0022SetDeployedBy\u0022, ownerPlayer, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity.Spawn();\n\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, modDeployable, baseEntity);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\n\t\t\tUseItemAmount(1);\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "CanExplosiveStick(TimedExplosive timedExplosive, BaseEntity entity)",
    "MethodSignature": "CanStickTo(BaseEntity entity)",
    "MethodSourseCode": "\n\tpublic virtual bool CanStickTo(BaseEntity entity)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanExplosiveStick\u0022, this, entity);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (entity.TryGetComponent\u003CDecorDeployable\u003E(out var _))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (entity is Drone)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemCraftCancelled(ItemCraftTask itemCraftTask)",
    "MethodSignature": "CancelTask(int iID, bool ReturnItems)",
    "MethodSourseCode": "\n\tpublic bool CancelTask(int iID, bool ReturnItems)\n\t{\n\t\tif (queue.Count == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) =\u003E x.taskUID == iID \u0026\u0026 !x.cancelled);\n\t\tif (itemCraftTask == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemCraftTask.cancelled = true;\n\t\tif (itemCraftTask.owner == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemCraftCancelled\u0022, itemCraftTask);\n\t\titemCraftTask.owner.Command(\u0022note.craft_done\u0022, itemCraftTask.taskUID, 0);\n\t\tif (itemCraftTask.takenItems != null \u0026\u0026 itemCraftTask.takenItems.Count \u003E 0 \u0026\u0026 ReturnItems)\n\t\t{\n\t\t\tforeach (Item takenItem in itemCraftTask.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem != null \u0026\u0026 takenItem.amount \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tif (takenItem.IsBlueprint() \u0026\u0026 takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.UseItem(itemCraftTask.numCrafted);\n\t\t\t\t\t}\n\t\t\t\t\tif (takenItem.amount \u003E 0 \u0026\u0026 !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))\n\t\t\t\t\t{\n\t\t\t\t\t\ttakenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition \u002B UnityEngine.Random.value * Vector3.down \u002B UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);\n\t\t\t\t\t\titemCraftTask.owner.Command(\u0022note.inv\u0022, takenItem.info.itemid, -takenItem.amount);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnItemUpgrade(Item item, Item item2, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (!(command == \u0022upgrade_item\u0022) || item.amount \u003C numForUpgrade)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= upgradeSuccessChance)\n\t\t{\n\t\t\titem.UseItem(numForUpgrade);\n\t\t\tItem item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);\n\t\t\tInterface.CallHook(\u0022OnItemUpgrade\u0022, item, item2, player);\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem(numToLoseOnFail);\n\t\t\tif (failEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(failEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModUpgrade",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnBuildingSplit(BuildingManager.Building building, uint newID)",
    "MethodSignature": "Split(Building building)",
    "MethodSourseCode": "\n\tprivate void Split(Building building)\n\t{\n\t\twhile (building.HasBuildingBlocks())\n\t\t{\n\t\t\tBuildingBlock buildingBlock = building.buildingBlocks[0];\n\t\t\tuint newID = BuildingManager.server.NewBuildingID();\n\t\t\tInterface.CallHook(\u0022OnBuildingSplit\u0022, building, newID);\n\t\t\tbuildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)\n\t\t\t{\n\t\t\t\tb.AttachToBuilding(newID);\n\t\t\t});\n\t\t}\n\t\twhile (building.HasBuildingPrivileges())\n\t\t{\n\t\t\tBuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];\n\t\t\tBuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();\n\t\t\tbuildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);\n\t\t}\n\t\twhile (building.HasDecayEntities())\n\t\t{\n\t\t\tDecayEntity decayEntity = building.decayEntities[0];\n\t\t\tBuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();\n\t\t\tdecayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);\n\t\t}\n\t\tif (AI.nav_carve_use_building_optimization)\n\t\t{\n\t\t\tbuilding.isNavMeshCarvingDirty = true;\n\t\t\tint ticks = 2;\n\t\t\tUpdateNavMeshCarver(building, ref ticks, 0);\n\t\t}\n\t}\n",
    "ClassName": "ServerBuildingManager",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)",
    "MethodSignature": "StartFiring(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void StartFiring(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (OnCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!RequiresPumping)\n\t\t{\n\t\t\tpressure = MaxPressure;\n\t\t}\n\t\tif (CanFire(player))\n\t\t{\n\t\t\tCancelInvoke(\u0022FireTick\u0022);\n\t\t\tInvokeRepeating(\u0022FireTick\u0022, 0f, FireRate);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tStartCooldown(FireRate);\n\t\t\tif (base.isServer)\n\t\t\t{\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnLiquidWeaponFired\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "CanDropActiveItem(BasePlayer basePlayer)",
    "MethodSignature": "ShouldDropActiveItem()",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldDropActiveItem()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDropActiveItem\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretRotate(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "FlipAim(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void FlipAim(RPCMessage rpc)\n\t{\n\t\tif (!IsOnline() \u0026\u0026 IsAuthed(rpc.player) \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretRotate\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanEntityBeHostile(BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic virtual bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn unHostileTime \u003E UnityEngine.Time.realtimeSinceStartup;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWaterCollect(WaterPump waterPump, ItemDefinition atPoint)",
    "MethodSignature": "CreateWater()",
    "MethodSourseCode": "\n\tpublic void CreateWater()\n\t{\n\t\tif (!IsFull())\n\t\t{\n\t\t\tItemDefinition atPoint = WaterResource.GetAtPoint(WaterResourceLocation.position);\n\t\t\tif (atPoint != null \u0026\u0026 Interface.CallHook(\u0022OnWaterCollect\u0022, this, atPoint) == null)\n\t\t\t{\n\t\t\t\tbase.inventory.AddItem(atPoint, AmountPerPump, 0uL);\n\t\t\t\tUpdateOnFlag();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WaterPump",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnMapMarkersCleared(BasePlayer basePlayer)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, State.pointsOfInterest) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tServerCurrentDeathNote?.Dispose();\n\t\tServerCurrentDeathNote = null;\n\t\tif (State.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in State.pointsOfInterest)\n\t\t\t{\n\t\t\t\titem?.Dispose();\n\t\t\t}\n\t\t\tState.pointsOfInterest.Clear();\n\t\t}\n\t\tDirtyPlayerState();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnNpcEquipWeapon(NPCPlayer nPCPlayer, Item slot)",
    "MethodSignature": "EquipWeapon(bool skipDeployDelay)",
    "MethodSourseCode": "\n\tpublic virtual void EquipWeapon(bool skipDeployDelay = false)\n\t{\n\t\tif (inventory == null || inventory.containerBelt == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem slot = inventory.containerBelt.GetSlot(0);\n\t\tif (Interface.CallHook(\u0022OnNpcEquipWeapon\u0022, this, slot) != null || slot == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);\n\t\tBaseEntity heldEntity = slot.GetHeldEntity();\n\t\tif (!(heldEntity != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAttackEntity component = heldEntity.GetComponent\u003CAttackEntity\u003E();\n\t\tif (component != null)\n\t\t{\n\t\t\tif (skipDeployDelay)\n\t\t\t{\n\t\t\t\tcomponent.ResetAttackCooldown();\n\t\t\t}\n\t\t\tcomponent.TopUpAmmo();\n\t\t}\n\t}\n",
    "ClassName": "NPCPlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnSignLocked(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHammerHit(BasePlayer ownerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void DoAttackShared(HitInfo info)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\n\t\tif (baseCombatEntity != null \u0026\u0026 ownerPlayer != null \u0026\u0026 base.isServer)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHammerHit\u0022, ownerPlayer, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022DoRepair\u0022, 50))\n\t\t\t{\n\t\t\t\tbaseCombatEntity.DoRepair(ownerPlayer);\n\t\t\t}\n\t\t}\n\t\tinfo.DoDecals = false;\n\t\tif (base.isServer)\n\t\t{\n\t\t\tEffect.server.ImpactEffect(info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEffect.client.ImpactEffect(info);\n\t\t}\n\t}\n",
    "ClassName": "Hammer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_RotateVM(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RotateVM(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRotateVendingMachine\u0022, this, msg.player) == null \u0026\u0026 CanRotate())\n\t\t{\n\t\t\tUpdateEmptyFlag();\n\t\t\tif (msg.player.CanBuild() \u0026\u0026 IsInventoryEmpty())\n\t\t\t{\n\t\t\t\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, GunTrap gunTrap)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tbool flag = false;\n\t\tif (entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity item in entityContents)\n\t\t\t{\n\t\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (component.IsSleeping() || !component.IsAlive())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\t\tif (obj2 is bool)\n\t\t\t\t{\n\t\t\t\t\tPool.FreeList(ref obj);\n\t\t\t\t\treturn (bool)obj2;\n\t\t\t\t}\n\t\t\t\tif (component.IsBuildingAuthed())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobj.Clear();\n\t\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "GunTrap",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerID, bool ignoreTimers)",
    "MethodSignature": "ValidForPlayer(ulong playerID, bool ignoreTimers)",
    "MethodSourseCode": "\n\tpublic virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnSleepingBagValidCheck\u0022, this, playerID, ignoreTimers);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (deployerUserID == playerID)\n\t\t{\n\t\t\tif (!ignoreTimers)\n\t\t\t{\n\t\t\t\treturn unlockTime \u003C UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)",
    "MethodSignature": "AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)",
    "MethodSourseCode": "\n\tpublic static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\n\t{\n\t\tif (!missionsenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!mission.IsEligableForMission(assignee, provider))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAssignMission\u0022, assignee, mission, provider);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tMissionInstance missionInstance = Pool.Get\u003CMissionInstance\u003E();\n\t\tmissionInstance.missionID = mission.id;\n\t\tmissionInstance.startTime = Time.time;\n\t\tmissionInstance.providerID = provider.ProviderID();\n\t\tmissionInstance.status = MissionStatus.Active;\n\t\tmissionInstance.createdEntities = Pool.GetList\u003CMissionEntity\u003E();\n\t\tmissionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];\n\t\tfor (int i = 0; i \u003C mission.objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tmissionInstance.objectiveStatuses[i] = new MissionInstance.ObjectiveStatus();\n\t\t}\n\t\tassignee.AddMission(missionInstance);\n\t\tmission.MissionStart(missionInstance, assignee);\n\t\tassignee.SetActiveMission(assignee.missions.Count - 1);\n\t\tassignee.MissionDirty();\n\t\tInterface.CallHook(\u0022OnMissionAssigned\u0022, mission, provider, assignee);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "CanHideStash(BasePlayer rpcPlayer, StashContainer stashContainer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnAmmoUnload(BaseProjectile component, Item item, BasePlayer player)",
    "MethodSignature": "UnloadAmmo(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void UnloadAmmo(Item item, BasePlayer player)\n\t{\n\t\tBaseProjectile component = item.GetHeldEntity().GetComponent\u003CBaseProjectile\u003E();\n\t\tif (!component.canUnloadAmmo || Interface.CallHook(\u0022OnAmmoUnload\u0022, component, item, player) != null || !component)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint contents = component.primaryMagazine.contents;\n\t\tif (contents \u003E 0)\n\t\t{\n\t\t\tcomponent.primaryMagazine.contents = 0;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItem item2 = ItemManager.Create(component.primaryMagazine.ammoType, contents, 0uL);\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain))\n\t\t\t{\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnAdventGiftAwarded(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "AwardGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AwardGift(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnAdventGiftAward\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tint num = now.Day - startDay;\n\t\tif (now.Month == startMonth \u0026\u0026 num \u003E= 0 \u0026\u0026 num \u003C days.Length)\n\t\t{\n\t\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t\t{\n\t\t\t\tplayerRewardHistory.Add(player.userID, new List\u003Cint\u003E());\n\t\t\t}\n\t\t\tplayerRewardHistory[player.userID].Add(num);\n\t\t\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C crosses.Length)\n\t\t\t{\n\t\t\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position \u002B Vector3.up * 1.5f);\n\t\t\t}\n\t\t\tDayReward dayReward = days[num];\n\t\t\tfor (int i = 0; i \u003C dayReward.rewards.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItemAmount itemAmount = dayReward.rewards[i];\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnAdventGiftAwarded\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnSignUpdated(PhotoFrame photoFrame, BasePlayer msgPlayer)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(5f)]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tbyte[] array = msg.read.BytesWithSize();\n\t\t\tif (array != null \u0026\u0026 ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveAllByEntity(net.ID);\n\t\t\t\t_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\n\t\t\t\tLogEdit(msg.player);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnDeleteVendingOffer(VendingMachine vendingMachine, int num)",
    "MethodSignature": "RPC_DeleteSellOrder(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_DeleteSellOrder(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tInterface.CallHook(\u0022OnDeleteVendingOffer\u0022, this, num);\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C sellOrders.sellOrders.Count)\n\t\t\t{\n\t\t\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);\n\t\t\t\tsellOrders.sellOrders.RemoveAt(num);\n\t\t\t}\n\t\t\tRefreshSellOrderStockLevel();\n\t\t\tUpdateMapMarker();\n\t\t\tSendSellOrders(player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerAssist(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Assist(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Assist(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerAssist\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tStopWounded(msg.player);\n\t\t\tmsg.player.stats.Add(\u0022wounded_assisted\u0022, 1, (Stats)5);\n\t\t\tstats.Add(\u0022wounded_healed\u0022, 1);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPortalUse(BasePlayer player, BasePortal basePortal)",
    "MethodSignature": "UsePortal(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void UsePortal(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPortalUse\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tLinkPortal();\n\t\tif (targetPortal != null)\n\t\t{\n\t\t\tplayer.PauseFlyHackDetection();\n\t\t\tplayer.PauseSpeedHackDetection();\n\t\t\tVector3 position = player.transform.position;\n\t\t\tVector3 vector = targetPortal.GetLocalEntryExitPosition();\n\t\t\tVector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\n\t\t\tVector3 vector3 = vector2;\n\t\t\tif (isMirrored)\n\t\t\t{\n\t\t\t\tVector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\n\t\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\n\t\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;\n\t\t\t}\n\t\t\tif (disappearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, Vector3.up);\n\t\t\t}\n\t\t\tif (appearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, Vector3.up);\n\t\t\t}\n\t\t\tplayer.SetParent(null, worldPositionStays: true);\n\t\t\tplayer.Teleport(vector);\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForceViewAnglesTo\u0022, vector3);\n\t\t\tif (transitionSoundEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tplayer.UpdateNetworkGroup();\n\t\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022StartLoading_Quick\u0022, arg1: true);\n\t\t\tInterface.CallHook(\u0022OnPortalUsed\u0022, player, this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.Log(\u0022No portal...\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePortal",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopAcceptClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "AcceptClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AcceptClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 !(vendorPlayer == null) \u0026\u0026 !(customerPlayer == null) \u0026\u0026 Interface.CallHook(\u0022OnShopAcceptClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tif (IsPlayerVendor(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\t\tvendorInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\telse if (IsPlayerCustomer(msg.player))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tcustomerInventory.SetLocked(isLocked: true);\n\t\t\t}\n\t\t\tif (HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t\t\tInvoke(CompleteTrade, 2f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnHelicopterAttacked(BaseHelicopter baseHelicopter, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterAttacked\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (info.damageTypes.Total() \u003E= base.health)\n\t\t{\n\t\t\tbase.health = 1000000f;\n\t\t\tmyAI.CriticalDamage();\n\t\t\tflag = true;\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif (flag)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tweakspot[] array = weakspots;\n\t\tforeach (weakspot weakspot in array)\n\t\t{\n\t\t\tstring[] bonenames = weakspot.bonenames;\n\t\t\tforeach (string str in bonenames)\n\t\t\t{\n\t\t\t\tif (info.HitBone == StringPool.Get(str))\n\t\t\t\t{\n\t\t\t\t\tweakspot.Hurt(info.damageTypes.Total(), info);\n\t\t\t\t\tmyAI.WeakspotDamaged(weakspot, info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseHelicopter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExperimentStarted(Workbench workbench, BasePlayer player)",
    "MethodSignature": "RPC_BeginExperiment(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_BeginExperiment(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null || IsWorking())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;\n\t\tint num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);\n\t\tfor (int i = 0; i \u003C experimentalItems.subSpawn.Length; i\u002B\u002B)\n\t\t{\n\t\t\tint num2 = i \u002B num;\n\t\t\tif (num2 \u003E= experimentalItems.subSpawn.Length)\n\t\t\t{\n\t\t\t\tnum2 -= experimentalItems.subSpawn.Length;\n\t\t\t}\n\t\t\tItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;\n\t\t\tif ((bool)itemDef.Blueprint \u0026\u0026 !itemDef.Blueprint.defaultBlueprint \u0026\u0026 itemDef.Blueprint.userCraftable \u0026\u0026 itemDef.Blueprint.isResearchable \u0026\u0026 !itemDef.Blueprint.NeedsSteamItem \u0026\u0026 !itemDef.Blueprint.NeedsSteamDLC \u0026\u0026 !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))\n\t\t\t{\n\t\t\t\tpendingBlueprint = itemDef;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022You have already unlocked everything for this workbench tier.\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnExperimentStart\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem slot = base.inventory.GetSlot(0);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tif (!slot.MoveToContainer(player.inventory.containerMain))\n\t\t\t\t{\n\t\t\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tif (experimentStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tCancelInvoke(ExperimentComplete);\n\t\t\tInvoke(ExperimentComplete, 5f);\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnExperimentStarted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 54
  },
  {
    "HookSignature": "OnEntityFromOwnerCheck(BaseEntity ent, BasePlayer player, uint id, string debugName)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityFromOwnerCheck\u0022, ent, player, id, debugName);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnFishCatch(Item item, BaseFishingRod baseFishingRod, BasePlayer ownerPlayer)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(null, \u0022Client_HookedSomething\u0022);\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(null, \u0022Client_UpdateFishState\u0022, (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tfishLookup.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\n\t\t\tClientRPC(null, \u0022Client_OnCaughtFish\u0022, currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 168
  },
  {
    "HookSignature": "OnPlayerTick(BasePlayer basePlayer, PlayerTick msg, bool wasPlayerStalled)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tResetInputIdleTime();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(msg.activeItem);\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (!IsIncapacitated())\n\t\t{\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t\t}\n\t\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\t\tUpdateRotationFromTick(msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_OpenShop(RPCMessage msg)\n\t{\n\t\tif (OccupiedCheck(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopOpen\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSendSellOrders(msg.player);\n\t\t\tPlayerOpenLoot(msg.player, customerPanel);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnMixingTableToggle(MixingTable mixingTable, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMixingTableToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag != IsOn() \u0026\u0026 !(msg.player == null))\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tStartMixing(msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStopMixing();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MixingTable",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTeamDisbanded(RelationshipManager.PlayerTeam teamToDisband)",
    "MethodSignature": "DisbandTeam(PlayerTeam teamToDisband)",
    "MethodSourseCode": "\n\tpublic void DisbandTeam(PlayerTeam teamToDisband)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamDisband\u0022, teamToDisband) == null)\n\t\t{\n\t\t\tteams.Remove(teamToDisband.teamID);\n\t\t\tInterface.CallHook(\u0022OnTeamDisbanded\u0022, teamToDisband);\n\t\t\tFacepunch.Pool.Free(ref teamToDisband);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerWound(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "BecomeWounded(HitInfo info)",
    "MethodSourseCode": "\n\tpublic void BecomeWounded(HitInfo info = null)\n\t{\n\t\tif (IsWounded() || Interface.CallHook(\u0022OnPlayerWound\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = info != null \u0026\u0026 info.damageTypes.GetMajorityDamageType() == DamageType.Fall;\n\t\tif (IsCrawling())\n\t\t{\n\t\t\twoundedByFallDamage |= flag;\n\t\t\tGoToIncapacitated(info);\n\t\t\treturn;\n\t\t}\n\t\twoundedByFallDamage = flag;\n\t\tif (flag || !ConVar.Server.crawlingenabled)\n\t\t{\n\t\t\tGoToIncapacitated(info);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGoToCrawling(info);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Die(HitInfo info = null)\n\t{\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Global.developer \u003E 1)\n\t\t{\n\t\t\tDebug.Log(\u0022[Combat]\u0022.PadRight(10) \u002B base.gameObject.name \u002B \u0022 died\u0022);\n\t\t}\n\t\thealth = 0f;\n\t\tlifestate = LifeState.Dead;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tif (info != null \u0026\u0026 (bool)info.InitiatorPlayer)\n\t\t{\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif (initiatorPlayer != null \u0026\u0026 initiatorPlayer.GetActiveMission() != -1 \u0026\u0026 !initiatorPlayer.IsNpc)\n\t\t\t{\n\t\t\t\tinitiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID.ToString(), 1f);\n\t\t\t}\n\t\t}\n\t\tusing (TimeWarning.New(\u0022OnKilled\u0022))\n\t\t{\n\t\t\tOnKilled(info);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnButtonPress(PressButton pressButton, BasePlayer msgPlayer)",
    "MethodSignature": "Press(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Press(RPCMessage msg)\n\t{\n\t\tif (!IsOn() \u0026\u0026 Interface.CallHook(\u0022OnButtonPress\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInvoke(UnpowerTime, pressPowerTime);\n\t\t\tSetFlag(Flags.Reserved3, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tMarkDirty();\n\t\t\tInvoke(Unpress, pressDuration);\n\t\t}\n\t}\n",
    "ClassName": "PressButton",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEyePosValidate(AttackEntity attackEntity, BasePlayer player, UnityEngine.Vector3 eyePos)",
    "MethodSignature": "ValidateEyePos(BasePlayer player, Vector3 eyePos)",
    "MethodSourseCode": "\n\tprotected bool ValidateEyePos(BasePlayer player, Vector3 eyePos)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEyePosValidate\u0022, this, player, eyePos);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tbool flag = true;\n\t\tif (eyePos.IsNaNOrInfinity())\n\t\t{\n\t\t\tstring shortPrefabName = base.ShortPrefabName;\n\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_nan\u0022);\n\t\t\tflag = false;\n\t\t}\n\t\tif (ConVar.AntiHack.eye_protection \u003E 0)\n\t\t{\n\t\t\tfloat num = 1f \u002B ConVar.AntiHack.eye_forgiveness;\n\t\t\tfloat eye_clientframes = ConVar.AntiHack.eye_clientframes;\n\t\t\tfloat eye_serverframes = ConVar.AntiHack.eye_serverframes;\n\t\t\tfloat num2 = eye_clientframes / 60f;\n\t\t\tfloat num3 = eye_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\tfloat num4 = (player.desyncTimeClamped \u002B num2 \u002B num3) * num;\n\t\t\tint layerMask = (ConVar.AntiHack.eye_terraincheck ? 10551296 : 2162688);\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 1)\n\t\t\t{\n\t\t\t\tfloat num5 = player.MaxVelocity() \u002B player.GetParentVelocity().magnitude;\n\t\t\t\tfloat num6 = player.BoundsPadding() \u002B num4 * num5;\n\t\t\t\tfloat num7 = Vector3.Distance(player.eyes.position, eyePos);\n\t\t\t\tif (num7 \u003E num6)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Distance (\u0022 \u002B shortPrefabName2 \u002B \u0022 on attack with \u0022 \u002B num7 \u002B \u0022m \u003E \u0022 \u002B num6 \u002B \u0022m)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_distance\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 3)\n\t\t\t{\n\t\t\t\tfloat num8 = Mathf.Abs(player.GetMountVelocity().y \u002B player.GetParentVelocity().y);\n\t\t\t\tfloat num9 = player.BoundsPadding() \u002B num4 * num8 \u002B player.GetJumpHeight();\n\t\t\t\tfloat num10 = Mathf.Abs(player.eyes.position.y - eyePos.y);\n\t\t\t\tif (num10 \u003E num9)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName3 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, \u0022Altitude (\u0022 \u002B shortPrefabName3 \u002B \u0022 on attack with \u0022 \u002B num10 \u002B \u0022m \u003E \u0022 \u002B num9 \u002B \u0022m)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_altitude\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 2)\n\t\t\t{\n\t\t\t\tVector3 center = player.eyes.center;\n\t\t\t\tVector3 position = player.eyes.position;\n\t\t\t\tVector3 vector = eyePos;\n\t\t\t\tif (!GamePhysics.LineOfSightRadius(center, position, layerMask, ConVar.AntiHack.eye_losradius) || !GamePhysics.LineOfSightRadius(position, vector, layerMask, ConVar.AntiHack.eye_losradius))\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName4, \u0022 on attack) \u0022, center, \u0022 \u0022, position, \u0022 \u0022, vector));\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_los\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ConVar.AntiHack.eye_protection \u003E= 4 \u0026\u0026 !player.HasParent())\n\t\t\t{\n\t\t\t\tVector3 position2 = player.eyes.position;\n\t\t\t\tVector3 vector2 = eyePos;\n\t\t\t\tfloat num11 = Vector3.Distance(position2, vector2);\n\t\t\t\tCollider collider;\n\t\t\t\tif (num11 \u003E ConVar.AntiHack.eye_noclip_cutoff)\n\t\t\t\t{\n\t\t\t\t\tif (AntiHack.TestNoClipping(position2, vector2, player.NoClipRadius(ConVar.AntiHack.eye_noclip_margin), ConVar.AntiHack.eye_noclip_backtracking, ConVar.AntiHack.noclip_protection \u003E= 2, out collider))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring shortPrefabName5 = base.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(\u0022NoClip (\u0022, shortPrefabName5, \u0022 on attack) \u0022, position2, \u0022 \u0022, vector2));\n\t\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_noclip\u0022);\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (num11 \u003E 0.01f \u0026\u0026 AntiHack.TestNoClipping(position2, vector2, 0.01f, ConVar.AntiHack.eye_noclip_backtracking, ConVar.AntiHack.noclip_protection \u003E= 2, out collider))\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.EyeHack, string.Concat(\u0022NoClip (\u0022, shortPrefabName6, \u0022 on attack) \u0022, position2, \u0022 \u0022, vector2));\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022eye_noclip\u0022);\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tAntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);\n\t\t\t}\n\t\t\telse if (ConVar.AntiHack.eye_protection \u003E= 5 \u0026\u0026 !player.HasParent() \u0026\u0026 !player.isMounted)\n\t\t\t{\n\t\t\t\tplayer.eyeHistory.PushBack(eyePos);\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "AttackEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEngineStatsRefresh(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardProtectionCalculated(BuildingPrivlidge buildingPrivlidge, float cachedProtectedMinutes)",
    "MethodSignature": "GetProtectedMinutes(bool force)",
    "MethodSourseCode": "\n\tpublic float GetProtectedMinutes(bool force = false)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (!force \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003C nextProtectedCalcTime)\n\t\t\t{\n\t\t\t\treturn cachedProtectedMinutes;\n\t\t\t}\n\t\t\tnextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup \u002B 60f;\n\t\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.GetList\u003CItemAmount\u003E();\n\t\t\tCalculateUpkeepCostAmounts(obj);\n\t\t\tfloat num = CalculateUpkeepPeriodMinutes();\n\t\t\tfloat num2 = -1f;\n\t\t\tif (base.inventory != null)\n\t\t\t{\n\t\t\t\tforeach (ItemAmount item in obj)\n\t\t\t\t{\n\t\t\t\t\tint num3 = base.inventory.FindItemsByItemID(item.itemid).Sum((Item x) =\u003E x.amount);\n\t\t\t\t\tif (num3 \u003E 0 \u0026\u0026 item.amount \u003E 0f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num4 = (float)num3 / item.amount * num;\n\t\t\t\t\t\tif (num2 == -1f || num4 \u003C num2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum2 = num4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2 = 0f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num2 == -1f)\n\t\t\t\t{\n\t\t\t\t\tnum2 = 0f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\tcachedProtectedMinutes = num2;\n\t\t\tInterface.CallHook(\u0022OnCupboardProtectionCalculated\u0022, this, cachedProtectedMinutes);\n\t\t\treturn cachedProtectedMinutes;\n\t\t}\n\t\treturn 0f;\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnMapMarkerAdded(BasePlayer basePlayer, ProtoBuf.MapNote mapNote)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(8uL)]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, MapNote.Deserialize(msg.read)) == null)\n\t\t{\n\t\t\tmsg.read.Position = 13L;\n\t\t\tif (State.pointsOfInterest == null)\n\t\t\t{\n\t\t\t\tState.pointsOfInterest = Facepunch.Pool.GetList\u003CMapNote\u003E();\n\t\t\t}\n\t\t\tif (State.pointsOfInterest.Count \u003E= ConVar.Server.maximumMapMarkers)\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMapNote mapNote = MapNote.Deserialize(msg.read);\n\t\t\tValidateMapNote(mapNote);\n\t\t\tmapNote.colourIndex = State.pointsOfInterest.Count;\n\t\t\tState.pointsOfInterest.Add(mapNote);\n\t\t\tDirtyPlayerState();\n\t\t\tSendMarkersToClient();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, mapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnPhoneAnswer(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPlayerColliderEnable(BasePlayer basePlayer, UnityEngine.CapsuleCollider playerCollider)",
    "MethodSignature": "EnablePlayerCollider()",
    "MethodSourseCode": "\n\tpublic void EnablePlayerCollider()\n\t{\n\t\tif (!playerCollider.enabled \u0026\u0026 Interface.CallHook(\u0022OnPlayerColliderEnable\u0022, this, playerCollider) == null)\n\t\t{\n\t\t\tRefreshColliderSize(forced: true);\n\t\t\tplayerCollider.enabled = true;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemAction(Item item, string text, BasePlayer msgPlayer)",
    "MethodSignature": "ItemCmd(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server]\n\t[BaseEntity.RPC_Server.FromOwner]\n\tprivate void ItemCmd(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (msg.player != null \u0026\u0026 msg.player.IsWounded())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemId id = msg.read.ItemID();\n\t\tstring text = msg.read.String();\n\t\tItem item = FindItemUID(id);\n\t\tif (item == null || Interface.CallHook(\u0022OnItemAction\u0022, item, text, msg.player) != null || item.IsLocked() || (item.parent != null \u0026\u0026 item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (text == \u0022drop\u0022)\n\t\t{\n\t\t\tint num = item.amount;\n\t\t\tif (msg.read.Unread \u003E= 4)\n\t\t\t{\n\t\t\t\tnum = msg.read.Int32();\n\t\t\t}\n\t\t\tbase.baseEntity.stats.Add(\u0022item_drop\u0022, 1, (Stats)5);\n\t\t\tif (num \u003C item.amount)\n\t\t\t{\n\t\t\t\tItem item2 = item.SplitItem(num);\n\t\t\t\tif (item2 != null)\n\t\t\t\t{\n\t\t\t\t\tDroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;\n\t\t\t\t\tif (droppedItem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Player;\n\t\t\t\t\t\tdroppedItem.DroppedBy = base.baseEntity.userID;\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;\n\t\t\t\tif (droppedItem2 != null)\n\t\t\t\t{\n\t\t\t\t\tdroppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;\n\t\t\t\t\tdroppedItem2.DroppedBy = base.baseEntity.userID;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, \u0022drop_item\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.ServerCommand(text, base.baseEntity);\n\t\t\tItemManager.DoRemoves();\n\t\t\tServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnEntityStabilityCheck(StabilityEntity stabilityEntity)",
    "MethodSignature": "StabilityCheck()",
    "MethodSourseCode": "\n\tpublic void StabilityCheck()\n\t{\n\t\tif (base.IsDestroyed || Interface.CallHook(\u0022OnEntityStabilityCheck\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (supports == null)\n\t\t{\n\t\t\tInitializeSupports();\n\t\t}\n\t\tbool flag = false;\n\t\tint num = DistanceFromGround();\n\t\tif (num != cachedDistanceFromGround)\n\t\t{\n\t\t\tcachedDistanceFromGround = num;\n\t\t\tflag = true;\n\t\t}\n\t\tfloat num2 = SupportValue();\n\t\tif (Mathf.Abs(cachedStability - num2) \u003E Stability.accuracy)\n\t\t{\n\t\t\tcachedStability = num2;\n\t\t\tflag = true;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tdirty = true;\n\t\t\tUpdateConnectedEntities();\n\t\t\tUpdateStability();\n\t\t}\n\t\telse if (dirty)\n\t\t{\n\t\t\tdirty = false;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (num2 \u003C Stability.collapse)\n\t\t{\n\t\t\tif (stabilityStrikes \u003C Stability.strikes)\n\t\t\t{\n\t\t\t\tUpdateStability();\n\t\t\t\tstabilityStrikes\u002B\u002B;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tKill(DestroyMode.Gib);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstabilityStrikes = 0;\n\t\t}\n\t}\n",
    "ClassName": "StabilityEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerStudyBlueprint(BasePlayer player, Item item)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (item.GetOwnerPlayer() != player)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tforeach (ItemContainer container in player.inventory.loot.containers)\n\t\t\t{\n\t\t\t\tif (item.GetRootContainer() == container)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!(command == \u0022study\u0022) || !item.IsBlueprint())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition blueprintTargetDef = item.blueprintTargetDef;\n\t\tItemBlueprint blueprint = blueprintTargetDef.Blueprint;\n\t\tbool flag2 = player.blueprints.IsUnlocked(blueprintTargetDef);\n\t\tif (flag2 \u0026\u0026 blueprint != null \u0026\u0026 blueprint.additionalUnlocks != null \u0026\u0026 blueprint.additionalUnlocks.Count \u003E 0)\n\t\t{\n\t\t\tforeach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)\n\t\t\t{\n\t\t\t\tif (!player.blueprints.IsUnlocked(additionalUnlock))\n\t\t\t\t{\n\t\t\t\t\tflag2 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (blueprint != null \u0026\u0026 blueprint.defaultBlueprint)\n\t\t{\n\t\t\tflag2 = true;\n\t\t}\n\t\tif (flag2 || Interface.CallHook(\u0022OnPlayerStudyBlueprint\u0022, player, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = item;\n\t\tif (item.amount \u003E 1)\n\t\t{\n\t\t\titem2 = item.SplitItem(1);\n\t\t}\n\t\titem2.UseItem();\n\t\tplayer.blueprints.Unlock(blueprintTargetDef);\n\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, \u0022blueprint\u0022);\n\t\tif (blueprint != null \u0026\u0026 blueprint.additionalUnlocks != null \u0026\u0026 blueprint.additionalUnlocks.Count \u003E 0)\n\t\t{\n\t\t\tforeach (ItemDefinition additionalUnlock2 in blueprint.additionalUnlocks)\n\t\t\t{\n\t\t\t\tplayer.blueprints.Unlock(additionalUnlock2);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock2, \u0022blueprint\u0022);\n\t\t\t}\n\t\t}\n\t\tif (studyEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(studyEffect.resourcePath, player, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "ItemModStudyBlueprint",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "OnFuelItemCheck(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer)",
    "MethodSignature": "GetFuelItem()",
    "MethodSourseCode": "\n\tpublic Item GetFuelItem()\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022OnFuelItemCheck\u0022, this, fuelContainer);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn fuelContainer.inventory.GetSlot(0);\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnDroppedItemCombined(DroppedItem droppedItem)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\n\tpublic void OnDroppedOn(DroppedItem di)\n\t{\n\t\tif (item == null || di.item == null || Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() \u0026\u0026 di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition \u0026\u0026 di.item.condition != di.item.maxCondition) || (item.hasCondition \u0026\u0026 item.condition != item.maxCondition))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (di.item.info != null)\n\t\t{\n\t\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t\t{\n\t\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\n\t\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\t\tif (num != num2)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((di.item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(di.item) != null) || (item.info != null \u0026\u0026 item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(item) != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint num3 = di.item.amount \u002B item.amount;\n\t\tif (num3 \u003C= item.MaxStackable() \u0026\u0026 num3 != 0)\n\t\t{\n\t\t\tif (di.DropReason == DropReasonEnum.Player)\n\t\t\t{\n\t\t\t\tDropReason = DropReasonEnum.Player;\n\t\t\t}\n\t\t\tdi.DestroyItem();\n\t\t\tdi.Kill();\n\t\t\titem.amount = num3;\n\t\t\titem.MarkDirty();\n\t\t\tif (GetDespawnDuration() \u003C float.PositiveInfinity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnDroppedItemCombined\u0022, this);\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\n\t\t\t}\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, IRemoteControllable component)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnBookmarkInput(ComputerStation computerStation, BasePlayer player, InputState inputState)",
    "MethodSignature": "PlayerServerInput(InputState inputState, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void PlayerServerInput(InputState inputState, BasePlayer player)\n\t{\n\t\tbase.PlayerServerInput(inputState, player);\n\t\tif (HasFlag(Flags.Reserved2) \u0026\u0026 currentlyControllingEnt.IsValid(serverside: true) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkInput\u0022, this, player, inputState) == null)\n\t\t{\n\t\t\tcurrentlyControllingEnt.Get(serverside: true).GetComponent\u003CIRemoteControllable\u003E().UserInput(inputState, new CameraViewerId(player.userID, 0L));\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)",
    "MethodSignature": "CanAcceptItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tpublic bool CanAcceptItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanVendingAcceptItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tBasePlayer ownerPlayer = item.GetOwnerPlayer();\n\t\tif (transactionActive || industrialItemIncoming)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (item.parent == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.inventory.itemList.Contains(item))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (ownerPlayer == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn CanPlayerAdmin(ownerPlayer);\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\tbuyer.GiveItem(soldItem, GiveItemReason.PickedUp);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnComposterUpdate(Composter composter)",
    "MethodSignature": "UpdateComposting()",
    "MethodSourseCode": "\n\tpublic void UpdateComposting()\n\t{\n\t\tif (Interface.CallHook(\u0022OnComposterUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C base.inventory.capacity; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = base.inventory.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tCompostItem(slot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Composter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSendCommand(Network.Connection cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(Connection cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(Connection cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tstring val = ConsoleSystem.BuildCommand(strCommand, args);\n\t\t\tnetWrite.String(val);\n\t\t\tnetWrite.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnOvenStarted(BaseOven baseOven)",
    "MethodSignature": "StartCooking()",
    "MethodSourseCode": "\n\tpublic virtual void StartCooking()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOvenStart\u0022, this) == null \u0026\u0026 (FindBurnable() != null || CanRunWithNoFuel))\n\t\t{\n\t\t\tbase.inventory.temperature = cookingTemperature;\n\t\t\tUpdateAttachmentTemperature();\n\t\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInterface.CallHook(\u0022OnOvenStarted\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTurretAssigned(AutoTurret autoTurret, ulong num, BasePlayer msgPlayer)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num != 0L \u0026\u0026 !IsAuthed(num) \u0026\u0026 Interface.CallHook(\u0022OnTurretAssign\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = num;\n\t\t\tplayerNameID.username = username;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, num);\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnTurretAssigned\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor itemBasedFlowRestrictor)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t}\n",
    "ClassName": "ItemBasedFlowRestrictor",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerCorpseSpawn(BasePlayer basePlayer)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring strCorpsePrefab = \u0022assets/prefabs/player/player_corpse.prefab\u0022;\n\t\t\tbool flag = false;\n\t\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t\t{\n\t\t\t\tforeach (Item item in inventory.containerWear.itemList)\n\t\t\t\t{\n\t\t\t\t\tif (item != null \u0026\u0026 item.info.TryGetComponent\u003CItemCorpseOverride\u003E(out var component))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) \u003E 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\n\t\t\t\t\t\tflag = component.BlockWearableCopy;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tif (!flag)\n\t\t\t\t{\n\t\t\t\t\tplayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\t}\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component2 = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\n\t\t{\n\t\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\t\tUnityEngine.Random.InitState((int)(seed \u002B steamid));\n\t\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\n\t\t\tUnityEngine.Random.state = state;\n\t\t\treturn result;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterStrafe(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanStrafe()",
    "MethodSourseCode": "\n\tpublic bool CanStrafe()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafe\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime \u003E= 20f)\n\t\t{\n\t\t\treturn CanInterruptState();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCCTVDirectionChange(CCTV_RC cCTV_RC, BasePlayer player)",
    "MethodSignature": "Server_SetDir(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void Server_SetDir(RPCMessage msg)\n\t{\n\t\tif (!IsStatic())\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (player.CanBuild() \u0026\u0026 player.IsBuildingAuthed() \u0026\u0026 Interface.CallHook(\u0022OnCCTVDirectionChange\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tVector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);\n\t\t\t\tdirection = base.transform.InverseTransformDirection(direction);\n\t\t\t\tVector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);\n\t\t\t\tpitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);\n\t\t\t\tyawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CCTV_RC",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnEntityActiveCheck(BaseEntity ent, BasePlayer player, uint id, string debugName)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (ent.net == null || player.net == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityActiveCheck\u0022, ent, player, id, debugName);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (ent.net.ID == player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (ent.parentEntity.uid != player.net.ID)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tItem activeItem = player.GetActiveItem();\n\t\t\t\tif (activeItem == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (activeItem.GetHeldEntity() != ent)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRfFrequencyChanged(Detonator detonator, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild() || GetOwnerPlayer() != msg.player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsOn());\n\t\t\tfrequency = num;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\townerItem?.LoseCondition(ownerItem.maxCondition * 0.01f);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 36
  },
  {
    "HookSignature": "OnItemUnlock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcAlert(ScientistNPC scientistNPC)",
    "MethodSignature": "Alert()",
    "MethodSourseCode": "\n\tpublic void Alert()\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcAlert\u0022, this) == null)\n\t\t{\n\t\t\tlastAlertedTime = Time.time;\n\t\t\tSetChatterType(RadioChatterType.Alert);\n\t\t}\n\t}\n",
    "ClassName": "ScientistNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAffordUpgrade(ulong iSkin, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade)",
    "MethodSignature": "CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAffordUpgrade\u0022, iSkin, this, iGrade);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).costToBuild)\n\t\t{\n\t\t\tif ((float)player.inventory.GetAmount(item.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnQuarryGather(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "ProcessResources()",
    "MethodSourseCode": "\n\tpublic void ProcessResources()\n\t{\n\t\tif (_linkedDeposit == null || hopperPrefab.instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!FuelCheck())\n\t\t{\n\t\t\tSetOn(isOn: false);\n\t\t}\n\t\tfloat num = Mathf.Min(workToAdd, pendingWork);\n\t\tpendingWork -= num;\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)\n\t\t{\n\t\t\tif ((!canExtractLiquid \u0026\u0026 resource.isLiquid) || (!canExtractSolid \u0026\u0026 !resource.isLiquid))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat workNeeded = resource.workNeeded;\n\t\t\tint num2 = Mathf.FloorToInt(resource.workDone / workNeeded);\n\t\t\tresource.workDone \u002B= num;\n\t\t\tint num3 = Mathf.FloorToInt(resource.workDone / workNeeded);\n\t\t\tif (resource.workDone \u003E workNeeded)\n\t\t\t{\n\t\t\t\tresource.workDone %= workNeeded;\n\t\t\t}\n\t\t\tif (num2 != num3)\n\t\t\t{\n\t\t\t\tint iAmount = num3 - num2;\n\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\n\t\t\t\tif (Interface.CallHook(\u0022OnQuarryGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t\telse if (!item.MoveToContainer(hopperPrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\tSetOn(isOn: false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnWaterCollect(WaterCatcher waterCatcher)",
    "MethodSignature": "CollectWater()",
    "MethodSourseCode": "\n\tpublic void CollectWater()\n\t{\n\t\tif (!IsFull() \u0026\u0026 Interface.CallHook(\u0022OnWaterCollect\u0022, this) == null)\n\t\t{\n\t\t\tfloat num = 0.25f;\n\t\t\tnum \u002B= Climate.GetFog(base.transform.position) * 2f;\n\t\t\tif (TestIsOutside())\n\t\t\t{\n\t\t\t\tnum \u002B= Climate.GetRain(base.transform.position);\n\t\t\t\tnum \u002B= Climate.GetSnow(base.transform.position) * 0.5f;\n\t\t\t}\n\t\t\tAddResource(Mathf.CeilToInt(maxItemToCreate * num));\n\t\t}\n\t}\n",
    "ClassName": "WaterCatcher",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFuelConsumed(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= GetFuelRate())\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tint fuelRate = GetFuelRate();\n\t\tfuel.UseItem(fuelRate);\n\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \u0022smelt\u0022);\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "OnNpcTargetSense(BaseEntity owner, BaseEntity ent, AIBrainSenses brainSenses)",
    "MethodSignature": "SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)",
    "MethodSourseCode": "\n\tpublic void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTargetSense\u0022, owner, ent, brainSenses) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIAISenses iAISenses = owner as IAISenses;\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif (basePlayer != null \u0026\u0026 PlayerIgnoreList.Contains(basePlayer))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (iAISenses != null \u0026\u0026 iAISenses.IsThreat(ent))\n\t\t{\n\t\t\tflag = true;\n\t\t\tif (brainSenses != null)\n\t\t\t{\n\t\t\t\tbrainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i \u003C All.Count; i\u002B\u002B)\n\t\t{\n\t\t\tif (All[i].Entity == ent)\n\t\t\t{\n\t\t\t\tSeenInfo value = All[i];\n\t\t\t\tvalue.Position = ent.transform.position;\n\t\t\t\tvalue.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);\n\t\t\t\tAll[i] = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tif (ConVar.AI.ignoreplayers \u0026\u0026 !basePlayer.IsNpc)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tPlayers.Add(ent);\n\t\t}\n\t\tif (iAISenses != null)\n\t\t{\n\t\t\tif (iAISenses.IsTarget(ent))\n\t\t\t{\n\t\t\t\tTargets.Add(ent);\n\t\t\t}\n\t\t\tif (iAISenses.IsFriendly(ent))\n\t\t\t{\n\t\t\t\tFriendlies.Add(ent);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tThreats.Add(ent);\n\t\t\t}\n\t\t}\n\t\tAll.Add(new SeenInfo\n\t\t{\n\t\t\tEntity = ent,\n\t\t\tPosition = ent.transform.position,\n\t\t\tTimestamp = UnityEngine.Time.realtimeSinceStartup\n\t\t});\n\t}\n",
    "ClassName": "SimpleAIMemory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemDespawn(Item item)",
    "MethodSignature": "IdleDestroy()",
    "MethodSourseCode": "\n\tpublic void IdleDestroy()\n\t{\n\t\tInterface.CallHook(\u0022OnItemDespawn\u0022, item);\n\t\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);\n\t\tDestroyItem();\n\t\tKill();\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnResearchCostDetermine(Item item, ResearchTable researchTable)",
    "MethodSignature": "ScrapForResearch(Item item)",
    "MethodSourseCode": "\n\tpublic int ScrapForResearch(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnResearchCostDetermine\u0022, item, this);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\treturn ScrapForResearch(item.info);\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, KeyLock keyLock)",
    "MethodSignature": "RPC_Unlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Unlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null \u0026\u0026 HasLockPermission(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVehicleHornPressed(VehicleModuleSeating vehicleModuleSeating, BasePlayer player)",
    "MethodSignature": "PlayerServerInput(InputState inputState, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void PlayerServerInput(InputState inputState, BasePlayer player)\n\t{\n\t\tbase.PlayerServerInput(inputState, player);\n\t\tif (hornLoop != null \u0026\u0026 IsOnThisModule(player))\n\t\t{\n\t\t\tbool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);\n\t\t\tif (flag != HasFlag(Flags.Reserved8))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved8, flag);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnVehicleHornPressed\u0022, this, player);\n\t\t\t\thornPlayer = player;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleSeating",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanWearItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanWearItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tprivate bool CanWearItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanWearItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn CanWearItem(item, canAdjustClothing: true);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityControl(RemoteControlEntity remoteControlEntity, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDeath(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void OnKilled(HitInfo info)\n\t{\n\t\tisKilled = true;\n\t\tInterface.CallHook(\u0022OnEntityDeath\u0022, this, info);\n\t\tKill();\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnFireBallSpread(FireBall fireBall, BaseEntity baseEntity)",
    "MethodSignature": "TryToSpread()",
    "MethodSourseCode": "\n\tpublic void TryToSpread()\n\t{\n\t\tfloat num = 0.9f - generation * 0.1f;\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C num \u0026\u0026 spreadSubEntity.isValid)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.transform.position = base.transform.position \u002B Vector3.up * 0.25f;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);\n\t\t\t\tbaseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallSpread\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\n\t\t\t\tbaseEntity.SendMessage(\u0022SetGeneration\u0022, generation \u002B 1f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnEntityMarkHostile(BasePlayer basePlayer, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic override void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tdouble currentTimestamp = TimeEx.currentTimestamp;\n\t\t\tdouble val = currentTimestamp \u002B (double)duration;\n\t\t\tState.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);\n\t\t\tDirtyPlayerState();\n\t\t\tdouble num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);\n\t\t\tClientRPCPlayer(null, this, \u0022SetHostileLength\u0022, (float)num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretTarget(AutoTurret autoTurret, BaseCombatEntity targ)",
    "MethodSignature": "SetTarget(BaseCombatEntity targ)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity targ)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTurretTarget\u0022, this, targ) == null)\n\t\t{\n\t\t\tif (targ != target)\n\t\t\t{\n\t\t\t\tEffect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t\tMarkDirtyForceUpdateOutputs();\n\t\t\t\tnextShotTime \u002B= 0.1f;\n\t\t\t}\n\t\t\ttarget = targ;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanTrainCarCouple(TrainCar owner, TrainCar theirCouplingOwner)",
    "MethodSignature": "TryCouple(TrainCoupling theirCoupling, bool reflect)",
    "MethodSourseCode": "\n\tpublic bool TryCouple(TrainCoupling theirCoupling, bool reflect)\n\t{\n\t\tif (!isValid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (CoupledTo == theirCoupling)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (IsCoupled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanTrainCarCouple\u0022, owner, theirCoupling.owner);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (reflect \u0026\u0026 !theirCoupling.TryCouple(this, reflect: false))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tcontroller.OnPreCouplingChange();\n\t\tCoupledTo = theirCoupling;\n\t\towner.SetFlag(flag, b: true, recursive: false, networkupdate: false);\n\t\towner.SendNetworkUpdate();\n\t\treturn true;\n\t}\n",
    "ClassName": "TrainCoupling",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnDemoRecordingStopped(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnWaterPurify(WaterPurifier waterPurifier, float timeCooked)",
    "MethodSignature": "ConvertWater(float timeCooked)",
    "MethodSourseCode": "\n\tprotected void ConvertWater(float timeCooked)\n\t{\n\t\tif (stopWhenOutputFull)\n\t\t{\n\t\t\tItem slot = waterStorage.inventory.GetSlot(0);\n\t\t\tif (slot != null \u0026\u0026 slot.amount \u003E= slot.MaxStackable())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnWaterPurify\u0022, this, timeCooked) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\n\t\tdirtyWaterProcssed \u002B= num;\n\t\tif (dirtyWaterProcssed \u003E= 1f)\n\t\t{\n\t\t\tItem slot2 = base.inventory.GetSlot(0);\n\t\t\tint num2 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\n\t\t\tnum = num2;\n\t\t\tslot2.UseItem(num2);\n\t\t\tdirtyWaterProcssed -= num2;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tpendingFreshWater \u002B= num / (float)freshWaterRatio;\n\t\tif (!(pendingFreshWater \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num3 = Mathf.FloorToInt(pendingFreshWater);\n\t\tpendingFreshWater -= num3;\n\t\tItem slot3 = waterStorage.inventory.GetSlot(0);\n\t\tif (slot3 != null \u0026\u0026 slot3.info != freshWater)\n\t\t{\n\t\t\tslot3.RemoveFromContainer();\n\t\t\tslot3.Remove();\n\t\t}\n\t\tif (slot3 == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(freshWater, num3, 0uL);\n\t\t\tif (!item.MoveToContainer(waterStorage.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslot3.amount \u002B= num3;\n\t\t\tslot3.amount = Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\n\t\t\twaterStorage.inventory.MarkDirty();\n\t\t}\n\t\tInterface.CallHook(\u0022OnWaterPurified\u0022, this, timeCooked);\n\t\twaterStorage.SendNetworkUpdate();\n\t}\n",
    "ClassName": "WaterPurifier",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnTick()",
    "MethodSignature": "DoTick()",
    "MethodSourseCode": "\n\tprivate void DoTick()\n\t{\n\t\tInterface.CallHook(\u0022OnTick\u0022);\n\t\tRCon.Update();\n\t\tCompanionServer.Server.Update();\n\t\tfor (int i = 0; i \u003C Network.Net.sv.connections.Count; i\u002B\u002B)\n\t\t{\n\t\t\tNetwork.Connection connection = Network.Net.sv.connections[i];\n\t\t\tif (!connection.isAuthenticated \u0026\u0026 !(connection.GetSecondsConnected() \u003C (float)ConVar.Server.authtimeout))\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(connection, \u0022Authentication Timed Out\u0022);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] array)",
    "MethodSignature": "TakePhoto(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tprivate void TakePhoto(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItem item = GetItem();\n\t\tif (player == null || item == null || item.condition \u003C= 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array.Length \u003E 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\n\t\tif (item2 == null)\n\t\t{\n\t\t\tDebug.LogError(\u0022Failed to create photo item\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!item2.instanceData.subEntity.IsValid)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Photo has no sub-entity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity was not found\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!(baseNetworkable is PhotoEntity photoEntity))\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity is not a photo\u0022);\n\t\t\treturn;\n\t\t}\n\t\tphotoEntity.SetImageData(player.userID, array);\n\t\tif (Interface.CallHook(\u0022OnPhotoCapture\u0022, photoEntity, item, player, array) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!player.inventory.GiveItem(item2))\n\t\t{\n\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t}\n\t\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\n\t\tif (!hasSentAchievement \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_PAPARAZZI\u0022))\n\t\t{\n\t\t\tVector3 position = GetOwnerPlayer().eyes.position;\n\t\t\tVector3 vector = GetOwnerPlayer().eyes.HeadForward();\n\t\t\tList\u003CBasePlayer\u003E obj = Facepunch.Pool.GetList\u003CBasePlayer\u003E();\n\t\t\tVis.Entities(position \u002B vector * 5f, 5f, obj, 131072);\n\t\t\tforeach (BasePlayer item3 in obj)\n\t\t\t{\n\t\t\t\tif (item3.isServer \u0026\u0026 item3 != GetOwnerPlayer() \u0026\u0026 item3.IsVisible(GetOwnerPlayer().eyes.position))\n\t\t\t\t{\n\t\t\t\t\thasSentAchievement = true;\n\t\t\t\t\tGetOwnerPlayer().GiveAchievement(\u0022SUMMER_PAPARAZZI\u0022);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t}\n\t\titem.LoseCondition(1f);\n\t\tInterface.CallHook(\u0022OnPhotoCaptured\u0022, photoEntity, item, player, array);\n\t}\n",
    "ClassName": "InstantCameraTool",
    "HookLineInvoke": 70
  },
  {
    "HookSignature": "OnTrapTrigger(Landmine landmine, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (!base.isClient)\n\t\t{\n\t\t\tif (!Armed())\n\t\t\t{\n\t\t\t\tCancelInvoke(Arm);\n\t\t\t\tblocked = true;\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t\t{\n\t\t\t\tBasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;\n\t\t\t\tTrigger(ply);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnInventoryItemsCount(PlayerInventory playerInventory, int itemid)",
    "MethodSignature": "GetAmount(int itemid)",
    "MethodSourseCode": "\n\tpublic int GetAmount(int itemid)\n\t{\n\t\tif (itemid == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemsCount\u0022, this, itemid);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tint num = 0;\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tnum \u002B= containerMain.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tnum \u002B= containerBelt.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tnum \u002B= containerWear.GetAmount(itemid, onlyUsableAmounts: true);\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnSleepingBagDestroyed(SleepingBag sleepingBag2, BasePlayer player)",
    "MethodSignature": "DestroyBag(BasePlayer player, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(BasePlayer player, NetworkableId sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (sleepingBag2.canBePublic)\n\t\t{\n\t\t\tsleepingBag2.SetPublic(isPublic: true);\n\t\t\tsleepingBag2.deployerUserID = 0uL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\tplayer.SendRespawnOptions();\n\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, player);\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnStructureRotate(BuildingBlock buildingBlock, BasePlayer msgPlayer)",
    "MethodSignature": "DoRotation(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoRotation(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanRotate(msg.player) \u0026\u0026 blockDefinition.canRotateAfterPlacement \u0026\u0026 Interface.CallHook(\u0022OnStructureRotate\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbase.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);\n\t\t\tRefreshEntityLinks();\n\t\t\tUpdateSurroundingEntities();\n\t\t\tUpdateSkin(force: true);\n\t\t\tRefreshNeighbours(linkToNeighbours: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tClientRPC(null, \u0022RefreshSkin\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnDemoRecordingStart(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tSendEntityUpdate();\n\t\t\t\tTreeManager.SendSnapshot(this);\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnDispenserGather(ResourceDispenser resourceDispenser, BasePlayer entity, Item item)",
    "MethodSignature": "GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)",
    "MethodSourseCode": "\n\tprivate void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)\n\t{\n\t\tif (itemAmt.amount == 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();\n\t\tfloat num2 = itemAmt.startAmount / startingItemCounts;\n\t\tfloat f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);\n\t\tf = Mathf.Round(f);\n\t\tfloat num3 = f * destroyFraction * 2f;\n\t\tif (itemAmt.amount \u003C= f \u002B num3)\n\t\t{\n\t\t\tfloat num4 = (f \u002B num3) / itemAmt.amount;\n\t\t\tf /= num4;\n\t\t\tnum3 /= num4;\n\t\t}\n\t\titemAmt.amount -= Mathf.Floor(f);\n\t\titemAmt.amount -= Mathf.Floor(num3);\n\t\tif (f \u003C 1f)\n\t\t{\n\t\t\tf = ((UnityEngine.Random.Range(0f, 1f) \u003C= f) ? 1f : 0f);\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (itemAmt.amount \u003C 0f)\n\t\t{\n\t\t\titemAmt.amount = 0f;\n\t\t}\n\t\tif (f \u003E= 1f)\n\t\t{\n\t\t\tint num5 = CalculateGatherBonus(entity, itemAmt, f);\n\t\t\tint iAmount = Mathf.FloorToInt(f) \u002B num5;\n\t\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\n\t\t\tif (Interface.CallHook(\u0022OnDispenserGather\u0022, this, entity, item) == null \u0026\u0026 item != null)\n\t\t\t{\n\t\t\t\tOverrideOwnership(item, attackWeapon);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\n\t\t\t\tentity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceDispenser",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnItemLock(Item item)",
    "MethodSignature": "LockUnlock(bool bNewState)",
    "MethodSourseCode": "\n\tpublic void LockUnlock(bool bNewState)\n\t{\n\t\tif (HasFlag(Flag.IsLocked) != bNewState \u0026\u0026 (!bNewState || Interface.CallHook(\u0022OnItemLock\u0022, this) == null) \u0026\u0026 (bNewState || Interface.CallHook(\u0022OnItemUnlock\u0022, this) == null))\n\t\t{\n\t\t\tSetFlag(Flag.IsLocked, bNewState);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggled(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer)",
    "MethodSignature": "SvSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\tprivate void SvSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnWindmillUpdate(ElectricWindmill electricWindmill)",
    "MethodSignature": "WindUpdate()",
    "MethodSourseCode": "\n\tpublic void WindUpdate()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWindmillUpdate\u0022, this) == null)\n\t\t{\n\t\t\tserverWindSpeed = GetWindSpeedScale();\n\t\t\tif (!AmIVisible())\n\t\t\t{\n\t\t\t\tserverWindSpeed = 0f;\n\t\t\t}\n\t\t\tint num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\n\t\t\tbool num2 = currentEnergy != num;\n\t\t\tcurrentEnergy = num;\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnWindmillUpdated\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ElectricWindmill",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfListenerRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tlistenList.Remove(obj);\n\t\t\t}\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPhoneNameUpdate(PhoneController phoneController, string text, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 20)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 20);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnQuarryToggled(MiningQuarry miningQuarry, BasePlayer msgPlayer)",
    "MethodSignature": "StopEngine(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void StopEngine(RPCMessage msg)\n\t{\n\t\tMiningQuarry miningQuarry = GetParentEntity() as MiningQuarry;\n\t\tif ((bool)miningQuarry)\n\t\t{\n\t\t\tminingQuarry.EngineSwitch(isOn: false);\n\t\t\tInterface.CallHook(\u0022OnQuarryToggled\u0022, miningQuarry, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "EngineSwitch",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnMlrsFired(MLRS mLRS, BasePlayer owner)",
    "MethodSignature": "Fire(BasePlayer owner)",
    "MethodSourseCode": "\n\tpublic void Fire(BasePlayer owner)\n\t{\n\t\tUpdateStorageState();\n\t\tif (CanFire \u0026\u0026 !(_mounted == null) \u0026\u0026 Interface.CallHook(\u0022OnMlrsFire\u0022, this, owner) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved6, b: true);\n\t\t\tradiusModIndex = 0;\n\t\t\tnextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\n\t\t\trocketOwnerRef.Set(owner);\n\t\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\n\t\t\tInterface.CallHook(\u0022OnMlrsFired\u0022, this, owner);\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnVehicleModulesAssigned(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\titemModVehicleModule.doNonUserSpawn = true;\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t\tInvoke(HandleAdminBonus, 0f);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (HasLockPermission(player))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn !IsLocked();\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer, bool true)",
    "MethodSignature": "DoImmediateDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoImmediateDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 msg.player.IsAdmin \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, true) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnDecayHeal(DecayEntity decayEntity)",
    "MethodSignature": "DecayTick()",
    "MethodSourseCode": "\n\tpublic virtual void DecayTick()\n\t{\n\t\tif (decay == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = UnityEngine.Time.time - lastDecayTick;\n\t\tif (num \u003C ConVar.Decay.tick)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlastDecayTick = UnityEngine.Time.time;\n\t\tif (!decay.ShouldDecay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = num * ConVar.Decay.scale;\n\t\tif (ConVar.Decay.upkeep)\n\t\t{\n\t\t\tupkeepTimer \u002B= num2;\n\t\t\tif (upkeepTimer \u003E 0f)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\t\t\tif (buildingPrivilege != null)\n\t\t\t\t{\n\t\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (upkeepTimer \u003C 1f)\n\t\t\t{\n\t\t\t\tif (base.healthFraction \u003C 1f \u0026\u0026 ConVar.Decay.upkeep_heal_scale \u003E 0f \u0026\u0026 base.SecondsSinceAttacked \u003E 600f \u0026\u0026 Interface.CallHook(\u0022OnDecayHeal\u0022, this) == null)\n\t\t\t\t{\n\t\t\t\t\tfloat num3 = num / decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\n\t\t\t\t\tHeal(MaxHealth() * num3);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupkeepTimer = 1f;\n\t\t}\n\t\tdecayTimer \u002B= num2;\n\t\tif (decayTimer \u003C decay.GetDecayDelay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022DecayTick\u0022))\n\t\t{\n\t\t\tfloat num4 = 1f;\n\t\t\tif (ConVar.Decay.upkeep)\n\t\t\t{\n\t\t\t\tif (!BypassInsideDecayMultiplier \u0026\u0026 !IsOutside())\n\t\t\t\t{\n\t\t\t\t\tnum4 *= ConVar.Decay.upkeep_inside_decay_scale;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C decayPoints.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tDecayPoint decayPoint = decayPoints[i];\n\t\t\t\t\tif (decayPoint.IsOccupied(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 -= decayPoint.protection;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num4 \u003E 0f \u0026\u0026 Interface.CallHook(\u0022OnDecayDamage\u0022, this) == null)\n\t\t\t{\n\t\t\t\tfloat num5 = num2 / decay.GetDecayDuration(this) * MaxHealth();\n\t\t\t\tHurt(num5 * num4 * decayVariance, DamageType.Decay);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerDropActiveItem(BasePlayer player, Item activeItem)",
    "MethodSignature": "DropActive(Vector3 position, Vector3 velocity)",
    "MethodSourseCode": "\n\tpublic void DropActive(Vector3 position, Vector3 velocity)\n\t{\n\t\tItem activeItem = player.GetActiveItem();\n\t\tif (activeItem == null || Interface.CallHook(\u0022OnPlayerDropActiveItem\u0022, player, activeItem) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerBelt.DropActive\u0022))\n\t\t{\n\t\t\tDroppedItem droppedItem = activeItem.Drop(position, velocity) as DroppedItem;\n\t\t\tif (droppedItem != null)\n\t\t\t{\n\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Death;\n\t\t\t\tdroppedItem.DroppedBy = player.userID;\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);\n\t\t\t}\n\t\t\tplayer.svActiveItemID = default(ItemId);\n\t\t\tplayer.SendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PlayerBelt",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string strReason)",
    "MethodSignature": "OnDisconnected(string strReason, Network.Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnDisconnected(string strReason, Network.Connection connection)\n\t{\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);\n\t\tconnectionQueue.RemoveConnection(connection);\n\t\tConnectionAuth.OnDisconnect(connection);\n\t\tPlatformService.Instance.EndPlayerSession(connection.userid);\n\t\tEACServer.OnLeaveGame(connection);\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif ((bool)basePlayer)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDisconnected\u0022, basePlayer, strReason);\n\t\t\tbasePlayer.OnDisconnected();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string actionReasonDetailsString)",
    "MethodSignature": "OnClientActionRequired(OnClientActionRequiredCallbackInfo data)",
    "MethodSourseCode": "\n\tprivate static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)\n\t{\n\t\tusing (TimeWarning.New(\u0022OnClientActionRequired\u0022, 10))\n\t\t{\n\t\t\tIntPtr clientHandle = data.ClientHandle;\n\t\t\tConnection connection = GetConnection(clientHandle);\n\t\t\tif (connection == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022[EAC] Status update for invalid client: \u0022 \u002B clientHandle);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAntiCheatCommonClientAction clientAction = data.ClientAction;\n\t\t\tif (clientAction != AntiCheatCommonClientAction.RemovePlayer)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\n\t\t\tDebug.Log($\u0022[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\u0022);\n\t\t\tconnection.authStatus = \u0022eac\u0022;\n\t\t\tNetwork.Net.sv.Kick(connection, \u0022EAC: \u0022 \u002B actionReasonDetailsString);\n\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerKicked\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\n\t\t\t{\n\t\t\t\tconnection.authStatus = \u0022eacbanned\u0022;\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerBanned\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\n\t\t\t\t{\n\t\t\t\t\tEntity.DeleteBy(connection.userid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tUnregisterClientOptions unregisterClientOptions = default(UnregisterClientOptions);\n\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\n\t\t\tUnregisterClientOptions options = unregisterClientOptions;\n\t\t\tInterface.UnregisterClient(ref options);\n\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\n\t\t\tconnection2client.TryRemove(connection, out var _);\n\t\t\tconnection2status.TryRemove(connection, out var _);\n\t\t}\n\t}\n",
    "ClassName": "EACServer",
    "HookLineInvoke": 26
  },
  {
    "HookSignature": "CanEquipItem(PlayerInventory playerInventory, Item item, int targetSlot)",
    "MethodSignature": "CanEquipItem(Item item, int targetSlot)",
    "MethodSourseCode": "\n\tprivate bool CanEquipItem(Item item, int targetSlot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEquipItem\u0022, this, item, targetSlot);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tItemModContainerRestriction component = item.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tItem[] array = containerBelt.itemList.ToArray();\n\t\tforeach (Item item2 in array)\n\t\t{\n\t\t\tif (item2 != item)\n\t\t\t{\n\t\t\t\tItemModContainerRestriction component2 = item2.info.GetComponent\u003CItemModContainerRestriction\u003E();\n\t\t\t\tif (!(component2 == null) \u0026\u0026 !component.CanExistWith(component2) \u0026\u0026 !item2.MoveToContainer(containerMain))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnInventoryNetworkUpdate(PlayerInventory playerInventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool bSendInventoryToEveryone)",
    "MethodSignature": "SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone)",
    "MethodSourseCode": "\n\tpublic void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone = false)\n\t{\n\t\tusing UpdateItemContainer updateItemContainer = Facepunch.Pool.Get\u003CUpdateItemContainer\u003E();\n\t\tupdateItemContainer.type = (int)type;\n\t\tif (container != null)\n\t\t{\n\t\t\tcontainer.dirty = false;\n\t\t\tupdateItemContainer.container = Facepunch.Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tupdateItemContainer.container.Add(container.Save());\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnInventoryNetworkUpdate\u0022, this, container, updateItemContainer, type, bSendInventoryToEveryone) == null)\n\t\t{\n\t\t\tif (bSendInventoryToEveryone)\n\t\t\t{\n\t\t\t\tbase.baseEntity.ClientRPC(null, \u0022UpdatedItemContainer\u0022, updateItemContainer);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbase.baseEntity.ClientRPCPlayer(null, base.baseEntity, \u0022UpdatedItemContainer\u0022, updateItemContainer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPhoneDialTimeout(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tif (activeCallTo != null)\n\t\t\t{\n\t\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\t}\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHelicopterOutOfCrates(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OutOfCrates()",
    "MethodSourseCode": "\n\tpublic bool OutOfCrates()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnHelicopterOutOfCrates\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003C= 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable baseNetworkable, Network.Connection connection)",
    "MethodSignature": "SendAsSnapshot(Connection connection, bool justCreated)",
    "MethodSourseCode": "\n\tpublic void SendAsSnapshot(Connection connection, bool justCreated = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, this, connection) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tconnection.validate.entityUpdates\u002B\u002B;\n\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\tsaveInfo.forConnection = connection;\n\t\t\tsaveInfo.forDisk = false;\n\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\tnetWrite.PacketID(Message.Type.Entities);\n\t\t\tnetWrite.UInt32(connection.validate.entityUpdates);\n\t\t\tToStreamForNetwork(netWrite, saveInfo2);\n\t\t\tnetWrite.Send(new SendInfo(connection));\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorClosed(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_CloseDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_CloseDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || !IsOpen() || IsBusy() || IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (rpc.player.IsWounded())\n\t\t{\n\t\t\tif (!woundedCloses.ContainsKey(rpc.player) || !((float)woundedCloses[rpc.player] \u003E 2.5f))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twoundedCloses.Remove(rpc.player);\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t\t{\n\t\t\t\tSetNavMeshLinkEnabled(wantsOn: false);\n\t\t\t}\n\t\t\tStartCheckingForBlockages(isOpening: false);\n\t\t\tInterface.CallHook(\u0022OnDoorClosed\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t}\n\t\tif ((bool)ply)\n\t\t{\n\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t}\n\t\tcurrentlyControllingEnt.uid = default(NetworkableId);\n\t\tcurrentPlayerID = 0uL;\n\t\tSetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tCancelInvoke(CheckCCTVAchievement);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnItemDeployed(Deployer deployer, BaseEntity baseEntity, BaseEntity baseEntity2)",
    "MethodSignature": "DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)",
    "MethodSourseCode": "\n\tpublic void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)\n\t{\n\t\tif (!HasItemAmount())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at player position!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;\n\t\tif (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ownerPlayer.Distance(baseEntity) \u003E 3f)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Too far away!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked at placement position!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);\n\t\tif (baseEntity2 != null)\n\t\t{\n\t\t\tbaseEntity2.skinID = ownerItem.skin;\n\t\t\tbaseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));\n\t\t\tbaseEntity2.OwnerID = ownerPlayer.userID;\n\t\t\tbaseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);\n\t\t\tbaseEntity2.Spawn();\n\t\t\tbaseEntity.SetSlot(deployable.slot, baseEntity2);\n\t\t\tif (deployable.placeEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\n\t\tInterface.CallHook(\u0022OnItemDeployed\u0022, this, baseEntity, baseEntity2);\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);\n\t\tUseItemAmount(1);\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 49
  },
  {
    "HookSignature": "OnEntityFlagsNetworkUpdate(BaseEntity baseEntity)",
    "MethodSignature": "SendNetworkUpdate_Flags()",
    "MethodSourseCode": "\n\tpublic void SendNetworkUpdate_Flags()\n\t{\n\t\tif (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendNetworkUpdate_Flags\u0022))\n\t\t{\n\t\t\tLogEntry(LogEntryType.Network, 2, \u0022SendNetworkUpdate_Flags\u0022);\n\t\t\tif (Interface.CallHook(\u0022OnEntityFlagsNetworkUpdate\u0022, this) == null)\n\t\t\t{\n\t\t\t\tList\u003CConnection\u003E subscribers = GetSubscribers();\n\t\t\t\tif (subscribers != null \u0026\u0026 subscribers.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\t\t\tnetWrite.PacketID(Message.Type.EntityFlags);\n\t\t\t\t\tnetWrite.EntityID(net.ID);\n\t\t\t\t\tnetWrite.Int32((int)flags);\n\t\t\t\t\tSendInfo info = new SendInfo(subscribers);\n\t\t\t\t\tnetWrite.Send(info);\n\t\t\t\t}\n\t\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer player, BaseCombatEntity baseCombatEntity)",
    "MethodSignature": "CanPickup(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPickup(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (pickup.enabled)\n\t\t{\n\t\t\tif (!pickup.requireBuildingPrivilege || player.CanBuild())\n\t\t\t{\n\t\t\t\tif (pickup.requireHammer)\n\t\t\t\t{\n\t\t\t\t\treturn player.IsHoldingEntity\u003CHammer\u003E();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (inventory != null)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerRespawn(BasePlayer basePlayer, BasePlayer.SpawnPoint spawnPoint)",
    "MethodSignature": "Respawn()",
    "MethodSourseCode": "\n\tpublic void Respawn()\n\t{\n\t\tSpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);\n\t\tif (ConVar.Server.respawnAtDeathPosition \u0026\u0026 ServerCurrentDeathNote != null)\n\t\t{\n\t\t\tspawnPoint.pos = ServerCurrentDeathNote.worldPosition;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerRespawn\u0022, this, spawnPoint);\n\t\tif (obj is SpawnPoint)\n\t\t{\n\t\t\tspawnPoint = (SpawnPoint)obj;\n\t\t}\n\t\tRespawnAt(spawnPoint.pos, spawnPoint.rot);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnClientCommand(Network.Connection packetConnection, string text)",
    "MethodSignature": "OnClientCommand(Message packet)",
    "MethodSourseCode": "\n\tinternal static void OnClientCommand(Message packet)\n\t{\n\t\tif (packet.read.Unread \u003E ConVar.Server.maxpacketsize_command)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Dropping client command due to size\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring text = packet.read.StringRaw();\n\t\tif (packet.connection == null || !packet.connection.connected)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Client without connection tried to run command: \u0022 \u002B text);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnClientCommand\u0022, packet.connection, text) == null)\n\t\t{\n\t\t\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);\n\t\t\tif (!string.IsNullOrEmpty(text2))\n\t\t\t{\n\t\t\t\tSendClientReply(packet.connection, text2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "IOnPlayerCommand(BasePlayer player, string message)",
    "MethodSignature": "sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\tplayer = null;\n\t\t}\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;\n\t\tif (userGroup == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (text.Length \u003E 128)\n\t\t{\n\t\t\ttext = text.Substring(0, 128);\n\t\t}\n\t\tif (text.Length \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (text.StartsWith(\u0022/\u0022) || text.StartsWith(\u0022\\\\\u0022))\n\t\t{\n\t\t\tInterface.CallHook(\u0022IOnPlayerCommand\u0022, player, message);\n\t\t\treturn false;\n\t\t}\n\t\ttext = text.EscapeRichText();\n\t\tobject obj = Interface.CallHook(\u0022IOnPlayerChat\u0022, userId, username, text, targetChannel, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (serverlog)\n\t\t{\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat(\u0022[\u0022, targetChannel, \u0022] \u0022, username, \u0022: \u0022), ConsoleColor.DarkGreen, text);\n\t\t\tstring text2 = player?.ToString() ?? $\u0022{username}[{userId}]\u0022;\n\t\t\tswitch (targetChannel)\n\t\t\t{\n\t\t\tcase ChatChannel.Team:\n\t\t\t\tDebugEx.Log(\u0022[TEAM CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\tcase ChatChannel.Cards:\n\t\t\t\tDebugEx.Log(\u0022[CARDS CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDebugEx.Log(\u0022[CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;\n\t\tbool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));\n\t\tstring text3 = \u0022#5af\u0022;\n\t\tif (flag)\n\t\t{\n\t\t\ttext3 = \u0022#af5\u0022;\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\ttext3 = \u0022#fa5\u0022;\n\t\t}\n\t\tstring text4 = username.EscapeRichText();\n\t\tChatEntry ce = default(ChatEntry);\n\t\tce.Channel = targetChannel;\n\t\tce.Message = text;\n\t\tce.UserId = ((player != null) ? player.UserIDString : userId.ToString());\n\t\tce.Username = username;\n\t\tce.Color = text3;\n\t\tce.Time = Epoch.Current;\n\t\tRecord(ce);\n\t\tswitch (targetChannel)\n\t\t{\n\t\tcase ChatChannel.Cards:\n\t\t{\n\t\t\tif (player == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!player.isMounted)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;\n\t\t\tif (baseCardGameEntity == null || !baseCardGameEntity.GameController.IsAtTable(player))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E obj2 = Facepunch.Pool.GetList\u003CNetwork.Connection\u003E();\n\t\t\tbaseCardGameEntity.GameController.GetConnectionsInGame(obj2);\n\t\t\tif (obj2.Count \u003E 0)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(obj2, \u0022chat.add2\u0022, 3, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Global:\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, 0, userId, text, text4, text3, 1f);\n\t\t\treturn true;\n\t\tcase ChatChannel.Local:\n\t\t{\n\t\t\tif (!(player != null))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfloat num2 = localChatRange * localChatRange;\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\n\t\t\t\tif (!(sqrMagnitude \u003E num2))\n\t\t\t\t{\n\t\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, 4, userId, text, text4, text3, Mathf.Clamp01(sqrMagnitude / num2 \u002B 0.2f));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Team:\n\t\t{\n\t\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\n\t\t\tif (onlineMemberConnections != null)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \u0022chat.add2\u0022, 1, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tplayerTeam.BroadcastTeamChat(userId, text4, text, text3);\n\t\t\treturn true;\n\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnHelicopterRetire(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "Retire()",
    "MethodSourseCode": "\n\tpublic void Retire()\n\t{\n\t\tif (!isRetiring \u0026\u0026 Interface.CallHook(\u0022OnHelicopterRetire\u0022, this) == null)\n\t\t{\n\t\t\tisRetiring = true;\n\t\t\tInvoke(DestroyMe, 240f);\n\t\t\tfloat x = TerrainMeta.Size.x;\n\t\t\tfloat y = 200f;\n\t\t\tVector3 newPos = Vector3Ex.Range(-1f, 1f);\n\t\t\tnewPos.y = 0f;\n\t\t\tnewPos.Normalize();\n\t\t\tnewPos *= x * 20f;\n\t\t\tnewPos.y = y;\n\t\t\tExitCurrentState();\n\t\t\tState_Move_Enter(newPos);\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity baseEntity)",
    "MethodSignature": "FlameTick()",
    "MethodSourseCode": "\n\tpublic void FlameTick()\n\t{\n\t\tfloat num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;\n\t\tlastFlameTick = UnityEngine.Time.realtimeSinceStartup;\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tReduceAmmo(num);\n\t\tSendNetworkUpdate();\n\t\tRay ray = ownerPlayer.eyes.BodyRay();\n\t\tVector3 origin = ray.origin;\n\t\tRaycastHit hitInfo;\n\t\tbool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);\n\t\tif (!num2)\n\t\t{\n\t\t\thitInfo.point = origin \u002B ray.direction * flameRange;\n\t\t}\n\t\tfloat num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);\n\t\tfloat amount = damagePerSec[0].amount;\n\t\tdamagePerSec[0].amount = amount * num * num3;\n\t\tDamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2279681, useLineOfSight: true);\n\t\tdamagePerSec[0].amount = amount;\n\t\tif (num2 \u0026\u0026 UnityEngine.Time.realtimeSinceStartup \u003E= nextFlameTime \u0026\u0026 hitInfo.distance \u003E 1.1f)\n\t\t{\n\t\t\tnextFlameTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.45f;\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnFlameThrowerBurn\u0022, this, baseEntity);\n\t\t\t\tbaseEntity.creatorEntity = ownerPlayer;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t\tif (ammo == 0)\n\t\t{\n\t\t\tSetFlameState(wantsOn: false);\n\t\t}\n\t\tGetOwnerItem()?.LoseCondition(num);\n\t}\n",
    "ClassName": "FlameThrower",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnElevatorButtonPress(ElevatorLift elevatorLift, BasePlayer msgPlayer, Elevator.Direction direction, bool flag)",
    "MethodSignature": "Server_RaiseLowerFloor(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Server_RaiseLowerFloor(RPCMessage msg)\n\t{\n\t\tif (!CanMove())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tElevator.Direction direction = (Elevator.Direction)msg.read.Int32();\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnElevatorButtonPress\u0022, this, msg.player, direction, flag) == null)\n\t\t{\n\t\t\tSetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);\n\t\t\towner.Server_RaiseLowerElevator(direction, flag);\n\t\t\tInvoke(ClearDirection, 0.7f);\n\t\t\tif (liftButtonPressedEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ElevatorLift",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanHelicopterUseNapalm(PatrolHelicopterAI patrolHelicopterAI)",
    "MethodSignature": "CanUseNapalm()",
    "MethodSourseCode": "\n\tpublic bool CanUseNapalm()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterUseNapalm\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn UnityEngine.Time.realtimeSinceStartup - lastNapalmTime \u003E= 30f;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDeployItem(BasePlayer msgPlayer, Deployer deployer, NetworkableId networkableId)",
    "MethodSignature": "DoDeploy(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void DoDeploy(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable();\n\t\tif (deployable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRay ray = msg.read.Ray();\n\t\tNetworkableId networkableId = msg.read.EntityID();\n\t\tif (Interface.CallHook(\u0022CanDeployItem\u0022, msg.player, this, networkableId) == null)\n\t\t{\n\t\t\tif (deployable.toSlot)\n\t\t\t{\n\t\t\t\tDoDeploy_Slot(deployable, ray, networkableId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDoDeploy_Regular(deployable, ray);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Deployer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnNetworkGroupLeft(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupLeave(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupLeave(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupLeft\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBuildingMerge(ServerBuildingManager serverBuildingManager, BuildingManager.Building building1, BuildingManager.Building building2)",
    "MethodSignature": "Merge(Building building1, Building building2)",
    "MethodSourseCode": "\n\tprivate void Merge(Building building1, Building building2)\n\t{\n\t\tInterface.CallHook(\u0022OnBuildingMerge\u0022, this, building1, building2);\n\t\twhile (building2.HasDecayEntities())\n\t\t{\n\t\t\tbuilding2.decayEntities[0].AttachToBuilding(building1.ID);\n\t\t}\n\t\tif (AI.nav_carve_use_building_optimization)\n\t\t{\n\t\t\tbuilding1.isNavMeshCarvingDirty = true;\n\t\t\tbuilding2.isNavMeshCarvingDirty = true;\n\t\t\tint ticks = 3;\n\t\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\n\t\t\tUpdateNavMeshCarver(building1, ref ticks, 0);\n\t\t}\n\t}\n",
    "ClassName": "ServerBuildingManager",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSleep(BasePlayer basePlayer)",
    "MethodSignature": "StartSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void StartSleeping()\n\t{\n\t\tif (!IsSleeping())\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSleep\u0022, this);\n\t\t\tif (InSafeZone() \u0026\u0026 !IsInvoking(ScheduledDeath))\n\t\t\t{\n\t\t\t\tInvoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);\n\t\t\t}\n\t\t\tBaseMountable baseMountable = GetMounted();\n\t\t\tif (baseMountable != null \u0026\u0026 !baseMountable.allowSleeperMounting)\n\t\t\t{\n\t\t\t\tEnsureDismounted();\n\t\t\t}\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: true);\n\t\t\tsleepStartTime = UnityEngine.Time.time;\n\t\t\tsleepingPlayerList.Add(this);\n\t\t\tbots.Remove(this);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tCancelInvoke(TeamUpdate);\n\t\t\tinventory.loot.Clear();\n\t\t\tinventory.crafting.CancelAll(returnItems: true);\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tTurnOffAllLights();\n\t\t\tEnablePlayerCollider();\n\t\t\tRemovePlayerRigidbody();\n\t\t\tSetServerFall(wantsOn: true);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneDialTimedOut(PhoneController activeCallTo, PhoneController phoneController, BasePlayer activeCallToCurrentPlayer)",
    "MethodSignature": "TimeOutDialing()",
    "MethodSourseCode": "\n\tprivate void TimeOutDialing()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialTimeout\u0022, activeCallTo, this, activeCallTo.currentPlayer) == null)\n\t\t{\n\t\t\tif (activeCallTo != null)\n\t\t\t{\n\t\t\t\tactiveCallTo.ServerPlayAnsweringMessage(this);\n\t\t\t}\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tInterface.CallHook(\u0022OnPhoneDialTimedOut\u0022, activeCallTo, this, activeCallTo.currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnItemRemovedFromContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Remove(Item item)",
    "MethodSourseCode": "\n\tpublic bool Remove(Item item)\n\t{\n\t\tif (!itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (onPreItemRemove != null)\n\t\t{\n\t\t\tonPreItemRemove(item);\n\t\t}\n\t\titemList.Remove(item);\n\t\titem.parent = null;\n\t\tMarkDirty();\n\t\tif (onItemAddedRemoved != null)\n\t\t{\n\t\t\tonItemAddedRemoved(item, arg2: false);\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemRemovedFromContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnLootEntityEnd(BasePlayer player, DroppedItemContainer droppedItemContainer)",
    "MethodSignature": "PlayerStoppedLooting(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PlayerStoppedLooting(BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnLootEntityEnd\u0022, player, this);\n\t\tif (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)\n\t\t{\n\t\t\tKill();\n\t\t\treturn;\n\t\t}\n\t\tResetRemovalTime();\n\t\tSetFlag(Flags.Open, b: false);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "DroppedItemContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControl(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable remoteControllable)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnQueueMessage(Network.Connection c, int position)",
    "MethodSignature": "SendMessage(Connection c, int position)",
    "MethodSourseCode": "\n\tpublic void SendMessage(Connection c, int position)\n\t{\n\t\tif (Interface.CallHook(\u0022OnQueueMessage\u0022, c, position) == null)\n\t\t{\n\t\t\tstring empty = string.Empty;\n\t\t\tempty = ((position \u003C= 0) ? string.Format(\u0022YOU\u0027RE NEXT - {1:N0} PLAYERS BEHIND YOU\u0022, position, queue.Count - position - 1) : $\u0022{position:N0} PLAYERS AHEAD OF YOU, {queue.Count - position - 1:N0} PLAYERS BEHIND\u0022);\n\t\t\tNetWrite netWrite = Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.Message);\n\t\t\tnetWrite.String(\u0022QUEUE\u0022);\n\t\t\tnetWrite.String(empty);\n\t\t\tnetWrite.Send(new SendInfo(c));\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamInvite(BasePlayer basePlayer, BasePlayer component)",
    "MethodSignature": "sendinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void sendinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer || !UnityEngine.Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), out var hitInfo, 5f, 1218652417, QueryTriggerInteraction.Ignore))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\n\t\tif ((bool)entity)\n\t\t{\n\t\t\tBasePlayer component = entity.GetComponent\u003CBasePlayer\u003E();\n\t\t\tif ((bool)component \u0026\u0026 component != basePlayer \u0026\u0026 !component.IsNpc \u0026\u0026 component.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamInvite\u0022, basePlayer, component) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.SendInvite(component);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnDecayDamage(DecayEntity decayEntity)",
    "MethodSignature": "DecayTick()",
    "MethodSourseCode": "\n\tpublic virtual void DecayTick()\n\t{\n\t\tif (decay == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = UnityEngine.Time.time - lastDecayTick;\n\t\tif (num \u003C ConVar.Decay.tick)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlastDecayTick = UnityEngine.Time.time;\n\t\tif (!decay.ShouldDecay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = num * ConVar.Decay.scale;\n\t\tif (ConVar.Decay.upkeep)\n\t\t{\n\t\t\tupkeepTimer \u002B= num2;\n\t\t\tif (upkeepTimer \u003E 0f)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\t\t\tif (buildingPrivilege != null)\n\t\t\t\t{\n\t\t\t\t\tupkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (upkeepTimer \u003C 1f)\n\t\t\t{\n\t\t\t\tif (base.healthFraction \u003C 1f \u0026\u0026 ConVar.Decay.upkeep_heal_scale \u003E 0f \u0026\u0026 base.SecondsSinceAttacked \u003E 600f \u0026\u0026 Interface.CallHook(\u0022OnDecayHeal\u0022, this) == null)\n\t\t\t\t{\n\t\t\t\t\tfloat num3 = num / decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;\n\t\t\t\t\tHeal(MaxHealth() * num3);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tupkeepTimer = 1f;\n\t\t}\n\t\tdecayTimer \u002B= num2;\n\t\tif (decayTimer \u003C decay.GetDecayDelay(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022DecayTick\u0022))\n\t\t{\n\t\t\tfloat num4 = 1f;\n\t\t\tif (ConVar.Decay.upkeep)\n\t\t\t{\n\t\t\t\tif (!BypassInsideDecayMultiplier \u0026\u0026 !IsOutside())\n\t\t\t\t{\n\t\t\t\t\tnum4 *= ConVar.Decay.upkeep_inside_decay_scale;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C decayPoints.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tDecayPoint decayPoint = decayPoints[i];\n\t\t\t\t\tif (decayPoint.IsOccupied(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 -= decayPoint.protection;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (num4 \u003E 0f \u0026\u0026 Interface.CallHook(\u0022OnDecayDamage\u0022, this) == null)\n\t\t\t{\n\t\t\t\tfloat num5 = num2 / decay.GetDecayDuration(this) * MaxHealth();\n\t\t\t\tHurt(num5 * num4 * decayVariance, DamageType.Decay);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DecayEntity",
    "HookLineInvoke": 66
  },
  {
    "HookSignature": "OnRidableAnimalClaim(BaseRidableAnimal baseRidableAnimal, BasePlayer player, Item item)",
    "MethodSignature": "RPC_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 IsForSale())\n\t\t{\n\t\t\tint tokenItemID = msg.read.Int32();\n\t\t\tItem item = GetPurchaseToken(player, tokenItemID);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player, item) == null)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tOnClaimedWithToken(item);\n\t\t\t\titem.UseItem();\n\t\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnMlrsTarget(MLRS mLRS, UnityEngine.Vector3 worldPos, BasePlayer _mounted)",
    "MethodSignature": "SetUserTargetHitPos(Vector3 worldPos)",
    "MethodSourseCode": "\n\tpublic void SetUserTargetHitPos(Vector3 worldPos)\n\t{\n\t\tif (UserTargetHitPos == worldPos)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tVector3 position = TerrainMeta.Position;\n\t\t\tVector3 vector = position \u002B TerrainMeta.Size;\n\t\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\n\t\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\n\t\t\tworldPos.y = GetSurfaceHeight(worldPos);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnMlrsTarget\u0022, this, worldPos, _mounted) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserTargetHitPos = worldPos;\n\t\tif (base.isServer)\n\t\t{\n\t\t\ttrueTargetHitPos = UserTargetHitPos;\n\t\t\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\n\t\t\t{\n\t\t\t\tVector3 center = allSafeZone.triggerCollider.bounds.center;\n\t\t\t\tcenter.y = 0f;\n\t\t\t\tfloat num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) \u002B targetAreaRadius;\n\t\t\t\ttrueTargetHitPos.y = 0f;\n\t\t\t\tif (Vector3.Distance(center, trueTargetHitPos) \u003C num)\n\t\t\t\t{\n\t\t\t\t\tVector3 vector2 = trueTargetHitPos - center;\n\t\t\t\t\ttrueTargetHitPos = center \u002B vector2.normalized * num;\n\t\t\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnMlrsTargetSet\u0022, this, trueTargetHitPos, _mounted);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanStackItem(Item item, Item item)",
    "MethodSignature": "CanStack(Item item)",
    "MethodSourseCode": "\n\tpublic bool CanStack(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanStackItem\u0022, this, item);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (item == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (MaxStackable() \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.MaxStackable() \u003C= 1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.itemid != info.itemid)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (hasCondition \u0026\u0026 condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.hasCondition \u0026\u0026 item.condition != item.info.condition.max)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValid())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBlueprint() \u0026\u0026 blueprintTarget != item.blueprintTarget)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.skin != skin)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t{\n\t\t\tint num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\tint num2 = ((instanceData != null) ? instanceData.dataInt : (-1));\n\t\t\tif (num != num2)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (item.instanceData != null \u0026\u0026 instanceData != null \u0026\u0026 (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt \u0026\u0026 item.info.Blueprint != null \u0026\u0026 item.info.Blueprint.workbenchLevelRequired == 3)))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (instanceData != null \u0026\u0026 instanceData.subEntity.IsValid \u0026\u0026 (bool)info.GetComponent\u003CItemModSign\u003E())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (item.instanceData != null \u0026\u0026 item.instanceData.subEntity.IsValid \u0026\u0026 (bool)item.info.GetComponent\u003CItemModSign\u003E())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer player)",
    "MethodSignature": "OnDeployed(BaseEntity ent, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal void OnDeployed(BaseEntity ent, BasePlayer player)\n\t{\n\t\tif (player.IsValid() \u0026\u0026 !string.IsNullOrEmpty(UnlockAchievement))\n\t\t{\n\t\t\tplayer.GiveAchievement(UnlockAchievement);\n\t\t}\n\t\tif (ent is BuildingPrivlidge buildingPrivlidge \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, buildingPrivlidge, player) == null)\n\t\t{\n\t\t\tbuildingPrivlidge.AddPlayer(player);\n\t\t}\n\t}\n",
    "ClassName": "ItemModDeployable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnItemResearch(ResearchTable researchTable, Item targetItem, BasePlayer player)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tint scrapCost = ScrapForResearch(targetItem);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnBonusItemDropped(Item item, BasePlayer basePlayer)",
    "MethodSignature": "DropBonusItems(BaseEntity initiator, ItemContainer container)",
    "MethodSourseCode": "\n\tpublic override void DropBonusItems(BaseEntity initiator, ItemContainer container)\n\t{\n\t\tbase.DropBonusItems(initiator, container);\n\t\tif (initiator == null || container == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = initiator as BasePlayer;\n\t\tif (basePlayer == null || scrapAmount \u003C= 0 || !(scrapDef != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = ((basePlayer.modifiers != null) ? (1f \u002B basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);\n\t\tif (!(num \u003E 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);\n\t\tfloat num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);\n\t\tvariableValue \u002B= num2;\n\t\tint num3 = 0;\n\t\tif (variableValue \u003E= 1f)\n\t\t{\n\t\t\tnum3 = (int)variableValue;\n\t\t\tvariableValue -= (float)num3;\n\t\t}\n\t\tbasePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);\n\t\tif (num3 \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(scrapDef, num3, 0uL);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnBonusItemDrop\u0022, item, basePlayer) == null)\n\t\t\t{\n\t\t\t\t(item.Drop(GetDropPosition() \u002B new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t\tInterface.CallHook(\u0022OnBonusItemDropped\u0022, item, basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 34
  },
  {
    "HookSignature": "OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string text, IRemoteControllable remoteControllable)",
    "MethodSignature": "BeginControllingBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void BeginControllingBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);\n\t\tif (remoteControllable == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity ent = remoteControllable.GetEnt();\n\t\tif (ent == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022RC identifier \u0022 \u002B text \u002B \u0022 was found but has a null or destroyed entity, this should never happen\u0022);\n\t\t}\n\t\telse if (remoteControllable.CanControl(player.userID) \u0026\u0026 !(Vector3.Distance(base.transform.position, ent.transform.position) \u003E= remoteControllable.MaxRange) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkControl\u0022, this, player, text, remoteControllable) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tIRemoteControllable component = baseEntity.GetComponent\u003CIRemoteControllable\u003E();\n\t\t\t\tcomponent?.StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, player, component);\n\t\t\t}\n\t\t\tplayer.net.SwitchSecondaryGroup(ent.net.group);\n\t\t\tcurrentlyControllingEnt.uid = ent.net.ID;\n\t\t\tcurrentPlayerID = player.userID;\n\t\t\tbool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t\tSetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tSendControlBookmarks(player);\n\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 remoteControllable.GetEnt() is CCTV_RC)\n\t\t\t{\n\t\t\t\tInvokeRepeating(CheckCCTVAchievement, 1f, 3f);\n\t\t\t}\n\t\t\tInvokeRepeating(ControlCheck, 0f, 0f);\n\t\t\tInterface.CallHook(\u0022OnBookmarkControlStarted\u0022, this, player, text, remoteControllable);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 45
  },
  {
    "HookSignature": "OnSwitchToggle(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer)",
    "MethodSignature": "SvSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(2uL)]\n\t[RPC_Server]\n\tprivate void SvSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnFishCaught(ItemDefinition currentFishTarget, BaseFishingRod baseFishingRod, BasePlayer ownerPlayer)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(null, \u0022Client_HookedSomething\u0022);\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(null, \u0022Client_UpdateFishState\u0022, (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tfishLookup.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\n\t\t\tClientRPC(null, \u0022Client_OnCaughtFish\u0022, currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 193
  },
  {
    "HookSignature": "OnSupplyDropLanded(SupplyDrop supplyDrop)",
    "MethodSignature": "OnCollisionEnter(Collision collision)",
    "MethodSourseCode": "\n\tprivate void OnCollisionEnter(Collision collision)\n\t{\n\t\tif (((1 \u003C\u003C collision.collider.gameObject.layer) \u0026 0x40A10111) \u003E 0)\n\t\t{\n\t\t\tRemoveParachute();\n\t\t\tMakeLootable();\n\t\t}\n\t\tInterface.CallHook(\u0022OnSupplyDropLanded\u0022, this);\n\t}\n",
    "ClassName": "SupplyDrop",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanUseVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanOpenLootPanel(BasePlayer player, string panelName)",
    "MethodSourseCode": "\n\tpublic override bool CanOpenLootPanel(BasePlayer player, string panelName)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (panelName == customerPanel)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (base.CanOpenLootPanel(player, panelName))\n\t\t{\n\t\t\treturn CanPlayerAdmin(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "RPC_LootPlayer(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_LootPlayer(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanBeLooted(player) \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerMain);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerWear);\n\t\t\tplayer.inventory.loot.AddContainer(inventory.containerBelt);\n\t\t\tInterface.CallHook(\u0022OnLootPlayer\u0022, this, player);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, \u0022player_corpse\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnRemoteIdentifierUpdate(PoweredRemoteControlEntity poweredRemoteControlEntity, string newID)",
    "MethodSignature": "UpdateIdentifier(string newID, bool clientSend)",
    "MethodSourseCode": "\n\tpublic void UpdateIdentifier(string newID, bool clientSend = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRemoteIdentifierUpdate\u0022, this, newID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t_ = rcIdentifier;\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (!RemoteControlEntity.IDInUse(newID))\n\t\t\t{\n\t\t\t\trcIdentifier = newID;\n\t\t\t}\n\t\t\tif (!Rust.Application.isLoadingSave)\n\t\t\t{\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PoweredRemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnHorseUnhitch(RidableHorse horse, HitchTrough.HitchSpot hitchSpot)",
    "MethodSignature": "Unhitch(RidableHorse horse)",
    "MethodSourseCode": "\n\tpublic void Unhitch(RidableHorse horse)\n\t{\n\t\tHitchSpot[] array = hitchSpots;\n\t\tforeach (HitchSpot hitchSpot in array)\n\t\t{\n\t\t\tif (hitchSpot.GetHorse(base.isServer) == horse)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnHorseUnhitch\u0022, horse, hitchSpot) != null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thitchSpot.SetOccupiedBy(null);\n\t\t\t\thorse.SetHitch(null);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanAcceptItem(ItemContainer itemContainer, Item item, int targetPos)",
    "MethodSignature": "CanAcceptItem(Item item, int targetPos)",
    "MethodSourseCode": "\n\tpublic CanAcceptResult CanAcceptItem(Item item, int targetPos)\n\t{\n\t\tif (canAcceptItem != null \u0026\u0026 !canAcceptItem(item, targetPos))\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (isServer \u0026\u0026 availableSlots != null \u0026\u0026 availableSlots.Count \u003E 0)\n\t\t{\n\t\t\tif (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tforeach (ItemSlot availableSlot in availableSlots)\n\t\t\t{\n\t\t\t\tnum |= (int)availableSlot;\n\t\t\t}\n\t\t\tif (((uint)num \u0026 (uint)item.info.occupySlots) != (uint)item.info.occupySlots)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAcceptRightNow;\n\t\t\t}\n\t\t}\n\t\tif ((allowedContents \u0026 item.info.itemType) != item.info.itemType)\n\t\t{\n\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t}\n\t\tif (HasLimitedAllowedItems)\n\t\t{\n\t\t\tbool flag = false;\n\t\t\tfor (int i = 0; i \u003C onlyAllowedItems.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (onlyAllowedItems[i] == item.info)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\treturn CanAcceptResult.CannotAccept;\n\t\t\t}\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAcceptItem\u0022, this, item, targetPos);\n\t\tif (obj is CanAcceptResult)\n\t\t{\n\t\t\treturn (CanAcceptResult)obj;\n\t\t}\n\t\treturn CanAcceptResult.CanAccept;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "OnFuelCheck(EntityFuelSystem entityFuelSystem)",
    "MethodSignature": "HasFuel(bool forceCheck)",
    "MethodSourseCode": "\n\tpublic bool HasFuel(bool forceCheck = false)\n\t{\n\t\tif (Time.time \u003E nextFuelCheckTime || forceCheck)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnFuelCheck\u0022, this);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tcachedHasFuel = (float)GetFuelAmount() \u003E 0f;\n\t\t\tnextFuelCheckTime = Time.time \u002B UnityEngine.Random.Range(1f, 2f);\n\t\t}\n\t\treturn cachedHasFuel;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnFuelConsume(BaseOven baseOven, Item fuel, ItemModBurnable burnable)",
    "MethodSignature": "ConsumeFuel(Item fuel, ItemModBurnable burnable)",
    "MethodSourseCode": "\n\tpublic void ConsumeFuel(Item fuel, ItemModBurnable burnable)\n\t{\n\t\tif (Interface.CallHook(\u0022OnFuelConsume\u0022, this, fuel, burnable) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (allowByproductCreation \u0026\u0026 burnable.byproductItem != null \u0026\u0026 UnityEngine.Random.Range(0f, 1f) \u003E burnable.byproductChance)\n\t\t{\n\t\t\tItem item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\tOvenFull();\n\t\t\t\titem.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);\n\t\t\t}\n\t\t}\n\t\tif (fuel.amount \u003C= GetFuelRate())\n\t\t{\n\t\t\tfuel.Remove();\n\t\t\treturn;\n\t\t}\n\t\tint fuelRate = GetFuelRate();\n\t\tfuel.UseItem(fuelRate);\n\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \u0022smelt\u0022);\n\t\tfuel.fuel = burnable.fuelAmount;\n\t\tfuel.MarkDirty();\n\t\tInterface.CallHook(\u0022OnFuelConsumed\u0022, this, fuel, burnable);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRecyclerToggle(Recycler recycler, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag == IsOn() || msg.player == null || Interface.CallHook(\u0022OnRecyclerToggle\u0022, this, msg.player) != null || (flag \u0026\u0026 !HasRecyclable()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tforeach (Item item in base.inventory.itemList)\n\t\t\t{\n\t\t\t\titem.CollectedForCrafting(msg.player);\n\t\t\t}\n\t\t\tStartRecycling();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStopRecycling();\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnLiquidWeaponFiringStopped(LiquidWeapon liquidWeapon)",
    "MethodSignature": "StopFiring()",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void StopFiring()\n\t{\n\t\tCancelInvoke(\u0022FireTick\u0022);\n\t\tif (!RequiresPumping)\n\t\t{\n\t\t\tpressure = MaxPressure;\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tif (base.isServer)\n\t\t{\n\t\t\tSendNetworkUpdateImmediate();\n\t\t}\n\t\tInterface.CallHook(\u0022OnLiquidWeaponFiringStopped\u0022, this);\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnTakeCurrencyItem(VendingMachine vendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic virtual void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null \u0026\u0026 !takenCurrencyItem.MoveToContainer(base.inventory))\n\t\t{\n\t\t\ttakenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "PlayerInit(Network.Connection c)",
    "MethodSourseCode": "\n\tpublic void PlayerInit(Network.Connection c)\n\t{\n\t\tusing (TimeWarning.New(\u0022PlayerInit\u0022, 10))\n\t\t{\n\t\t\tCancelInvoke(base.KillMessage);\n\t\t\tSetPlayerFlag(PlayerFlags.Connected, b: true);\n\t\t\tactivePlayerList.Add(this);\n\t\t\tbots.Remove(this);\n\t\t\tuserID = c.userid;\n\t\t\tUserIDString = userID.ToString();\n\t\t\tdisplayName = c.username;\n\t\t\tc.player = this;\n\t\t\tsecondsConnected = 0;\n\t\t\tcurrentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.persistance.SetPlayerName(userID, displayName);\n\t\t\ttickInterpolator.Reset(base.transform.position);\n\t\t\ttickHistory.Reset(base.transform.position);\n\t\t\teyeHistory.Clear();\n\t\t\tlastTickTime = 0f;\n\t\t\tlastInputTime = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tstats.Init();\n\t\t\tInvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));\n\t\t\tpreviousLifeStory = SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetLastLifeStory(userID);\n\t\t\tSetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);\n\t\t\tSetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));\n\t\t\tif (IsDead() \u0026\u0026 net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))\n\t\t\t{\n\t\t\t\tSendNetworkGroupChange();\n\t\t\t}\n\t\t\tnet.OnConnected(c);\n\t\t\tnet.StartSubscriber();\n\t\t\tSendAsSnapshot(net.connection);\n\t\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);\n\t\t\t}\n\t\t\tif (net != null)\n\t\t\t{\n\t\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnPlayerConnected\u0022, this);\n\t\t\tif (IsAdmin)\n\t\t\t{\n\t\t\t\tif (ConVar.AntiHack.noclip_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.noclip_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.speedhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.speedhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.flyhack_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.flyhack_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.projectile_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.projectile_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.melee_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.eye_protection \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tChatMessage(\u0022antihack.eye_protection is disabled!\u0022);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnTerrainCreate(TerrainGenerator terrainGenerator)",
    "MethodSignature": "CreateTerrain(int heightmapResolution, int alphamapResolution)",
    "MethodSourseCode": "\n\tpublic GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)\n\t{\n\t\tInterface.CallHook(\u0022OnTerrainCreate\u0022, this);\n\t\tTerrain component = Terrain.CreateTerrainGameObject(new TerrainData\n\t\t{\n\t\t\tbaseMapResolution = GetBaseMapRes(),\n\t\t\theightmapResolution = heightmapResolution,\n\t\t\talphamapResolution = alphamapResolution,\n\t\t\tsize = new Vector3(World.Size, 1000f, World.Size)\n\t\t}).GetComponent\u003CTerrain\u003E();\n\t\tcomponent.transform.position = base.transform.position \u002B new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);\n\t\tcomponent.drawInstanced = false;\n\t\tcomponent.castShadows = config.CastShadows;\n\t\tcomponent.materialType = Terrain.MaterialType.Custom;\n\t\tcomponent.materialTemplate = config.Material;\n\t\tcomponent.gameObject.tag = base.gameObject.tag;\n\t\tcomponent.gameObject.layer = base.gameObject.layer;\n\t\tcomponent.gameObject.GetComponent\u003CTerrainCollider\u003E().sharedMaterial = config.GenericMaterial;\n\t\tTerrainMeta terrainMeta = component.gameObject.AddComponent\u003CTerrainMeta\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPhysics\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainColors\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainCollision\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainBiomeMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainAlphaMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainHeightMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainSplatMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainTopologyMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainWaterMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPlacementMap\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainPath\u003E();\n\t\tcomponent.gameObject.AddComponent\u003CTerrainTexturing\u003E();\n\t\tterrainMeta.terrain = component;\n\t\tterrainMeta.config = config;\n\t\tObject.DestroyImmediate(base.gameObject);\n\t\treturn component.gameObject;\n\t}\n",
    "ClassName": "TerrainGenerator",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorMiningToggled(ExcavatorArm excavatorArm)",
    "MethodSignature": "BeginMining()",
    "MethodSourseCode": "\n\tpublic void BeginMining()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.On, b: true);\n\t\tInvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);\n\t\tif (UnityEngine.Time.time \u003E nextNotificationTime)\n\t\t{\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tif (!activePlayer.IsNpc \u0026\u0026 activePlayer.IsConnected)\n\t\t\t\t{\n\t\t\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnextNotificationTime = UnityEngine.Time.time \u002B 60f;\n\t\t}\n\t\tExcavatorServerEffects.SetMining(isMining: true);\n\t\tFacepunch.Rust.Analytics.Server.ExcavatorStarted();\n\t\texcavatorStartTime = GetNetworkTime();\n\t\tInterface.CallHook(\u0022OnExcavatorMiningToggled\u0022, this);\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnPlayerReported(BasePlayer basePlayer, string text5, string text4, string text, string text2, string text3)",
    "MethodSignature": "OnPlayerReported(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void OnPlayerReported(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tstring text2 = msg.read.StringMultiLine();\n\t\tstring text3 = msg.read.String();\n\t\tstring text4 = msg.read.String();\n\t\tstring text5 = msg.read.String();\n\t\tDebugEx.Log($\u0022[PlayerReport] {this} reported {text5}[{text4}] - \\\u0022{text}\\\u0022\u0022);\n\t\tRCon.Broadcast(RCon.LogType.Report, new\n\t\t{\n\t\t\tPlayerId = UserIDString,\n\t\t\tPlayerName = displayName,\n\t\t\tTargetId = text4,\n\t\t\tTargetName = text5,\n\t\t\tSubject = text,\n\t\t\tMessage = text2,\n\t\t\tType = text3\n\t\t});\n\t\tInterface.CallHook(\u0022OnPlayerReported\u0022, this, text5, text4, text, text2, text3);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnCollectiblePickup(CollectibleEntity collectibleEntity, BasePlayer reciever, bool eat)",
    "MethodSignature": "DoPickup(BasePlayer reciever, bool eat)",
    "MethodSourseCode": "\n\tpublic void DoPickup(BasePlayer reciever, bool eat = false)\n\t{\n\t\tif (itemList == null || Interface.CallHook(\u0022OnCollectiblePickup\u0022, this, reciever, eat) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemAmount[] array = itemList;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (eat \u0026\u0026 item.info.category == ItemCategory.Food \u0026\u0026 reciever != null)\n\t\t\t{\n\t\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\t\tif (component != null)\n\t\t\t\t{\n\t\t\t\t\tcomponent.DoAction(item, reciever);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((bool)reciever)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);\n\t\t\t\treciever.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t}\n\t\t}\n\t\titemList = null;\n\t\tif (pickupEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);\n\t\t}\n\t\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find\u003CRandomItemDispenser\u003E(prefabID);\n\t\tif (randomItemDispenser != null)\n\t\t{\n\t\t\trandomItemDispenser.DistributeItems(reciever, base.transform.position);\n\t\t}\n\t\tKill();\n\t}\n",
    "ClassName": "CollectibleEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanElevatorLiftMove(ElevatorLift elevatorLift)",
    "MethodSignature": "CanMove()",
    "MethodSourseCode": "\n\tpublic bool CanMove()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanElevatorLiftMove\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn !VehicleTrigger.HasContents;\n\t}\n",
    "ClassName": "ElevatorLift",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityTakeDamage(ResourceEntity resourceEntity, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (!base.isServer || isKilled || Interface.CallHook(\u0022OnEntityTakeDamage\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (resourceDispenser != null)\n\t\t{\n\t\t\tresourceDispenser.OnAttacked(info);\n\t\t}\n\t\tif (!info.DidGather)\n\t\t{\n\t\t\tif ((bool)baseProtection)\n\t\t\t{\n\t\t\t\tbaseProtection.Scale(info.damageTypes);\n\t\t\t}\n\t\t\tfloat num = info.damageTypes.Total();\n\t\t\thealth -= num;\n\t\t\tif (health \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnKilled(info);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOnHealthChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ResourceEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnConstructionPlace(BaseEntity baseEntity, Construction component, Construction.Target placement, BasePlayer ownerPlayer)",
    "MethodSignature": "DoPlacement(Construction.Target placement, Construction component)",
    "MethodSourseCode": "\n\tpublic GameObject DoPlacement(Construction.Target placement, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tBaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tfloat num = 1f;\n\t\tfloat num2 = 0f;\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null)\n\t\t{\n\t\t\tbaseEntity.skinID = ownerItem.skin;\n\t\t\tif (ownerItem.hasCondition)\n\t\t\t{\n\t\t\t\tnum = ownerItem.conditionNormalized;\n\t\t\t}\n\t\t}\n\t\tPoolableEx.AwakeFromInstantiate(baseEntity.gameObject);\n\t\tBuildingBlock buildingBlock = baseEntity as BuildingBlock;\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tbuildingBlock.blockDefinition = PrefabAttribute.server.Find\u003CConstruction\u003E(buildingBlock.prefabID);\n\t\t\tif (!buildingBlock.blockDefinition)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Placing a building block that has no block definition!\u0022);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tbuildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);\n\t\t\tnum2 = buildingBlock.currentGrade.maxHealth;\n\t\t}\n\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\tif ((bool)baseCombatEntity)\n\t\t{\n\t\t\tnum2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);\n\t\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\n\t\t\tbaseCombatEntity.InitializeHealth(num2 * num, num2);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnConstructionPlace\u0022, baseEntity, component, placement, ownerPlayer) != null)\n\t\t{\n\t\t\tif (baseEntity.IsValid())\n\t\t\t{\n\t\t\t\tbaseEntity.KillMessage();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGameManager.Destroy(baseEntity);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tbaseEntity.gameObject.SendMessage(\u0022SetDeployedBy\u0022, ownerPlayer, SendMessageOptions.DontRequireReceiver);\n\t\tbaseEntity.OwnerID = ownerPlayer.userID;\n\t\tbaseEntity.Spawn();\n\t\tif ((bool)buildingBlock)\n\t\t{\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/build/frame_place.prefab\u0022, baseEntity, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t\tStabilityEntity stabilityEntity = baseEntity as StabilityEntity;\n\t\tif ((bool)stabilityEntity)\n\t\t{\n\t\t\tstabilityEntity.UpdateSurroundingEntities();\n\t\t}\n\t\treturn baseEntity.gameObject;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnPhoneDial(PhoneController phoneController, PhoneController telephone, BasePlayer currentPlayer)",
    "MethodSignature": "CallPhone(int number)",
    "MethodSourseCode": "\n\tpublic void CallPhone(int number)\n\t{\n\t\tif (number == PhoneNumber)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.CallSelf);\n\t\t\treturn;\n\t\t}\n\t\tif (TelephoneManager.GetCurrentActiveCalls() \u002B 1 \u003E TelephoneManager.MaxConcurrentCalls)\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.NetworkBusy);\n\t\t\treturn;\n\t\t}\n\t\tPhoneController telephone = TelephoneManager.GetTelephone(number);\n\t\tif (telephone != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnPhoneDial\u0022, this, telephone, currentPlayer) == null)\n\t\t\t{\n\t\t\t\tif (telephone.serverState == Telephone.CallState.Idle \u0026\u0026 telephone.CanReceiveCall())\n\t\t\t\t{\n\t\t\t\t\tSetPhoneState(Telephone.CallState.Dialing);\n\t\t\t\t\tlastDialedNumber = number;\n\t\t\t\t\tactiveCallTo = telephone;\n\t\t\t\t\tactiveCallTo.ReceiveCallFrom(this);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tOnDialFailed(Telephone.DialFailReason.Engaged);\n\t\t\t\t\ttelephone.OnIncomingCallWhileBusy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnDialFailed(Telephone.DialFailReason.WrongNumber);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnServerUserRemove(ulong uid)",
    "MethodSignature": "Remove(ulong uid)",
    "MethodSourseCode": "\n\tpublic static void Remove(ulong uid)\n\t{\n\t\tInterface.CallHook(\u0022OnServerUserRemove\u0022, uid);\n\t\tusers.Remove(uid);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer rpcPlayer, int num, int num2)",
    "MethodSignature": "BuyItem(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void BuyItem(RPCMessage rpc)\n\t{\n\t\tif (OccupiedCheck(rpc.player))\n\t\t{\n\t\t\tint num = rpc.read.Int32();\n\t\t\tint num2 = rpc.read.Int32();\n\t\t\tif (IsVending())\n\t\t\t{\n\t\t\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnBuyVendingItem\u0022, this, rpc.player, num, num2) == null)\n\t\t\t{\n\t\t\t\tSetPendingOrder(rpc.player, num, num2);\n\t\t\t\tInvoke(CompletePendingOrder, GetBuyDuration());\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnNpcConversationRespond(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode != null \u0026\u0026 Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) == null)\n\t\t{\n\t\t\tif (responseNode.conditions.Length != 0)\n\t\t\t{\n\t\t\t\tUpdateFlags();\n\t\t\t}\n\t\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\t\tif (flag \u0026\u0026 !string.IsNullOrEmpty(responseNode.actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, responseNode.actionString);\n\t\t\t}\n\t\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\t\tif (speechNodeIndex == -1)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tForceSpeechNode(player, speechNodeIndex);\n\t\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnPlayerLanded(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tmetabolism.bleeding.Add(num * 0.5f);\n\t\t\tfloat num2 = num * 500f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);\n\t\t\tHurt(num2, DamageType.Fall);\n\t\t\tif (num2 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnTurretAssign(AutoTurret autoTurret, ulong num, BasePlayer msgPlayer)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num != 0L \u0026\u0026 !IsAuthed(num) \u0026\u0026 Interface.CallHook(\u0022OnTurretAssign\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tstring username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = num;\n\t\t\tplayerNameID.username = username;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, num);\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnTurretAssigned\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnVehiclePush(BaseVehicle baseVehicle, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_WantsPush(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(5f)]\n\tpublic void RPC_WantsPush(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!player.isMounted \u0026\u0026 !RecentlyPushed \u0026\u0026 CanPushNow(player) \u0026\u0026 !(rigidBody == null) \u0026\u0026 (!OnlyOwnerAccessible() || !(player != creatorEntity)) \u0026\u0026 Interface.CallHook(\u0022OnVehiclePush\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tplayer.metabolism.calories.Subtract(3f);\n\t\t\tplayer.metabolism.SendChangesToClient();\n\t\t\tif (rigidBody.IsSleeping())\n\t\t\t{\n\t\t\t\trigidBody.WakeUp();\n\t\t\t}\n\t\t\tDoPushAction(player);\n\t\t\ttimeSinceLastPush = 0f;\n\t\t}\n\t}\n",
    "ClassName": "BaseVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnRfListenerAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tDebug.Log(\u0022adding same listener twice\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenList.Add(obj);\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnSamSiteTargetScan(SamSite samSite, System.Collections.Generic.List\u003CSamSite.ISamSiteTarget\u003E obj)",
    "MethodSignature": "TargetScan()",
    "MethodSourseCode": "\n\tpublic void TargetScan()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tlastTargetVisibleTime = 0f;\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.time \u003E lastTargetVisibleTime \u002B 3f)\n\t\t{\n\t\t\tClearTarget();\n\t\t}\n\t\tif (!staticRespawn)\n\t\t{\n\t\t\tint num = ((ammoItem != null \u0026\u0026 ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\n\t\t\tbool flag = lastAmmoCount \u003C lowAmmoThreshold;\n\t\t\tbool flag2 = num \u003C lowAmmoThreshold;\n\t\t\tif (num != lastAmmoCount \u0026\u0026 flag != flag2)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t\tlastAmmoCount = num;\n\t\t}\n\t\tif (HasValidTarget() || IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CISamSiteTarget\u003E obj = Facepunch.Pool.GetList\u003CISamSiteTarget\u003E();\n\t\tif (Interface.CallHook(\u0022OnSamSiteTargetScan\u0022, this, obj) == null)\n\t\t{\n\t\t\tif (!IsInDefenderMode())\n\t\t\t{\n\t\t\t\tAddTargetSet(obj, 32768, targetTypeVehicle.scanRadius);\n\t\t\t}\n\t\t\tAddTargetSet(obj, 1048576, targetTypeMissile.scanRadius);\n\t\t}\n\t\tISamSiteTarget samSiteTarget = null;\n\t\tforeach (ISamSiteTarget item in obj)\n\t\t{\n\t\t\tif (!item.isClient \u0026\u0026 !(item.CenterPoint().y \u003C eyePoint.transform.position.y) \u0026\u0026 item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) \u0026\u0026 item.IsValidSAMTarget(staticRespawn) \u0026\u0026 Interface.CallHook(\u0022OnSamSiteTarget\u0022, this, item) == null)\n\t\t\t{\n\t\t\t\tsamSiteTarget = item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ObjectEx.IsUnityNull(samSiteTarget) \u0026\u0026 currentTarget != samSiteTarget)\n\t\t{\n\t\t\tlockOnTime = UnityEngine.Time.time \u002B 0.5f;\n\t\t}\n\t\tSetTarget(samSiteTarget);\n\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tlastTargetVisibleTime = UnityEngine.Time.time;\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj);\n\t\tif (ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tCancelInvoke(WeaponTick);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\n\t\t}\n\t\tvoid AddTargetSet(List\u003CISamSiteTarget\u003E allTargets, int layerMask, float scanRadius)\n\t\t{\n\t\t\tList\u003CISamSiteTarget\u003E obj2 = Facepunch.Pool.GetList\u003CISamSiteTarget\u003E();\n\t\t\tVis.Entities(eyePoint.transform.position, scanRadius, obj2, layerMask, QueryTriggerInteraction.Ignore);\n\t\t\tallTargets.AddRange(obj2);\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "OnGrowableGathered(GrowableEntity growableEntity, Item item, BasePlayer player)",
    "MethodSignature": "GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)",
    "MethodSourseCode": "\n\tpublic void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)\n\t{\n\t\tItem item = ItemManager.Create(Properties.pickupItem, amount, 0uL);\n\t\tif (applyCondition)\n\t\t{\n\t\t\titem.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);\n\t\t}\n\t\tif (eat \u0026\u0026 player != null \u0026\u0026 IsFood())\n\t\t{\n\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\tif (component != null)\n\t\t\t{\n\t\t\t\tcomponent.DoAction(item, player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (player != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnGrowableGathered\u0022, this, item, player);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);\n\t\t\tplayer.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "CanUseGesture(BasePlayer player, GestureConfig gestureConfig)",
    "MethodSignature": "IsOwnedBy(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool IsOwnedBy(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseGesture\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (forceUnlock)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (gestureType == GestureType.NPC)\n\t\t{\n\t\t\treturn player.IsNpc;\n\t\t}\n\t\tif (gestureType == GestureType.Cinematic)\n\t\t{\n\t\t\treturn player.IsAdmin;\n\t\t}\n\t\tif (dlcItem != null \u0026\u0026 dlcItem.CanUse(player))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (inventoryItem != null \u0026\u0026 player.blueprints.steamInventory.HasItem(inventoryItem.id))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "GestureConfig",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDieselEngineToggle(DieselEngine dieselEngine, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(6f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnDieselEngineToggle\u0022, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (msg.read.Bit())\n\t\t{\n\t\t\tif (GetFuelAmount() \u003E 0)\n\t\t\t{\n\t\t\t\tEngineOn();\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 msg.player != null)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.stats.Add(\u0022excavator_activated\u0022, 1, Stats.All);\n\t\t\t\t\tmsg.player.stats.Save(forceSteamSave: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEngineOff();\n\t\t}\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnInventoryItemsFind(PlayerInventory playerInventory, int id)",
    "MethodSignature": "FindItemIDs(int id)",
    "MethodSourseCode": "\n\tpublic List\u003CItem\u003E FindItemIDs(int id)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryItemsFind\u0022, this, id);\n\t\tif (obj is List\u003CItem\u003E)\n\t\t{\n\t\t\treturn (List\u003CItem\u003E)obj;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tif (containerMain != null)\n\t\t{\n\t\t\tlist.AddRange(containerMain.FindItemsByItemID(id));\n\t\t}\n\t\tif (containerBelt != null)\n\t\t{\n\t\t\tlist.AddRange(containerBelt.FindItemsByItemID(id));\n\t\t}\n\t\tif (containerWear != null)\n\t\t{\n\t\t\tlist.AddRange(containerWear.FindItemsByItemID(id));\n\t\t}\n\t\treturn list;\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSetBedPublic(BasePlayer msgPlayer, SleepingBag sleepingBag)",
    "MethodSignature": "RPC_MakePublic(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic virtual void RPC_MakePublic(RPCMessage msg)\n\t{\n\t\tif (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID \u0026\u0026 !msg.player.CanBuild()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = msg.read.Bit();\n\t\tif (flag == IsPublic() || Interface.CallHook(\u0022CanSetBedPublic\u0022, msg.player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetPublic(flag);\n\t\tif (!IsPublic())\n\t\t{\n\t\t\tBaseGameMode.CanAssignBedResult? canAssignBedResult = BaseGameMode.GetActiveGameMode(serverside: true)?.CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);\n\t\t\tif (canAssignBedResult.HasValue)\n\t\t\t{\n\t\t\t\tif (canAssignBedResult.Value.Result)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t}\n\t\t\t\tif (!canAssignBedResult.Value.Result)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeployerUserID = msg.player.userID;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);\n\t\t}\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnOutputUpdate(IOEntity iOEntity)",
    "MethodSignature": "UpdateOutputs()",
    "MethodSourseCode": "\n\tpublic virtual void UpdateOutputs()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOutputUpdate\u0022, this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tensureOutputsUpdated = false;\n\t\tusing (TimeWarning.New(\u0022ProcessIOOutputs\u0022))\n\t\t{\n\t\t\tfor (int i = 0; i \u003C outputs.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tIOSlot iOSlot = outputs[i];\n\t\t\t\tbool flag = true;\n\t\t\t\tIOEntity iOEntity = iOSlot.connectedTo.Get();\n\t\t\t\tif (!(iOEntity != null))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ioType == IOType.Fluidic \u0026\u0026 !DisregardGravityRestrictionsOnLiquid \u0026\u0026 !iOEntity.DisregardGravityRestrictionsOnLiquid)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022FluidOutputProcessing\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint passthroughAmount = GetPassthroughAmount(i);\n\t\t\t\tiOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNetworkTo(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (IsSpectating() \u0026\u0026 player != this \u0026\u0026 !player.net.connection.info.GetBool(\u0022global.specnet\u0022))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn base.ShouldNetworkTo(player);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "CanDropCrate()",
    "MethodSourseCode": "\n\tpublic bool CanDropCrate()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterDropCrate\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn numCrates \u003E 0;\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorSuppliesRequest(ExcavatorSignalComputer excavatorSignalComputer, BasePlayer rpcPlayer)",
    "MethodSignature": "RequestSupplies(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void RequestSupplies(RPCMessage rpc)\n\t{\n\t\tif (HasFlag(Flags.Reserved7) \u0026\u0026 IsPowered() \u0026\u0026 chargePower \u003E= chargeNeededForSupplies \u0026\u0026 Interface.CallHook(\u0022OnExcavatorSuppliesRequest\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tVector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\n\t\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnExcavatorSuppliesRequested\u0022, this, rpc.player, baseEntity);\n\t\t\tchargePower -= chargeNeededForSupplies;\n\t\t\tSetFlag(Flags.Reserved7, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorSignalComputer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnCorpsePopulate(ScarecrowNPC scarecrowNPC, string text)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring text = \u0022assets/prefabs/npc/murderer/murderer_corpse.prefab\u0022;\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(text) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = \u0022Scarecrow\u0022;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, text);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int i = 0; i \u003C lootSpawnSlots.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];\n\t\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlot.numberToSpawn; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "ScarecrowNPC",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnSprayCreate(SprayCan sprayCan, UnityEngine.Vector3 vector, UnityEngine.Quaternion quaternion)",
    "MethodSignature": "CreateSpray(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CreateSpray(RPCMessage msg)\n\t{\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tClientRPC(null, \u0022Client_ChangeSprayColour\u0022, -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3();\n\t\tVector3 point = msg.read.Vector3();\n\t\tint num = msg.read.Int32();\n\t\tif (!(Vector3.Distance(vector, base.transform.position) \u003E 4.5f))\n\t\t{\n\t\t\tQuaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);\n\t\t\tquaternion *= Quaternion.Euler(0f, 0f, 90f);\n\t\t\tbool flag = false;\n\t\t\tif (msg.player.IsDeveloper)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (num != 0 \u0026\u0026 !flag \u0026\u0026 !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\n\t\t\t{\n\t\t\t\tDebug.Log($\u0022SprayCan.ChangeItemSkin player does not have item :{num}:\u0022);\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnSprayCreate\u0022, this, vector, quaternion) == null)\n\t\t\t{\n\t\t\t\tulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);\n\t\t\t\tbaseEntity.skinID = num2;\n\t\t\t\tbaseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tCheckAchievementPosition(vector);\n\t\t\t\tLoseCondition(ConditionLossPerSpray);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "CanWaterBallSplash(ItemDefinition liquidDef, UnityEngine.Vector3 position, float radius, int amount)",
    "MethodSignature": "DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)",
    "MethodSourseCode": "\n\tpublic static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanWaterBallSplash\u0022, liquidDef, position, radius, amount);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tList\u003CBaseEntity\u003E obj2 = Pool.GetList\u003CBaseEntity\u003E();\n\t\tVis.Entities(position, radius, obj2, 1219701523);\n\t\tint num = 0;\n\t\tint num2 = amount;\n\t\twhile (amount \u003E 0 \u0026\u0026 num \u003C 3)\n\t\t{\n\t\t\tList\u003CISplashable\u003E obj3 = Pool.GetList\u003CISplashable\u003E();\n\t\t\tforeach (BaseEntity item in obj2)\n\t\t\t{\n\t\t\t\tif (!item.isClient \u0026\u0026 item is ISplashable splashable \u0026\u0026 !obj3.Contains(splashable) \u0026\u0026 splashable.WantsSplash(liquidDef, amount))\n\t\t\t\t{\n\t\t\t\t\tobj3.Add(splashable);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obj3.Count == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint b = Mathf.CeilToInt(amount / obj3.Count);\n\t\t\tforeach (ISplashable item2 in obj3)\n\t\t\t{\n\t\t\t\tint num3 = item2.DoSplash(liquidDef, Mathf.Min(amount, b));\n\t\t\t\tamount -= num3;\n\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPool.FreeList(ref obj3);\n\t\t\tnum\u002B\u002B;\n\t\t}\n\t\tPool.FreeList(ref obj2);\n\t\treturn amount \u003C num2;\n\t}\n",
    "ClassName": "WaterBall",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, ModularCarSeat modularCarSeat)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (associatedSeatingModule.DoorsAreLockable)\n\t\t{\n\t\t\tModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;\n\t\t\tif (modularCar != null)\n\t\t\t{\n\t\t\t\treturn modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ModularCarSeat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "RunMetabolism(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tprotected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRunPlayerMetabolism\u0022, this, ownerEntity, delta) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tfloat currentTemperature = owner.currentTemperature;\n\t\tfloat fTarget = owner.currentComfort;\n\t\tfloat currentCraftLevel = owner.currentCraftLevel;\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, owner.InSafeZone());\n\t\tif (activeGameMode == null || activeGameMode.allowTemperature)\n\t\t{\n\t\t\tfloat num = currentTemperature;\n\t\t\tnum -= DeltaWet() * 34f;\n\t\t\tfloat num2 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);\n\t\t\tfloat num3 = Mathf.InverseLerp(20f, -50f, currentTemperature);\n\t\t\tfloat num4 = Mathf.InverseLerp(20f, 30f, currentTemperature);\n\t\t\tnum \u002B= num3 * 70f * num2;\n\t\t\tnum \u002B= num4 * 10f * Mathf.Abs(num2);\n\t\t\tnum \u002B= heartrate.value * 5f;\n\t\t\ttemperature.MoveTowards(num, delta * 5f);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemperature.value = 25f;\n\t\t}\n\t\tif (temperature.value \u003E= 40f)\n\t\t{\n\t\t\tfTarget = 0f;\n\t\t}\n\t\tcomfort.MoveTowards(fTarget, delta / 5f);\n\t\tfloat num5 = 0.6f \u002B 0.4f * comfort.value;\n\t\tif (calories.value \u003E 100f \u0026\u0026 owner.healthFraction \u003C num5 \u0026\u0026 radiation_poison.Fraction() \u003C 0.25f \u0026\u0026 owner.SecondsSinceAttacked \u003E 10f \u0026\u0026 !SignificantBleeding() \u0026\u0026 temperature.value \u003E= 10f \u0026\u0026 hydration.value \u003E 40f)\n\t\t{\n\t\t\tfloat num6 = Mathf.InverseLerp(calories.min, calories.max, calories.value);\n\t\t\tfloat num7 = 5f;\n\t\t\tfloat num8 = num7 * owner.MaxHealth() * 0.8f / 600f;\n\t\t\tnum8 \u002B= num8 * num6 * 0.5f;\n\t\t\tfloat num9 = num8 / num7;\n\t\t\tnum9 \u002B= num9 * comfort.value * 6f;\n\t\t\townerEntity.Heal(num9 * delta);\n\t\t\tcalories.Subtract(num8 * delta);\n\t\t\thydration.Subtract(num8 * delta * 0.2f);\n\t\t}\n\t\tfloat num10 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;\n\t\tfloat fTarget2 = Mathf.Clamp(0.05f \u002B num10, 0f, 1f);\n\t\theartrate.MoveTowards(fTarget2, delta * 0.1f);\n\t\tif (!owner.IsGod())\n\t\t{\n\t\t\tfloat num11 = heartrate.Fraction() * 0.375f;\n\t\t\tcalories.MoveTowards(0f, delta * num11);\n\t\t\tfloat num12 = 1f / 120f;\n\t\t\tnum12 \u002B= Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);\n\t\t\tnum12 \u002B= heartrate.value * (1f / 15f);\n\t\t\thydration.MoveTowards(0f, delta * num12);\n\t\t}\n\t\tbool b = hydration.Fraction() \u003C= 0f || radiation_poison.value \u003E= 100f;\n\t\towner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);\n\t\tif (temperature.value \u003E 40f)\n\t\t{\n\t\t\thydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);\n\t\t}\n\t\tif (temperature.value \u003C 10f)\n\t\t{\n\t\t\tfloat num13 = Mathf.InverseLerp(20f, -100f, temperature.value);\n\t\t\theartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num13), delta * 2f * num13);\n\t\t}\n\t\tfloat num14 = owner.AirFactor();\n\t\tfloat num15 = ((num14 \u003E oxygen.value) ? 1f : 0.1f);\n\t\toxygen.MoveTowards(num14, delta * num15);\n\t\tfloat f = 0f;\n\t\tfloat f2 = 0f;\n\t\tif (owner.IsOutside(owner.eyes.position))\n\t\t{\n\t\t\tf = Climate.GetRain(owner.eyes.position) * Weather.wetness_rain;\n\t\t\tf2 = Climate.GetSnow(owner.eyes.position) * Weather.wetness_snow;\n\t\t}\n\t\tbool flag = owner.baseProtection.amounts[4] \u003E 0f;\n\t\tfloat currentEnvironmentalWetness = owner.currentEnvironmentalWetness;\n\t\tcurrentEnvironmentalWetness = Mathf.Clamp(currentEnvironmentalWetness, 0f, 0.8f);\n\t\tfloat num16 = owner.WaterFactor();\n\t\tif (!flag \u0026\u0026 num16 \u003E 0f)\n\t\t{\n\t\t\twetness.value = Mathf.Max(wetness.value, Mathf.Clamp(num16, wetness.min, wetness.max));\n\t\t}\n\t\tfloat num17 = Mathx.Max(wetness.value, f, f2, currentEnvironmentalWetness);\n\t\tnum17 = Mathf.Min(num17, flag ? 0f : num17);\n\t\twetness.MoveTowards(num17, delta * 0.05f);\n\t\tif (num16 \u003C wetness.value \u0026\u0026 currentEnvironmentalWetness \u003C= 0f)\n\t\t{\n\t\t\twetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, currentTemperature));\n\t\t}\n\t\tpoison.MoveTowards(0f, delta * (5f / 9f));\n\t\tif (wetness.Fraction() \u003E 0.4f \u0026\u0026 owner.estimatedSpeed \u003E 0.25f \u0026\u0026 radiation_level.Fraction() == 0f)\n\t\t{\n\t\t\tradiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);\n\t\t}\n\t\tif (ConVar.Server.radiation \u0026\u0026 !owner.IsGod())\n\t\t{\n\t\t\tradiation_level.value = owner.radiationLevel;\n\t\t\tif (radiation_level.value \u003E 0f)\n\t\t\t{\n\t\t\t\tradiation_poison.Add(radiation_level.value * delta);\n\t\t\t}\n\t\t}\n\t\tif (pending_health.value \u003E 0f)\n\t\t{\n\t\t\tfloat num18 = Mathf.Min(1f * delta, pending_health.value);\n\t\t\townerEntity.Heal(num18);\n\t\t\tif (ownerEntity.healthFraction == 1f)\n\t\t\t{\n\t\t\t\tpending_health.value = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpending_health.Subtract(num18);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFindSpawnPoint(BasePlayer forPlayer)",
    "MethodSignature": "FindSpawnPoint(BasePlayer forPlayer)",
    "MethodSourseCode": "\n\tpublic static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindSpawnPoint\u0022, forPlayer);\n\t\tif (obj is BasePlayer.SpawnPoint)\n\t\t{\n\t\t\treturn (BasePlayer.SpawnPoint)obj;\n\t\t}\n\t\tbool flag = false;\n\t\tBaseGameMode baseGameMode = Gamemode();\n\t\tif ((bool)baseGameMode \u0026\u0026 baseGameMode.useCustomSpawns)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);\n\t\t\tif (playerSpawn != null)\n\t\t\t{\n\t\t\t\treturn playerSpawn;\n\t\t\t}\n\t\t}\n\t\tif (SingletonComponent\u003CSpawnHandler\u003E.Instance != null \u0026\u0026 !flag)\n\t\t{\n\t\t\tBasePlayer.SpawnPoint spawnPoint = SpawnHandler.GetSpawnPoint();\n\t\t\tif (spawnPoint != null)\n\t\t\t{\n\t\t\t\treturn spawnPoint;\n\t\t\t}\n\t\t}\n\t\tBasePlayer.SpawnPoint spawnPoint2 = new BasePlayer.SpawnPoint();\n\t\tGameObject[] array = GameObject.FindGameObjectsWithTag(\u0022spawnpoint\u0022);\n\t\tif (array.Length != 0)\n\t\t{\n\t\t\tGameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];\n\t\t\tspawnPoint2.pos = gameObject.transform.position;\n\t\t\tspawnPoint2.rot = gameObject.transform.rotation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.Log(\u0022Couldn\u0027t find an appropriate spawnpoint for the player - so spawning at camera\u0022);\n\t\t\tif (MainCamera.mainCamera != null)\n\t\t\t{\n\t\t\t\tspawnPoint2.pos = MainCamera.position;\n\t\t\t\tspawnPoint2.rot = MainCamera.rotation;\n\t\t\t}\n\t\t}\n\t\tif (UnityEngine.Physics.Raycast(new Ray(spawnPoint2.pos, Vector3.down), out var hitInfo, 32f, 1537286401))\n\t\t{\n\t\t\tspawnPoint2.pos = hitInfo.point;\n\t\t}\n\t\treturn spawnPoint2;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDestroy(BradleyAPC bradleyAPC)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnKilled(HitInfo info)\n\t{\n\t\tif (base.isClient || Interface.CallHook(\u0022OnEntityDestroy\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tCreateExplosionMarker(10f);\n\t\tEffect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);\n\t\tVector3 zero = Vector3.zero;\n\t\tGameObject gibSource = servergibs.Get().GetComponent\u003CServerGib\u003E()._gibSource;\n\t\tList\u003CServerGib\u003E list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);\n\t\tfor (int i = 0; i \u003C 12 - maxCratesToSpawn; i\u002B\u002B)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);\n\t\t\tif (!baseEntity)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat min = 3f;\n\t\t\tfloat max = 10f;\n\t\t\tVector3 onUnitSphere = UnityEngine.Random.onUnitSphere;\n\t\t\tbaseEntity.transform.position = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere * UnityEngine.Random.Range(-4f, 4f);\n\t\t\tCollider component = baseEntity.GetComponent\u003CCollider\u003E();\n\t\t\tbaseEntity.Spawn();\n\t\t\tbaseEntity.SetVelocity(zero \u002B onUnitSphere * UnityEngine.Random.Range(min, max));\n\t\t\tforeach (ServerGib item in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C maxCratesToSpawn; j\u002B\u002B)\n\t\t{\n\t\t\tVector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;\n\t\t\tonUnitSphere2.y = 0f;\n\t\t\tonUnitSphere2.Normalize();\n\t\t\tVector3 pos = base.transform.position \u002B new Vector3(0f, 1.5f, 0f) \u002B onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);\n\t\t\tBaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));\n\t\t\tbaseEntity2.Spawn();\n\t\t\tLootContainer lootContainer = baseEntity2 as LootContainer;\n\t\t\tif ((bool)lootContainer)\n\t\t\t{\n\t\t\t\tlootContainer.Invoke(lootContainer.RemoveMe, 1800f);\n\t\t\t}\n\t\t\tCollider component2 = baseEntity2.GetComponent\u003CCollider\u003E();\n\t\t\tRigidbody rigidbody = baseEntity2.gameObject.AddComponent\u003CRigidbody\u003E();\n\t\t\trigidbody.useGravity = true;\n\t\t\trigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;\n\t\t\trigidbody.mass = 2f;\n\t\t\trigidbody.interpolation = RigidbodyInterpolation.Interpolate;\n\t\t\trigidbody.velocity = zero \u002B onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);\n\t\t\trigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);\n\t\t\trigidbody.drag = 0.5f * (rigidbody.mass / 5f);\n\t\t\trigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);\n\t\t\tFireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;\n\t\t\tif ((bool)fireBall)\n\t\t\t{\n\t\t\t\tfireBall.SetParent(baseEntity2);\n\t\t\t\tfireBall.Spawn();\n\t\t\t\tfireBall.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\t\tfireBall.GetComponent\u003CCollider\u003E().enabled = false;\n\t\t\t}\n\t\t\tbaseEntity2.SendMessage(\u0022SetLockingEnt\u0022, fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\n\t\t\tforeach (ServerGib item2 in list)\n\t\t\t{\n\t\t\t\tUnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);\n\t\t\t}\n\t\t}\n\t\tbase.OnKilled(info);\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapArm(BearTrap bearTrap, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Arm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Arm(RPCMessage rpc)\n\t{\n\t\tif (!Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapArm\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tArm();\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEngineStatsRefreshed(VehicleModuleEngine vehicleModuleEngine, Rust.Modular.EngineStorage engineStorage)",
    "MethodSignature": "RefreshPerformanceStats(EngineStorage engineStorage)",
    "MethodSourseCode": "\n\tpublic void RefreshPerformanceStats(EngineStorage engineStorage)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineStatsRefresh\u0022, this, engineStorage) == null)\n\t\t{\n\t\t\tif (engineStorage == null)\n\t\t\t{\n\t\t\t\tIsUsable = false;\n\t\t\t\tPerformanceFractionAcceleration = 0f;\n\t\t\t\tPerformanceFractionTopSpeed = 0f;\n\t\t\t\tPerformanceFractionFuelEconomy = 0f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIsUsable = engineStorage.isUsable;\n\t\t\t\tPerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);\n\t\t\t\tPerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\n\t\t\t\tPerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\n\t\t\t}\n\t\t\tOverallPerformanceFraction = (PerformanceFractionAcceleration \u002B PerformanceFractionTopSpeed \u002B PerformanceFractionFuelEconomy) / 3f;\n\t\t\tInterface.CallHook(\u0022OnEngineStatsRefreshed\u0022, this, engineStorage);\n\t\t}\n\t}\n",
    "ClassName": "VehicleModuleEngine",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnLootNetworkUpdate(PlayerLoot playerLoot)",
    "MethodSignature": "SendUpdate()",
    "MethodSourseCode": "\n\tprivate void SendUpdate()\n\t{\n\t\tisInvokingSendUpdate = false;\n\t\tif (!base.baseEntity.IsValid() || Interface.CallHook(\u0022OnLootNetworkUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing PlayerUpdateLoot playerUpdateLoot = Pool.Get\u003CPlayerUpdateLoot\u003E();\n\t\tif ((bool)entitySource \u0026\u0026 entitySource.net != null)\n\t\t{\n\t\t\tplayerUpdateLoot.entityID = entitySource.net.ID;\n\t\t}\n\t\tif (itemSource != null)\n\t\t{\n\t\t\tplayerUpdateLoot.itemID = itemSource.uid;\n\t\t}\n\t\tif (containers.Count \u003E 0)\n\t\t{\n\t\t\tplayerUpdateLoot.containers = Pool.Get\u003CList\u003CProtoBuf.ItemContainer\u003E\u003E();\n\t\t\tforeach (ItemContainer container in containers)\n\t\t\t{\n\t\t\t\tplayerUpdateLoot.containers.Add(container.Save());\n\t\t\t}\n\t\t}\n\t\tbase.baseEntity.ClientRPCPlayer(null, base.baseEntity, \u0022UpdateLoot\u0022, playerUpdateLoot);\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnCounterModeToggle(PowerCounter powerCounter, BasePlayer msgPlayer, bool flag)",
    "MethodSignature": "ToggleDisplayMode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ToggleDisplayMode(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnCounterModeToggle\u0022, this, msg.player, flag) == null \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tSetFlag(Flags.Reserved2, flag, recursive: false, networkupdate: false);\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityDismounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tVector3 res;\n\t\tif (lite)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t}\n\t\telse if (!GetDismountPosition(player, out res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.ClientRPCPlayer(null, _mounted, \u0022ForcePositionTo\u0022, res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t\t_mounted.SendModelState(force: true);\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tif ((bool)player.GetParentEntity())\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionToParentOffset\u0022, baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, res);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnSolarPanelSunUpdate(SolarPanel solarPanel, int num)",
    "MethodSignature": "SunUpdate()",
    "MethodSourseCode": "\n\tpublic void SunUpdate()\n\t{\n\t\tint num = currentEnergy;\n\t\tif (TOD_Sky.Instance.IsNight)\n\t\t{\n\t\t\tnum = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVector3 sunDirection = TOD_Sky.Instance.SunDirection;\n\t\t\tfloat value = Vector3.Dot(sunSampler.transform.forward, sunDirection);\n\t\t\tfloat num2 = Mathf.InverseLerp(dot_minimum, dot_maximum, value);\n\t\t\tif (num2 \u003E 0f \u0026\u0026 !IsVisible(sunSampler.transform.position \u002B sunDirection * 100f, 101f))\n\t\t\t{\n\t\t\t\tnum2 = 0f;\n\t\t\t}\n\t\t\tnum = Mathf.FloorToInt((float)maximalPowerOutput * num2 * base.healthFraction);\n\t\t}\n\t\tbool num3 = currentEnergy != num;\n\t\tcurrentEnergy = num;\n\t\tif (num3 \u0026\u0026 Interface.CallHook(\u0022OnSolarPanelSunUpdate\u0022, this, num) == null)\n\t\t{\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "SolarPanel",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnClothingItemChanged(PlayerInventory playerInventory, Item item, bool bAdded)",
    "MethodSignature": "OnClothingChanged(Item item, bool bAdded)",
    "MethodSourseCode": "\n\tprivate void OnClothingChanged(Item item, bool bAdded)\n\t{\n\t\tbase.baseEntity.SV_ClothingChanged();\n\t\tItemManager.DoRemoves();\n\t\tServerUpdate(0f);\n\t\tInterface.CallHook(\u0022OnClothingItemChanged\u0022, this, item, bAdded);\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity baseCombatEntity, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void Hurt(HitInfo info)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022This should be called serverside only\u0022);\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Hurt( HitInfo )\u0022, 50))\n\t\t{\n\t\t\tfloat num = health;\n\t\t\tScaleDamage(info);\n\t\t\tif (info.PointStart != Vector3.zero)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C propDirection.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (!(propDirection[i].extraProtection == null) \u0026\u0026 !propDirection[i].IsWeakspot(base.transform, info))\n\t\t\t\t\t{\n\t\t\t\t\t\tpropDirection[i].extraProtection.Scale(info.damageTypes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);\n\t\t\tinfo.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);\n\t\t\tif (!(this is BasePlayer))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022IOnBaseCombatEntityHurt\u0022, this, info) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDebugHurt(info);\n\t\t\thealth = num - info.damageTypes.Total();\n\t\t\tSendNetworkUpdate();\n\t\t\tif (ConVar.Global.developer \u003E 1)\n\t\t\t{\n\t\t\t\tDebug.Log(string.Concat(\u0022[Combat]\u0022.PadRight(10), base.gameObject.name, \u0022 hurt \u0022, info.damageTypes.GetMajorityDamageType(), \u0022/\u0022, info.damageTypes.Total(), \u0022 - \u0022, health.ToString(\u00220\u0022), \u0022 health left\u0022));\n\t\t\t}\n\t\t\tlastDamage = info.damageTypes.GetMajorityDamageType();\n\t\t\tlastAttacker = info.Initiator;\n\t\t\tif (lastAttacker != null)\n\t\t\t{\n\t\t\t\tBaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;\n\t\t\t\tif (baseCombatEntity != null)\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;\n\t\t\t\t\tbaseCombatEntity.lastDealtDamageTo = this;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;\n\t\t\tif (markAttackerHostile \u0026\u0026 baseCombatEntity2 != null \u0026\u0026 baseCombatEntity2 != this)\n\t\t\t{\n\t\t\t\tbaseCombatEntity2.MarkHostileFor();\n\t\t\t}\n\t\t\tif (lastDamage.IsConsideredAnAttack())\n\t\t\t{\n\t\t\t\tlastAttackedTime = UnityEngine.Time.time;\n\t\t\t\tif (lastAttacker != null)\n\t\t\t\t{\n\t\t\t\t\tLastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = Health() \u003C= 0f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tDie(info);\n\t\t\t}\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer)\n\t\t\t{\n\t\t\t\tif (IsDead())\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.LogAttack(info, \u0022killed\u0022, num);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.combat.LogAttack(info, \u0022\u0022, num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnOvenCook(BaseOven baseOven, Item item)",
    "MethodSignature": "Cook()",
    "MethodSourseCode": "\n\tpublic void Cook()\n\t{\n\t\tItem item = FindBurnable();\n\t\tif (Interface.CallHook(\u0022OnOvenCook\u0022, this, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (item == null \u0026\u0026 !CanRunWithNoFuel)\n\t\t{\n\t\t\tStopCooking();\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in base.inventory.itemList)\n\t\t{\n\t\t\tif (item2.position \u003E= _inputSlotIndex \u0026\u0026 item2.position \u003C _inputSlotIndex \u002B inputSlots \u0026\u0026 !item2.HasFlag(Item.Flag.Cooking))\n\t\t\t{\n\t\t\t\titem2.SetFlag(Item.Flag.Cooking, b: true);\n\t\t\t\titem2.MarkDirty();\n\t\t\t}\n\t\t}\n\t\tIncreaseCookTime(0.5f * GetSmeltingSpeed());\n\t\tBaseEntity slot = GetSlot(Slot.FireMod);\n\t\tif ((bool)slot)\n\t\t{\n\t\t\tslot.SendMessage(\u0022Cook\u0022, 0.5f, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\tItemModBurnable component = item.info.GetComponent\u003CItemModBurnable\u003E();\n\t\t\titem.fuel -= 0.5f * (cookingTemperature / 200f);\n\t\t\tif (!item.HasFlag(Item.Flag.OnFire))\n\t\t\t{\n\t\t\t\titem.SetFlag(Item.Flag.OnFire, b: true);\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\tif (item.fuel \u003C= 0f)\n\t\t\t{\n\t\t\t\tConsumeFuel(item, component);\n\t\t\t}\n\t\t}\n\t\tOnCooked();\n\t\tInterface.CallHook(\u0022OnOvenCooked\u0022, this, item, slot);\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnRocketLaunched(BasePlayer player, BaseEntity baseEntity)",
    "MethodSignature": "SV_Launch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void SV_Launch(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (primaryMagazine.contents \u003C= 0)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022magazine_empty\u0022);\n\t\t\treturn;\n\t\t}\n\t\tprimaryMagazine.contents--;\n\t\tSignalBroadcast(Signal.Attack, string.Empty, player.net.connection);\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 vector2 = msg.read.Vector3().normalized;\n\t\tbool num = msg.read.Bit();\n\t\tBaseEntity mounted = player.GetParentEntity();\n\t\tif (mounted == null)\n\t\t{\n\t\t\tmounted = player.GetMounted();\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\tif (mounted != null)\n\t\t\t{\n\t\t\t\tvector = mounted.transform.TransformPoint(vector);\n\t\t\t\tvector2 = mounted.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector = player.eyes.position;\n\t\t\t\tvector2 = player.eyes.BodyForward();\n\t\t\t}\n\t\t}\n\t\tif (!ValidateEyePos(player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = primaryMagazine.ammoType.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = GetAimCone() \u002B component.projectileSpread;\n\t\tif (num2 \u003E 0f)\n\t\t{\n\t\t\tvector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);\n\t\t}\n\t\tfloat num3 = 1f;\n\t\tif (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1236478737))\n\t\t{\n\t\t\tnum3 = hitInfo.distance - 0.1f;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector \u002B vector2 * num3);\n\t\tif (!(baseEntity == null))\n\t\t{\n\t\t\tbaseEntity.creatorEntity = player;\n\t\t\tServerProjectile component2 = baseEntity.GetComponent\u003CServerProjectile\u003E();\n\t\t\tif ((bool)component2)\n\t\t\t{\n\t\t\t\tcomponent2.InitializeVelocity(GetInheritedVelocity(player, vector2) \u002B vector2 * component2.speed);\n\t\t\t}\n\t\t\tbaseEntity.Spawn();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);\n\t\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay));\n\t\t\tInterface.CallHook(\u0022OnRocketLaunched\u0022, player, baseEntity);\n\t\t\tGetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));\n\t\t}\n\t}\n",
    "ClassName": "BaseLauncher",
    "HookLineInvoke": 81
  },
  {
    "HookSignature": "OnRfListenerRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tlistenList.Remove(obj);\n\t\t\t}\n\t\t\tobj.RFSignalUpdate(on: false);\n\t\t\tInterface.CallHook(\u0022OnRfListenerRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityGroundMissing(BaseEntity baseEntity)",
    "MethodSignature": "OnGroundMissing()",
    "MethodSourseCode": "\tprivate void OnGroundMissing()\n\t{\n\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);\n\t\tif (baseEntity != null \u0026\u0026 Interface.CallHook(\u0022OnEntityGroundMissing\u0022, baseEntity) == null)\n\t\t{\n\t\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\n\t\t\tif (baseCombatEntity != null)\n\t\t\t{\n\t\t\t\tbaseCombatEntity.Die();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.Kill(BaseNetworkable.DestroyMode.Gib);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DestroyOnGroundMissing",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnQueueCycle(int availableSlots)",
    "MethodSignature": "Cycle(int availableSlots)",
    "MethodSourseCode": "\n\tpublic void Cycle(int availableSlots)\n\t{\n\t\tif (Interface.CallHook(\u0022OnQueueCycle\u0022, availableSlots) == null \u0026\u0026 queue.Count != 0)\n\t\t{\n\t\t\tif (availableSlots - Joining \u003E 0)\n\t\t\t{\n\t\t\t\tJoinGame(queue[0]);\n\t\t\t}\n\t\t\tSendMessages();\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ResourceContainer resourceContainer)",
    "MethodSignature": "StartLootingContainer(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server]\n\t[BaseEntity.RPC_Server.IsVisible(3f)]\n\tprivate void StartLootingContainer(BaseEntity.RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 lootable \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(base.baseEntity))\n\t\t{\n\t\t\tlastAccessTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tplayer.inventory.loot.AddContainer(container);\n\t\t}\n\t}\n",
    "ClassName": "ResourceContainer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTeamUpdate(ulong currentTeam, ulong newTeam, BasePlayer basePlayer)",
    "MethodSignature": "UpdateTeam(ulong newTeam)",
    "MethodSourseCode": "\n\tpublic void UpdateTeam(ulong newTeam)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTeamUpdate\u0022, currentTeam, newTeam, this) == null)\n\t\t{\n\t\t\tcurrentTeam = newTeam;\n\t\t\tSendNetworkUpdate();\n\t\t\tif (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)\n\t\t\t{\n\t\t\t\tClearTeam();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTeamUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] array)",
    "MethodSignature": "TakePhoto(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tprivate void TakePhoto(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tItem item = GetItem();\n\t\tif (player == null || item == null || item.condition \u003C= 0f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array.Length \u003E 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem item2 = ItemManager.Create(photoItem, 1, 0uL);\n\t\tif (item2 == null)\n\t\t{\n\t\t\tDebug.LogError(\u0022Failed to create photo item\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!item2.instanceData.subEntity.IsValid)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Photo has no sub-entity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);\n\t\tif (baseNetworkable == null)\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity was not found\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!(baseNetworkable is PhotoEntity photoEntity))\n\t\t{\n\t\t\titem2.Remove();\n\t\t\tDebug.LogError(\u0022Sub-entity is not a photo\u0022);\n\t\t\treturn;\n\t\t}\n\t\tphotoEntity.SetImageData(player.userID, array);\n\t\tif (Interface.CallHook(\u0022OnPhotoCapture\u0022, photoEntity, item, player, array) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!player.inventory.GiveItem(item2))\n\t\t{\n\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity());\n\t\t}\n\t\tEffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));\n\t\tif (!hasSentAchievement \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_PAPARAZZI\u0022))\n\t\t{\n\t\t\tVector3 position = GetOwnerPlayer().eyes.position;\n\t\t\tVector3 vector = GetOwnerPlayer().eyes.HeadForward();\n\t\t\tList\u003CBasePlayer\u003E obj = Facepunch.Pool.GetList\u003CBasePlayer\u003E();\n\t\t\tVis.Entities(position \u002B vector * 5f, 5f, obj, 131072);\n\t\t\tforeach (BasePlayer item3 in obj)\n\t\t\t{\n\t\t\t\tif (item3.isServer \u0026\u0026 item3 != GetOwnerPlayer() \u0026\u0026 item3.IsVisible(GetOwnerPlayer().eyes.position))\n\t\t\t\t{\n\t\t\t\t\thasSentAchievement = true;\n\t\t\t\t\tGetOwnerPlayer().GiveAchievement(\u0022SUMMER_PAPARAZZI\u0022);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t}\n\t\titem.LoseCondition(1f);\n\t\tInterface.CallHook(\u0022OnPhotoCaptured\u0022, photoEntity, item, player, array);\n\t}\n",
    "ClassName": "InstantCameraTool",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "OnCorpsePopulate(FrankensteinPet frankensteinPet, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(\u0022assets/rust.ai/agents/NPCPlayer/pet/frankensteinpet_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = OverrideCorpseName();\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\tif (obj is BaseCorpse)\n\t\t\t{\n\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "FrankensteinPet",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "OnProjectileAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void OnProjectileAttack(RPCMessage msg)\n\t{\n\t\tPlayerProjectileAttack playerProjectileAttack = PlayerProjectileAttack.Deserialize(msg.read);\n\t\tif (playerProjectileAttack == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerAttack playerAttack = playerProjectileAttack.playerAttack;\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\thitInfo.Initiator = this;\n\t\thitInfo.ProjectileID = playerAttack.projectileID;\n\t\thitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;\n\t\thitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;\n\t\thitInfo.Predicted = msg.connection;\n\t\tif (hitInfo.IsNaNOrInfinity() || float.IsNaN(playerProjectileAttack.travelTime) || float.IsInfinity(playerProjectileAttack.travelTime))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_nan\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_invalid\u0022);\n\t\t\treturn;\n\t\t}\n\t\thitInfo.ProjectileHits = value.hits;\n\t\thitInfo.ProjectileIntegrity = value.integrity;\n\t\thitInfo.ProjectileTravelTime = value.travelTime;\n\t\thitInfo.ProjectileTrajectoryMismatch = value.trajectoryMismatch;\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Integrity is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_integrity\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_lifetime\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (value.ricochets \u003E 0)\n\t\t{\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile is ricochet (\u0022 \u002B playerAttack.projectileID \u002B \u0022)\u0022);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_ricochet\u0022);\n\t\t\treturn;\n\t\t}\n\t\thitInfo.Weapon = value.weaponSource;\n\t\thitInfo.WeaponPrefab = value.weaponPrefab;\n\t\thitInfo.ProjectilePrefab = value.projectilePrefab;\n\t\thitInfo.damageProperties = value.projectilePrefab.damageProperties;\n\t\tVector3 position = value.position;\n\t\tVector3 velocity = value.velocity;\n\t\tfloat partialTime = value.partialTime;\n\t\tfloat travelTime = value.travelTime;\n\t\tfloat num = Mathf.Clamp(playerProjectileAttack.travelTime, value.travelTime, 8f);\n\t\tVector3 gravity = UnityEngine.Physics.gravity * value.projectilePrefab.gravityModifier;\n\t\tfloat drag = value.projectilePrefab.drag;\n\t\tint layerMask = (ConVar.AntiHack.projectile_terraincheck ? 10551296 : 2162688);\n\t\tBaseEntity hitEntity = hitInfo.HitEntity;\n\t\tBasePlayer basePlayer = hitEntity as BasePlayer;\n\t\tbool flag = basePlayer != null;\n\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\tbool flag5 = flag \u0026\u0026 basePlayer.HasParent();\n\t\tbool flag6 = hitEntity != null;\n\t\tbool flag7 = flag6 \u0026\u0026 hitEntity.IsNpc;\n\t\tbool flag8 = hitInfo.HitMaterial == Projectile.WaterMaterialID();\n\t\tbool flag9;\n\t\tVector3 position2;\n\t\tVector3 pointStart;\n\t\tVector3 hitPositionWorld;\n\t\tVector3 vector2;\n\t\tint num27;\n\t\tif (value.protection \u003E 0)\n\t\t{\n\t\t\tflag9 = true;\n\t\t\tfloat num2 = 1f \u002B ConVar.AntiHack.projectile_forgiveness;\n\t\t\tfloat num3 = 1f - ConVar.AntiHack.projectile_forgiveness;\n\t\t\tfloat projectile_clientframes = ConVar.AntiHack.projectile_clientframes;\n\t\t\tfloat projectile_serverframes = ConVar.AntiHack.projectile_serverframes;\n\t\t\tfloat num4 = Mathx.Decrement(value.firedTime);\n\t\t\tfloat num5 = Mathf.Clamp(Mathx.Increment(UnityEngine.Time.realtimeSinceStartup) - num4, 0f, 8f);\n\t\t\tfloat num6 = num;\n\t\t\tfloat num7 = (value.desyncLifeTime = Mathf.Abs(num5 - num6));\n\t\t\tfloat num8 = Mathf.Min(num5, num6);\n\t\t\tfloat num9 = projectile_clientframes / 60f;\n\t\t\tfloat num10 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\tfloat num11 = (desyncTimeClamped \u002B num8 \u002B num9 \u002B num10) * num2;\n\t\t\tfloat num12 = ((value.protection \u003E= 6) ? ((desyncTimeClamped \u002B num9 \u002B num10) * num2) : num11);\n\t\t\tfloat num13 = (num5 - desyncTimeClamped - num9 - num10) * num3;\n\t\t\tfloat num14 = Vector3.Distance(value.initialPosition, hitInfo.HitPositionWorld);\n\t\t\tif (flag \u0026\u0026 hitInfo.boneArea == (HitArea)(-1))\n\t\t\t{\n\t\t\t\tstring text = hitInfo.ProjectilePrefab.name;\n\t\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Bone is invalid (\u0022 \u002B text \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 bone \u0022 \u002B hitInfo.HitBone \u002B \u0022)\u0022);\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_bone\u0022);\n\t\t\t\tflag9 = false;\n\t\t\t}\n\t\t\tif (flag8)\n\t\t\t{\n\t\t\t\tif (flag6)\n\t\t\t\t{\n\t\t\t\t\tstring text3 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text4 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water hit on entity (\u0022 \u002B text3 \u002B \u0022 on \u0022 \u002B text4 \u002B \u0022)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022water_entity\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (!WaterLevel.Test(hitInfo.HitPositionWorld - 0.5f * Vector3.up, waves: false, this))\n\t\t\t\t{\n\t\t\t\t\tstring text5 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text6 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile water level (\u0022 \u002B text5 \u002B \u0022 on \u0022 \u002B text6 \u002B \u0022)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022water_level\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 2)\n\t\t\t{\n\t\t\t\tif (flag6)\n\t\t\t\t{\n\t\t\t\t\tfloat num15 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num16 = hitEntity.BoundsPadding() \u002B num12 * num15;\n\t\t\t\t\tfloat num17 = hitEntity.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\tif (num17 \u003E num16)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text7 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName = hitEntity.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Entity too far away (\u0022 \u002B text7 \u002B \u0022 on \u0022 \u002B shortPrefabName \u002B \u0022 with \u0022 \u002B num17 \u002B \u0022m \u003E \u0022 \u002B num16 \u002B \u0022m in \u0022 \u002B num12 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022entity_distance\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value.protection \u003E= 6 \u0026\u0026 flag9 \u0026\u0026 flag \u0026\u0026 !flag7 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4 \u0026\u0026 !flag5)\n\t\t\t\t{\n\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\tfloat num18 = basePlayer.BoundsPadding() \u002B num12 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\tfloat num19 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);\n\t\t\t\t\tif (num19 \u003E num18)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text8 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\t\tstring shortPrefabName2 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Player too far away (\u0022 \u002B text8 \u002B \u0022 on \u0022 \u002B shortPrefabName2 \u002B \u0022 with \u0022 \u002B num19 \u002B \u0022m \u003E \u0022 \u002B num18 \u002B \u0022m in \u0022 \u002B num12 \u002B \u0022s)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022player_distance\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 1)\n\t\t\t{\n\t\t\t\tfloat magnitude2 = value.initialVelocity.magnitude;\n\t\t\t\tfloat num20 = hitInfo.ProjectilePrefab.initialDistance \u002B num11 * magnitude2;\n\t\t\t\tfloat num21 = hitInfo.ProjectileDistance \u002B 1f;\n\t\t\t\tif (num14 \u003E num20)\n\t\t\t\t{\n\t\t\t\t\tstring text9 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text10 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too fast (\u0022 \u002B text9 \u002B \u0022 on \u0022 \u002B text10 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num20 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_maxspeed\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num14 \u003E num21)\n\t\t\t\t{\n\t\t\t\t\tstring text11 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text12 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too far away (\u0022 \u002B text11 \u002B \u0022 on \u0022 \u002B text12 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num21 \u002B \u0022m in \u0022 \u002B num11 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_distance\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num7 \u003E ConVar.AntiHack.projectile_desync)\n\t\t\t\t{\n\t\t\t\t\tstring text13 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text14 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile desync (\u0022 \u002B text13 \u002B \u0022 on \u0022 \u002B text14 \u002B \u0022 with \u0022 \u002B num7 \u002B \u0022s \u003E \u0022 \u002B ConVar.AntiHack.projectile_desync \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_desync\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 4)\n\t\t\t{\n\t\t\t\tSimulateProjectile(ref position, ref velocity, ref partialTime, num - travelTime, gravity, drag, out var prevPosition, out var prevVelocity);\n\t\t\t\tVector3 vector = prevVelocity * (1f / 32f);\n\t\t\t\tLine line = new Line(prevPosition - vector, position \u002B vector);\n\t\t\t\tfloat num22 = line.Distance(hitInfo.PointStart);\n\t\t\t\tfloat num23 = line.Distance(hitInfo.HitPositionWorld);\n\t\t\t\tif (num22 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text15 = value.projectilePrefab.name;\n\t\t\t\t\tstring text16 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Start position trajectory (\u0022 \u002B text15 \u002B \u0022 on \u0022 \u002B text16 \u002B \u0022 with \u0022 \u002B num22 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022trajectory_start\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\tif (num23 \u003E ConVar.AntiHack.projectile_trajectory)\n\t\t\t\t{\n\t\t\t\t\tstring text17 = value.projectilePrefab.name;\n\t\t\t\t\tstring text18 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022End position trajectory (\u0022 \u002B text17 \u002B \u0022 on \u0022 \u002B text18 \u002B \u0022 with \u0022 \u002B num23 \u002B \u0022m \u003E \u0022 \u002B ConVar.AntiHack.projectile_trajectory \u002B \u0022m)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022trajectory_end\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t\thitInfo.ProjectileVelocity = velocity;\n\t\t\t\tif (playerProjectileAttack.hitVelocity != Vector3.zero \u0026\u0026 velocity != Vector3.zero)\n\t\t\t\t{\n\t\t\t\t\tfloat num24 = Vector3.Angle(playerProjectileAttack.hitVelocity, velocity);\n\t\t\t\t\tfloat num25 = playerProjectileAttack.hitVelocity.magnitude / velocity.magnitude;\n\t\t\t\t\tif (num24 \u003E ConVar.AntiHack.projectile_anglechange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text19 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text20 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory angle change (\u0022 \u002B text19 \u002B \u0022 on \u0022 \u002B text20 \u002B \u0022 with \u0022 \u002B num24 \u002B \u0022deg \u003E \u0022 \u002B ConVar.AntiHack.projectile_anglechange \u002B \u0022deg)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022angle_change\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (num25 \u003E ConVar.AntiHack.projectile_velocitychange)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring text21 = value.projectilePrefab.name;\n\t\t\t\t\t\tstring text22 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Trajectory velocity change (\u0022 \u002B text21 \u002B \u0022 on \u0022 \u002B text22 \u002B \u0022 with \u0022 \u002B num25 \u002B \u0022 \u003E \u0022 \u002B ConVar.AntiHack.projectile_velocitychange \u002B \u0022)\u0022);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022velocity_change\u0022);\n\t\t\t\t\t\tflag9 = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfloat magnitude3 = velocity.magnitude;\n\t\t\t\tfloat num26 = num13 * magnitude3;\n\t\t\t\tif (num14 \u003C num26)\n\t\t\t\t{\n\t\t\t\t\tstring text23 = hitInfo.ProjectilePrefab.name;\n\t\t\t\t\tstring text24 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Projectile too slow (\u0022 \u002B text23 \u002B \u0022 on \u0022 \u002B text24 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003C \u0022 \u002B num26 \u002B \u0022m in \u0022 \u002B num13 \u002B \u0022s)\u0022);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_minspeed\u0022);\n\t\t\t\t\tflag9 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value.protection \u003E= 3)\n\t\t\t{\n\t\t\t\tposition2 = value.position;\n\t\t\t\tpointStart = hitInfo.PointStart;\n\t\t\t\thitPositionWorld = hitInfo.HitPositionWorld;\n\t\t\t\tif (!flag8)\n\t\t\t\t{\n\t\t\t\t\thitPositionWorld -= hitInfo.ProjectileVelocity.normalized * 0.001f;\n\t\t\t\t}\n\t\t\t\tvector2 = hitInfo.PositionOnRay(hitPositionWorld);\n\t\t\t\tif (GamePhysics.LineOfSight(position2, pointStart, layerMask, value.lastEntityHit) \u0026\u0026 GamePhysics.LineOfSight(pointStart, vector2, layerMask, value.lastEntityHit))\n\t\t\t\t{\n\t\t\t\t\tnum27 = (GamePhysics.LineOfSight(vector2, hitPositionWorld, layerMask, value.lastEntityHit) ? 1 : 0);\n\t\t\t\t\tif (num27 != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B (flag6 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\tgoto IL_0f88;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum27 = 0;\n\t\t\t\t}\n\t\t\t\tstats.Add(\u0022hit_\u0022 \u002B (flag6 ? hitEntity.Categorize() : \u0022world\u0022) \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\t\t\tgoto IL_0f88;\n\t\t\t}\n\t\t\tgoto IL_1199;\n\t\t}\n\t\tgoto IL_11b2;\n\t\tIL_11b2:\n\t\tvalue.position = hitInfo.HitPositionWorld;\n\t\tvalue.velocity = playerProjectileAttack.hitVelocity;\n\t\tvalue.travelTime = num;\n\t\tvalue.partialTime = partialTime;\n\t\tvalue.hits\u002B\u002B;\n\t\tvalue.lastEntityHit = hitEntity;\n\t\thitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);\n\t\tif (value.integrity \u003C 1f)\n\t\t{\n\t\t\tvalue.integrity = 0f;\n\t\t}\n\t\telse if (flag8)\n\t\t{\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - 0.1f);\n\t\t}\n\t\telse if (hitInfo.ProjectilePrefab.penetrationPower \u003C= 0f || !flag6)\n\t\t{\n\t\t\tvalue.integrity = 0f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat num28 = hitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;\n\t\t\tvalue.integrity = Mathf.Clamp01(value.integrity - num28);\n\t\t}\n\t\tif (flag6)\n\t\t{\n\t\t\tstats.Add(value.itemMod.category \u002B \u0022_hit_\u0022 \u002B hitEntity.Categorize(), 1);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, this, hitInfo) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (value.integrity \u003C= 0f)\n\t\t{\n\t\t\tif (value.hits \u003C= ConVar.AntiHack.projectile_impactspawndepth)\n\t\t\t{\n\t\t\t\tvalue.itemMod.ServerProjectileHit(hitInfo);\n\t\t\t}\n\t\t\tif (hitInfo.ProjectilePrefab.remainInWorld)\n\t\t\t{\n\t\t\t\tCreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);\n\t\t\t}\n\t\t}\n\t\tfiredProjectiles[playerAttack.projectileID] = value;\n\t\tif (flag6)\n\t\t{\n\t\t\tif (value.hits \u003C= ConVar.AntiHack.projectile_damagedepth)\n\t\t\t{\n\t\t\t\thitEntity.OnAttacked(hitInfo);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022ricochet\u0022);\n\t\t\t}\n\t\t}\n\t\thitInfo.DoHitEffects = hitInfo.ProjectilePrefab.doDefaultHitEffects;\n\t\tEffect.server.ImpactEffect(hitInfo);\n\t\tplayerProjectileAttack.ResetToPool();\n\t\tplayerProjectileAttack = null;\n\t\treturn;\n\t\tIL_1199:\n\t\tif (!flag9)\n\t\t{\n\t\t\tAntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);\n\t\t\tplayerProjectileAttack.ResetToPool();\n\t\t\tplayerProjectileAttack = null;\n\t\t\treturn;\n\t\t}\n\t\tgoto IL_11b2;\n\t\tIL_0f88:\n\t\tif (num27 == 0)\n\t\t{\n\t\t\tstring text25 = hitInfo.ProjectilePrefab.name;\n\t\t\tstring text26 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(\u0022Line of sight (\u0022, text25, \u0022 on \u0022, text26, \u0022) \u0022, position2, \u0022 \u0022, pointStart, \u0022 \u0022, vector2, \u0022 \u0022, hitPositionWorld));\n\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_los\u0022);\n\t\t\tflag9 = false;\n\t\t}\n\t\tif (flag9 \u0026\u0026 flag \u0026\u0026 !flag7)\n\t\t{\n\t\t\tVector3 hitPositionWorld2 = hitInfo.HitPositionWorld;\n\t\t\tVector3 position3 = basePlayer.eyes.position;\n\t\t\tVector3 vector3 = basePlayer.CenterPoint();\n\t\t\tfloat projectile_losforgiveness = ConVar.AntiHack.projectile_losforgiveness;\n\t\t\tbool flag10 = GamePhysics.LineOfSight(hitPositionWorld2, position3, layerMask, 0f, projectile_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(position3, hitPositionWorld2, layerMask, projectile_losforgiveness, 0f);\n\t\t\tif (!flag10)\n\t\t\t{\n\t\t\t\tflag10 = GamePhysics.LineOfSight(hitPositionWorld2, vector3, layerMask, 0f, projectile_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(vector3, hitPositionWorld2, layerMask, projectile_losforgiveness, 0f);\n\t\t\t}\n\t\t\tif (!flag10)\n\t\t\t{\n\t\t\t\tstring text27 = hitInfo.ProjectilePrefab.name;\n\t\t\t\tstring text28 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat(\u0022Line of sight (\u0022, text27, \u0022 on \u0022, text28, \u0022) \u0022, hitPositionWorld2, \u0022 \u0022, position3, \u0022 or \u0022, hitPositionWorld2, \u0022 \u0022, vector3));\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnProjectileHackViolation(value);\n\t\t\t\tstats.combat.LogInvalid(hitInfo, \u0022projectile_los\u0022);\n\t\t\t\tflag9 = false;\n\t\t\t}\n\t\t}\n\t\tgoto IL_1199;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 325
  },
  {
    "HookSignature": "OnMissionStarted(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionStart(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionStart(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMissionStart\u0022, this, instance, assignee) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetupRewards(instance, assignee);\n\t\tSetupPositions(instance, assignee);\n\t\tAddBlockers(instance);\n\t\tfor (int i = 0; i \u003C objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tobjectives[i].Get().MissionStarted(i, instance);\n\t\t}\n\t\tif (acceptEffect.isValid)\n\t\t{\n\t\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\n\t\t}\n\t\tMissionEntityEntry[] array = missionEntities;\n\t\tforeach (MissionEntityEntry missionEntityEntry in array)\n\t\t{\n\t\t\tif (missionEntityEntry.entityRef.isValid)\n\t\t\t{\n\t\t\t\tVector3 missionPoint = instance.GetMissionPoint(missionEntityEntry.spawnPositionToUse, assignee);\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);\n\t\t\t\tMissionEntity missionEntity = baseEntity.gameObject.AddComponent\u003CMissionEntity\u003E();\n\t\t\t\tmissionEntity.Setup(assignee, instance, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);\n\t\t\t\tinstance.createdEntities.Add(missionEntity);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t\tforeach (MissionEntity createdEntity in instance.createdEntities)\n\t\t{\n\t\t\tcreatedEntity.MissionStarted(assignee, instance);\n\t\t}\n\t\tInterface.CallHook(\u0022OnMissionStarted\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "OnCrateLanded(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "LandCheck()",
    "MethodSourseCode": "\n\tpublic void LandCheck()\n\t{\n\t\tRaycastHit hitInfo;\n\t\tif (hasLanded)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnCrateLanded\u0022, this);\n\t\t}\n\t\telse if (UnityEngine.Physics.Raycast(new Ray(base.transform.position \u002B Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))\n\t\t{\n\t\t\tEffect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);\n\t\t\thasLanded = true;\n\t\t\tCancelInvoke(LandCheck);\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPhoneNameUpdated(PhoneController phoneController, string PhoneName, BasePlayer msgPlayer)",
    "MethodSignature": "UpdatePhoneName(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void UpdatePhoneName(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (!(msg.player != currentPlayer))\n\t\t{\n\t\t\tstring text = msg.read.String();\n\t\t\tif (text.Length \u003E 20)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 20);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnPhoneNameUpdate\u0022, this, text, msg.player) == null)\n\t\t\t{\n\t\t\t\tPhoneName = text;\n\t\t\t\tbase.baseEntity.SendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneNameUpdated\u0022, this, PhoneName, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)",
    "MethodSignature": "CanFire(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate bool CanFire(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanFireLiquidWeapon\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (RequiresPumping \u0026\u0026 pressure \u003C PressureLossPerTick)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (HasFlag(Flags.Open))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (AmountHeld() \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!player.CanInteract())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!player.CanAttack() || player.IsRunning())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tItem item = GetItem();\n\t\tif (item == null || item.contents == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "LiquidWeapon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretDeauthorize(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022removed\u0022, rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanBypassQueue(Network.Connection connection)",
    "MethodSignature": "CanJumpQueue(Connection connection)",
    "MethodSourseCode": "\n\tprivate bool CanJumpQueue(Connection connection)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBypassQueue\u0022, connection);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Moderator)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.Owner)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (user != null \u0026\u0026 user.group == ServerUsers.UserGroup.SkipQueue)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCrateDropped(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "SetWasDropped()",
    "MethodSourseCode": "\n\tpublic void SetWasDropped()\n\t{\n\t\twasDropped = true;\n\t\tInterface.CallHook(\u0022OnCrateDropped\u0022, this);\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnVehicleModulesAssign(ModularCar modularCar, Rust.Modular.ItemModVehicleModule[] modularCarPresetConfigSocketItemDefs)",
    "MethodSignature": "SpawnPreassignedModules()",
    "MethodSourseCode": "\n\tpublic void SpawnPreassignedModules()\n\t{\n\t\tif (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];\n\t\tif (Interface.CallHook(\u0022OnVehicleModulesAssign\u0022, this, modularCarPresetConfig.socketItemDefs) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C modularCarPresetConfig.socketItemDefs.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];\n\t\t\tif (itemModVehicleModule != null \u0026\u0026 base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))\n\t\t\t{\n\t\t\t\titemModVehicleModule.doNonUserSpawn = true;\n\t\t\t\tItem item = ItemManager.Create(itemModVehicleModule.GetComponent\u003CItemDefinition\u003E(), 1, 0uL);\n\t\t\t\tfloat num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);\n\t\t\t\titem.condition = item.maxCondition * num;\n\t\t\t\tif (!TryAddModule(item))\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnVehicleModulesAssigned\u0022, this, modularCarPresetConfig.socketItemDefs);\n\t\tInvoke(HandleAdminBonus, 0f);\n\t}\n",
    "ClassName": "ModularCar",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnDoorOpened(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_OpenDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_OpenDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !canHandOpen || IsOpen() || IsBusy() || IsLocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (rpc.player.IsWounded())\n\t\t{\n\t\t\tif (!woundedOpens.ContainsKey(rpc.player) || !((float)woundedOpens[rpc.player] \u003E 2.5f))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twoundedOpens.Remove(rpc.player);\n\t\t}\n\t\tBaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;\n\t\tif (baseLock != null)\n\t\t{\n\t\t\tif (!baseLock.OnTryToOpen(rpc.player))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (baseLock.IsLocked() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast \u003E 60f)\n\t\t\t{\n\t\t\t\tBuildingBlock buildingBlock = FindLinkedEntity\u003CBuildingBlock\u003E();\n\t\t\t\tif ((bool)buildingBlock)\n\t\t\t\t{\n\t\t\t\t\tDecay.BuildingDecayTouch(buildingBlock);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDecay.RadialDecayTouch(base.transform.position, 40f, 2097408);\n\t\t\t\t}\n\t\t\t\tdecayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.Open, b: true);\n\t\tSendNetworkUpdateImmediate();\n\t\tif (isSecurityDoor \u0026\u0026 NavMeshLink != null)\n\t\t{\n\t\t\tSetNavMeshLinkEnabled(wantsOn: true);\n\t\t}\n\t\tif (checkPhysBoxesOnOpen)\n\t\t{\n\t\t\tStartCheckingForBlockages(isOpening: true);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDoorOpened\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 48
  },
  {
    "HookSignature": "OnHotAirBalloonToggled(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "IOnRconInitialize()",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic static void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022IOnRconInitialize\u0022) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (Port == 0)\n\t\t{\n\t\t\tPort = Server.port;\n\t\t}\n\t\tPassword = CommandLine.GetSwitch(\u0022-rcon.password\u0022, CommandLine.GetSwitch(\u0022\u002Brcon.password\u0022, \u0022\u0022));\n\t\tif (Password == \u0022password\u0022 || Password == \u0022\u0022)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tOutput.OnMessage \u002B= OnMessage;\n\t\tif (Web)\n\t\t{\n\t\t\tlistenerNew = new Listener();\n\t\t\tif (!string.IsNullOrEmpty(Ip))\n\t\t\t{\n\t\t\t\tlistenerNew.Address = Ip;\n\t\t\t}\n\t\t\tlistenerNew.Password = Password;\n\t\t\tlistenerNew.Port = Port;\n\t\t\tlistenerNew.SslCertificate = CommandLine.GetSwitch(\u0022-rcon.ssl\u0022, null);\n\t\t\tlistenerNew.SslCertificatePassword = CommandLine.GetSwitch(\u0022-rcon.sslpwd\u0022, null);\n\t\t\tlistenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)\n\t\t\t{\n\t\t\t\tlock (Commands)\n\t\t\t\t{\n\t\t\t\t\tCommand item = JsonConvert.DeserializeObject\u003CCommand\u003E(msg);\n\t\t\t\t\titem.Ip = ip;\n\t\t\t\t\titem.ConnectionId = id;\n\t\t\t\t\tCommands.Enqueue(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlistenerNew.Start();\n\t\t\tDebug.Log(\u0022WebSocket RCon Started on \u0022 \u002B Port);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlistener = new RConListener();\n\t\t\tDebug.Log(\u0022RCon Started on \u0022 \u002B Port);\n\t\t\tDebug.Log(\u0022Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityEnter(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tif (!(ent == null))\n\t\t{\n\t\t\tif (entityContents == null)\n\t\t\t{\n\t\t\t\tentityContents = new HashSet\u003CBaseEntity\u003E();\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t\t{\n\t\t\t\tentityContents.Add(ent);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)",
    "MethodSignature": "DoBuild(Construction.Target target, Construction component)",
    "MethodSourseCode": "\n\tpublic void DoBuild(Construction.Target target, Construction component)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (target.socket != null)\n\t\t{\n\t\t\tif (!target.socket.female)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is not female. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (target.entity != null \u0026\u0026 target.entity.IsOccupied(target.socket))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target socket is occupied. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (target.onTerrain)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Target on terrain is not allowed when attaching to socket. (\u0022 \u002B target.socket.socketName \u002B \u0022)\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tVector3 vector = ((target.entity != null \u0026\u0026 target.socket != null) ? target.GetWorldPosition() : target.position);\n\t\tif (AntiHack.TestIsBuildingInsideSomething(target, vector))\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t deploy inside objects\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.AntiHack.eye_protection \u003E= 2)\n\t\t{\n\t\t\tVector3 center = ownerPlayer.eyes.center;\n\t\t\tVector3 position = ownerPlayer.eyes.position;\n\t\t\tVector3 origin = target.ray.origin;\n\t\t\tVector3 p = vector;\n\t\t\tint num = 2097152;\n\t\t\tint num2 = (ConVar.AntiHack.build_terraincheck ? 10551296 : 2162688);\n\t\t\tfloat num3 = ConVar.AntiHack.build_losradius;\n\t\t\tfloat padding = ConVar.AntiHack.build_losradius \u002B 0.01f;\n\t\t\tint layerMask = num2;\n\t\t\tif (target.socket != null)\n\t\t\t{\n\t\t\t\tnum3 = 0f;\n\t\t\t\tpadding = 0.5f;\n\t\t\t\tlayerMask = num;\n\t\t\t}\n\t\t\tif (component.isSleepingBag)\n\t\t\t{\n\t\t\t\tnum3 = ConVar.AntiHack.build_losradius_sleepingbag;\n\t\t\t\tpadding = ConVar.AntiHack.build_losradius_sleepingbag \u002B 0.01f;\n\t\t\t\tlayerMask = num2;\n\t\t\t}\n\t\t\tif (num3 \u003E 0f)\n\t\t\t{\n\t\t\t\tp \u002B= target.normal.normalized * num3;\n\t\t\t}\n\t\t\tif (target.entity != null)\n\t\t\t{\n\t\t\t\tDeployShell deployShell = PrefabAttribute.server.Find\u003CDeployShell\u003E(target.entity.prefabID);\n\t\t\t\tif (deployShell != null)\n\t\t\t\t{\n\t\t\t\t\tp \u002B= target.normal.normalized * deployShell.LineOfSightPadding();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!GamePhysics.LineOfSightRadius(center, position, layerMask, num3) || !GamePhysics.LineOfSightRadius(position, origin, layerMask, num3) || !GamePhysics.LineOfSightRadius(origin, p, layerMask, num3, 0f, padding))\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Line of sight blocked.\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tConstruction.lastPlacementError = \u0022No Error\u0022;\n\t\tGameObject gameObject = DoPlacement(target, component);\n\t\tif (gameObject == null)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t place: \u0022 \u002B Construction.lastPlacementError);\n\t\t}\n\t\tif (!(gameObject != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnEntityBuilt\u0022, this, gameObject);\n\t\tDeployable deployable = GetDeployable();\n\t\tBaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);\n\t\tif (deployable != null)\n\t\t{\n\t\t\tif (deployable.setSocketParent \u0026\u0026 target.entity != null \u0026\u0026 target.entity.SupportsChildDeployables() \u0026\u0026 (bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.SetParent(target.entity, worldPositionStays: true);\n\t\t\t}\n\t\t\tif (deployable.wantsInstanceData \u0026\u0026 GetOwnerItem().instanceData != null)\n\t\t\t{\n\t\t\t\t(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);\n\t\t\t}\n\t\t\tif (deployable.copyInventoryFromItem)\n\t\t\t{\n\t\t\t\tStorageContainer component2 = baseEntity.GetComponent\u003CStorageContainer\u003E();\n\t\t\t\tif ((bool)component2)\n\t\t\t\t{\n\t\t\t\t\tcomponent2.ReceiveInventoryFromItem(GetOwnerItem());\n\t\t\t\t}\n\t\t\t}\n\t\t\tItemModDeployable modDeployable = GetModDeployable();\n\t\t\tif (modDeployable != null)\n\t\t\t{\n\t\t\t\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\n\t\t\t}\n\t\t\tbaseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());\n\t\t\tif (deployable.placeEffect.isValid)\n\t\t\t{\n\t\t\t\tif ((bool)target.entity \u0026\u0026 target.socket != null)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (baseEntity != null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\n\t\t}\n\t\tPayForPlacement(ownerPlayer, component);\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 83
  },
  {
    "HookSignature": "OnCardSwipe(CardReader cardReader, Keycard keycard, BasePlayer msgPlayer)",
    "MethodSignature": "ServerCardSwiped(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerCardSwiped(RPCMessage msg)\n\t{\n\t\tif (!IsPowered() || Vector3Ex.Distance2D(msg.player.transform.position, base.transform.position) \u003E 1f || IsInvoking(GrantCard) || IsInvoking(FailCard))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tKeycard keycard = BaseNetworkable.serverEntities.Find(uid) as Keycard;\n\t\tEffect.server.Run(swipeEffect.resourcePath, audioPosition.position, Vector3.up, msg.player.net.connection);\n\t\tif (keycard != null \u0026\u0026 Interface.CallHook(\u0022OnCardSwipe\u0022, this, keycard, msg.player) == null)\n\t\t{\n\t\t\tItem item = keycard.GetItem();\n\t\t\tif (item != null \u0026\u0026 keycard.accessLevel == accessLevel \u0026\u0026 item.conditionNormalized \u003E 0f)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnKeycardSwiped(msg.player, this);\n\t\t\t\tInvoke(GrantCard, 0.5f);\n\t\t\t\titem.LoseCondition(1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInvoke(FailCard, 0.5f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CardReader",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerKeepAlive(BasePlayer basePlayer, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_KeepAlive(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_KeepAlive(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 !(msg.player == this) \u0026\u0026 IsWounded() \u0026\u0026 Interface.CallHook(\u0022OnPlayerKeepAlive\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tProlongWounding(10f);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerCanUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerCanUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNode\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerHasPathForUnlock(player, node))\n\t\t{\n\t\t\treturn !HasPlayerUnlocked(player, node);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretShutdown(AutoTurret autoTurret)",
    "MethodSignature": "InitiateShutdown()",
    "MethodSourseCode": "\n\tpublic void InitiateShutdown()\n\t{\n\t\tif ((!IsOffline() || booting) \u0026\u0026 Interface.CallHook(\u0022OnTurretShutdown\u0022, this) == null)\n\t\t{\n\t\t\tCancelInvoke(SetOnline);\n\t\t\tbooting = false;\n\t\t\tEffect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tSetIsOnline(online: false);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "leaveteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void leaveteam(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam != 0L)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\t\tif (playerTeam != null \u0026\u0026 Interface.CallHook(\u0022OnTeamLeave\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(basePlayer.userID);\n\t\t\t\tbasePlayer.ClearTeam();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanBeTargeted(BasePlayer component, FlameTurret flameTurret)",
    "MethodSignature": "CheckTrigger()",
    "MethodSourseCode": "\n\tpublic bool CheckTrigger()\n\t{\n\t\tif (Time.realtimeSinceStartup \u003C nextTriggerCheckTime)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tnextTriggerCheckTime = Time.realtimeSinceStartup \u002B 1f / triggerCheckRate;\n\t\tList\u003CRaycastHit\u003E obj = Pool.GetList\u003CRaycastHit\u003E();\n\t\tHashSet\u003CBaseEntity\u003E entityContents = trigger.entityContents;\n\t\tbool flag = false;\n\t\tif (entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity item in entityContents)\n\t\t\t{\n\t\t\t\tBasePlayer component = item.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (component.IsSleeping() || !component.IsAlive())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, component, this);\n\t\t\t\tif (obj2 is bool)\n\t\t\t\t{\n\t\t\t\t\tPool.FreeList(ref obj);\n\t\t\t\t\treturn (bool)obj2;\n\t\t\t\t}\n\t\t\t\tif (!(component.transform.position.y \u003C= GetEyePosition().y \u002B 0.5f) || component.IsBuildingAuthed())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tobj.Clear();\n\t\t\t\tGamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj[i]);\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == this || entity.EqualNetID(this)))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t\treturn flag;\n\t}\n",
    "ClassName": "FlameTurret",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, ContainerIOEntity containerIOEntity)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (needsBuildingPrivilegeToUse \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (onlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Already in use\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = lootPanelName;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ContainerIOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardDeauthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "RemoveSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RemoveSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tRPCMessage rpc2 = rpc;\n\t\tif (rpc2.player.CanInteract() \u0026\u0026 CanAdministrate(rpc2.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardDeauthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == rpc2.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022removed\u0022, rpc2.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanMountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTransform transform = mountAnchor.transform;\n\t\t\tplayer.MountObject(this);\n\t\t\tplayer.MovePosition(transform.position);\n\t\t\tplayer.transform.rotation = transform.rotation;\n\t\t\tplayer.ServerRotation = transform.rotation;\n\t\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, player.transform.position);\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum iGrade, ulong iSkin)",
    "MethodSignature": "CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanChangeGrade\u0022, player, this, iGrade, iSkin);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (HasUpgradePrivilege(iGrade, iSkin, player))\n\t\t{\n\t\t\treturn !IsUpgradeBlocked();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanCheckFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, BasePlayer player)",
    "MethodSignature": "IsInFuelInteractionRange(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool IsInFuelInteractionRange(BasePlayer player)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanCheckFuel\u0022, this, fuelContainer, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (fuelContainer != null)\n\t\t{\n\t\t\tfloat num = 0f;\n\t\t\tif (isServer)\n\t\t\t{\n\t\t\t\tnum = 3f;\n\t\t\t}\n\t\t\treturn fuelContainer.Distance(player.eyes.position) \u003C= num;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerRecover(BasePlayer basePlayer)",
    "MethodSignature": "RecoverFromWounded()",
    "MethodSourseCode": "\n\tpublic void RecoverFromWounded()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerRecover\u0022, this) == null)\n\t\t{\n\t\t\tif (IsCrawling())\n\t\t\t{\n\t\t\t\tbase.health = UnityEngine.Random.Range(2f, 6f) \u002B healingWhileCrawling;\n\t\t\t}\n\t\t\thealingWhileCrawling = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerRecovered\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)",
    "MethodSignature": "CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData, int amount, int skinID, Item fromTempBlueprint, bool free)",
    "MethodSourseCode": "\n\tpublic bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)\n\t{\n\t\tif (!CanCraft(bp, amount, free))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\ttaskUID\u002B\u002B;\n\t\tItemCraftTask itemCraftTask = Facepunch.Pool.Get\u003CItemCraftTask\u003E();\n\t\titemCraftTask.blueprint = bp;\n\t\tif (!free)\n\t\t{\n\t\t\tCollectIngredients(bp, itemCraftTask, amount, owner);\n\t\t}\n\t\titemCraftTask.endTime = 0f;\n\t\titemCraftTask.taskUID = taskUID;\n\t\titemCraftTask.owner = owner;\n\t\titemCraftTask.instanceData = instanceData;\n\t\tif (itemCraftTask.instanceData != null)\n\t\t{\n\t\t\titemCraftTask.instanceData.ShouldPool = false;\n\t\t}\n\t\titemCraftTask.amount = amount;\n\t\titemCraftTask.skinID = skinID;\n\t\tif (fromTempBlueprint != null \u0026\u0026 itemCraftTask.takenItems != null)\n\t\t{\n\t\t\tfromTempBlueprint.RemoveFromContainer();\n\t\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\n\t\t\titemCraftTask.conditionScale = 0.5f;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemCraft\u0022, itemCraftTask, owner, fromTempBlueprint);\n\t\tif (obj is bool)\n\t\t{\n\t\t\tif (fromTempBlueprint != null \u0026\u0026 itemCraftTask.instanceData != null)\n\t\t\t{\n\t\t\t\tfromTempBlueprint.instanceData = itemCraftTask.instanceData;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tqueue.AddLast(itemCraftTask);\n\t\tif (itemCraftTask.owner != null)\n\t\t{\n\t\t\titemCraftTask.owner.Command(\u0022note.craft_add\u0022, itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnTakeCurrencyItem(NPCVendingMachine nPCVendingMachine, Item takenCurrencyItem)",
    "MethodSignature": "TakeCurrencyItem(Item takenCurrencyItem)",
    "MethodSourseCode": "\n\tpublic override void TakeCurrencyItem(Item takenCurrencyItem)\n\t{\n\t\tif (Interface.CallHook(\u0022OnTakeCurrencyItem\u0022, this, takenCurrencyItem) == null)\n\t\t{\n\t\t\ttakenCurrencyItem.MoveToContainer(base.inventory);\n\t\t\ttakenCurrencyItem.RemoveFromContainer();\n\t\t\ttakenCurrencyItem.Remove();\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMapImageUpdated()",
    "MethodSignature": "ImageUpdate(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\t[RPC_Server.FromOwner]\n\tpublic void ImageUpdate(RPCMessage msg)\n\t{\n\t\tif (msg.player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte b = msg.read.UInt8();\n\t\tbyte b2 = msg.read.UInt8();\n\t\tuint num = msg.read.UInt32();\n\t\tif ((b == 0 \u0026\u0026 fogImages[b2] == num) || (b == 1 \u0026\u0026 paintImages[b2] == num))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tuint num2 = (uint)(b * 1000 \u002B b2);\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array != null)\n\t\t{\n\t\t\tFileStorage.server.RemoveEntityNum(net.ID, num2);\n\t\t\tuint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);\n\t\t\tif (b == 0)\n\t\t\t{\n\t\t\t\tfogImages[b2] = num3;\n\t\t\t}\n\t\t\tif (b == 1)\n\t\t\t{\n\t\t\t\tpaintImages[b2] = num3;\n\t\t\t}\n\t\t\tInvalidateNetworkCache();\n\t\t\tInterface.CallHook(\u0022OnMapImageUpdated\u0022);\n\t\t}\n\t}\n",
    "ClassName": "MapEntity",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnServerUserSet(ulong uid, ServerUsers.UserGroup group, string username, string notes, long expiry)",
    "MethodSignature": "Set(ulong uid, UserGroup group, string username, string notes, long expiry)",
    "MethodSourseCode": "\n\tpublic static void Set(ulong uid, UserGroup group, string username, string notes, long expiry = -1L)\n\t{\n\t\tRemove(uid);\n\t\tUser value = new User\n\t\t{\n\t\t\tsteamid = uid,\n\t\t\tgroup = group,\n\t\t\tusername = username,\n\t\t\tnotes = notes,\n\t\t\texpiry = expiry\n\t\t};\n\t\tInterface.CallHook(\u0022OnServerUserSet\u0022, uid, group, username, notes, expiry);\n\t\tusers.Add(uid, value);\n\t}\n",
    "ClassName": "ServerUsers",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnItemAddedToContainer(ItemContainer itemContainer, Item item)",
    "MethodSignature": "Insert(Item item)",
    "MethodSourseCode": "\n\tpublic bool Insert(Item item)\n\t{\n\t\tif (itemList.Contains(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsFull())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\titemList.Add(item);\n\t\titem.parent = this;\n\t\tif (!FindPosition(item))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tMarkDirty();\n\t\tif (onItemAddedRemoved != null)\n\t\t{\n\t\t\tonItemAddedRemoved(item, arg2: true);\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemAddedToContainer\u0022, this, item);\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemContainer",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnTrainCarUncouple(TrainCar trainCar, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_WantsUncouple(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsUncouple(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 !(Vector3.SqrMagnitude(base.transform.position - player.transform.position) \u003E 200f) \u0026\u0026 Interface.CallHook(\u0022OnTrainCarUncouple\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool front = msg.read.Bit();\n\t\t\tcoupling.Uncouple(front);\n\t\t}\n\t}\n",
    "ClassName": "TrainCar",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnInventoryAmmoItemFind(PlayerInventory ownerPlayerInventory, ItemDefinition fuelType)",
    "MethodSignature": "GetAmmo()",
    "MethodSourseCode": "\n\tpublic Item GetAmmo()\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnInventoryAmmoItemFind\u0022, ownerPlayer.inventory, fuelType);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tItem item = ownerPlayer.inventory.containerMain.FindItemsByItemName(fuelType.shortname);\n\t\tif (item == null)\n\t\t{\n\t\t\titem = ownerPlayer.inventory.containerBelt.FindItemsByItemName(fuelType.shortname);\n\t\t}\n\t\treturn item;\n\t}\n",
    "ClassName": "Chainsaw",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnItemPainted(PaintedItemStorageEntity paintedItemStorageEntity, Item item, BasePlayer msgPlayer, byte[] array)",
    "MethodSignature": "Server_UpdateImage(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(3uL)]\n\tprivate void Server_UpdateImage(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || msg.player.userID != base.OwnerID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item2 in msg.player.inventory.containerWear.itemList)\n\t\t{\n\t\t\tif (item2.instanceData != null \u0026\u0026 item2.instanceData.subEntity == net.ID)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItem item = msg.player.inventory.FindBySubEntityID(net.ID);\n\t\tif (item == null || item.isBroken)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (_currentImageCrc != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\n\t\t\t}\n\t\t\t_currentImageCrc = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 512, 512))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuint currentImageCrc = _currentImageCrc;\n\t\t\tif (_currentImageCrc != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(_currentImageCrc, FileStorage.Type.png, net.ID, 0u);\n\t\t\t}\n\t\t\t_currentImageCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);\n\t\t\tif (_currentImageCrc != currentImageCrc)\n\t\t\t{\n\t\t\t\titem.LoseCondition(0.25f);\n\t\t\t}\n\t\t\tlastEditedBy = msg.player.userID;\n\t\t}\n\t\tInterface.CallHook(\u0022OnItemPainted\u0022, this, item, msg.player, array);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "PaintedItemStorageEntity",
    "HookLineInvoke": 48
  },
  {
    "HookSignature": "CanDesignFirework(BasePlayer player, PatternFirework patternFirework)",
    "MethodSignature": "PlayerCanModify(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate bool PlayerCanModify(BasePlayer player)\n\t{\n\t\tif (player == null || !player.CanInteract())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanDesignFirework\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tBuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();\n\t\tif (buildingPrivilege != null \u0026\u0026 !buildingPrivilege.CanAdministrate(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnOvenStart(BaseOven baseOven)",
    "MethodSignature": "StartCooking()",
    "MethodSourseCode": "\n\tpublic virtual void StartCooking()\n\t{\n\t\tif (Interface.CallHook(\u0022OnOvenStart\u0022, this) == null \u0026\u0026 (FindBurnable() != null || CanRunWithNoFuel))\n\t\t{\n\t\t\tbase.inventory.temperature = cookingTemperature;\n\t\t\tUpdateAttachmentTemperature();\n\t\t\tInvokeRepeating(Cook, 0.5f, 0.5f);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tInterface.CallHook(\u0022OnOvenStarted\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanDemolish(BasePlayer player, BuildingBlock buildingBlock)",
    "MethodSignature": "CanDemolish(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanDemolish(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanDemolish\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (IsDemolishable())\n\t\t{\n\t\t\treturn HasDemolishPrivilege(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAdventGiftAward(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "AwardGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AwardGift(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnAdventGiftAward\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tint num = now.Day - startDay;\n\t\tif (now.Month == startMonth \u0026\u0026 num \u003E= 0 \u0026\u0026 num \u003C days.Length)\n\t\t{\n\t\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t\t{\n\t\t\t\tplayerRewardHistory.Add(player.userID, new List\u003Cint\u003E());\n\t\t\t}\n\t\t\tplayerRewardHistory[player.userID].Add(num);\n\t\t\tEffect.server.Run(giftEffect.resourcePath, player.transform.position);\n\t\t\tif (num \u003E= 0 \u0026\u0026 num \u003C crosses.Length)\n\t\t\t{\n\t\t\t\tEffect.server.Run(boxCloseEffect.resourcePath, base.transform.position \u002B Vector3.up * 1.5f);\n\t\t\t}\n\t\t\tDayReward dayReward = days[num];\n\t\t\tfor (int i = 0; i \u003C dayReward.rewards.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItemAmount itemAmount = dayReward.rewards[i];\n\t\t\t\tplayer.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnAdventGiftAwarded\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcConversationEnded(NPCTalking nPCTalking, BasePlayer msgPlayer)",
    "MethodSignature": "Server_EndTalking(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void Server_EndTalking(RPCMessage msg)\n\t{\n\t\tOnConversationEnded(msg.player);\n\t\tInterface.CallHook(\u0022OnNpcConversationEnded\u0022, this, msg.player);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved, Action\u003CBasePlayer, Item\u003E onItemPurchased, MarketTerminal droneMarketTerminal)",
    "MethodSourseCode": "\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved = null, Action\u003CBasePlayer, Item\u003E onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\n\t{\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E= sellOrders.sellOrders.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (targetContainer == null \u0026\u0026 Vector3.Distance(buyer.transform.position, base.transform.position) \u003E 4f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions, targetContainer);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\n\t\tList\u003CItem\u003E obj2 = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\tGetItemsToSell(sellOrder, obj2);\n\t\tif (obj2 == null || obj2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\n\t\tint num2 = obj2.Sum((Item x) =\u003E x.amount);\n\t\tif (num \u003E num2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CItem\u003E source = buyer.inventory.FindItemIDs(sellOrder.currencyID);\n\t\tif (sellOrder.currencyIsBP)\n\t\t{\n\t\t\tsource = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)\n\t\t\t\twhere x.blueprintTarget == sellOrder.currencyID\n\t\t\t\tselect x).ToList();\n\t\t}\n\t\tsource = source.Where((Item x) =\u003E !x.hasCondition || (x.conditionNormalized \u003E= 0.5f \u0026\u0026 x.maxConditionNormalized \u003E 0.5f)).ToList();\n\t\tif (source.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num3 = source.Sum((Item x) =\u003E x.amount);\n\t\tint num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;\n\t\tif (num3 \u003C num4)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\ttransactionActive = true;\n\t\tint num5 = 0;\n\t\tforeach (Item item3 in source)\n\t\t{\n\t\t\tint num6 = Mathf.Min(num4 - num5, item3.amount);\n\t\t\tItem item = ((item3.amount \u003E num6) ? item3.SplitItem(num6) : item3);\n\t\t\tTakeCurrencyItem(item);\n\t\t\tonCurrencyRemoved?.Invoke(buyer, item);\n\t\t\tnum5 \u002B= num6;\n\t\t\tif (num5 \u003E= num4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem * numberOfTransactions, sellOrder.currencyIsBP, numberOfTransactions, droneMarketTerminal);\n\t\tint num7 = 0;\n\t\tforeach (Item item4 in obj2)\n\t\t{\n\t\t\tint num8 = num - num7;\n\t\t\tItem item2 = ((item4.amount \u003E num8) ? item4.SplitItem(num8) : item4);\n\t\t\tif (item2 == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Vending machine error, contact developers!\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum7 \u002B= item2.amount;\n\t\t\t\tobject obj3 = Interface.CallHook(\u0022CanPurchaseItem\u0022, buyer, item2, onItemPurchased, this, targetContainer);\n\t\t\t\tif (obj3 is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj3;\n\t\t\t\t}\n\t\t\t\tRecordSaleAnalytics(item2);\n\t\t\t\tif (targetContainer == null)\n\t\t\t\t{\n\t\t\t\t\tGiveSoldItem(item2, buyer);\n\t\t\t\t}\n\t\t\t\telse if (!item2.MoveToContainer(targetContainer))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\n\t\t\t\t}\n\t\t\t\tonItemPurchased?.Invoke(buyer, item2);\n\t\t\t}\n\t\t\tif (num7 \u003E= num)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\tUpdateEmptyFlag();\n\t\ttransactionActive = false;\n\t\treturn true;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnFishingRodCast(BaseFishingRod baseFishingRod, BasePlayer ownerPlayer, Item currentLure)",
    "MethodSignature": "Server_RequestCast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void Server_RequestCast(RPCMessage msg)\n\t{\n\t\tVector3 pos = msg.read.Vector3();\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tItem currentLure = GetCurrentLure();\n\t\tif (currentLure == null)\n\t\t{\n\t\t\tFailedCast(FailReason.NoLure);\n\t\t\treturn;\n\t\t}\n\t\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\n\t\t{\n\t\t\tFailedCast(reason);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCastFishingRod\u0022, ownerPlayer, this, currentLure, pos);\n\t\tif (!(obj is bool) || (bool)obj)\n\t\t{\n\t\t\tFishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position \u002B Vector3.up * 2.8f \u002B ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent\u003CFishingBobber\u003E();\n\t\t\tcomponent.transform.forward = GetOwnerPlayer().eyes.BodyForward();\n\t\t\tcomponent.Spawn();\n\t\t\tcomponent.InitialiseBobber(ownerPlayer, surfaceBody, pos);\n\t\t\tlureUsed = currentLure.info;\n\t\t\tcurrentLure.UseItem();\n\t\t\tif (fishLookup == null)\n\t\t\t{\n\t\t\t\tfishLookup = PrefabAttribute.server.Find\u003CFishLookup\u003E(prefabID);\n\t\t\t}\n\t\t\tcurrentFishTarget = fishLookup.GetFish(component.transform.position, surfaceBody, lureUsed, out fishableModifier, lastFish);\n\t\t\tlastFish = fishableModifier;\n\t\t\tcurrentBobber.Set(component);\n\t\t\tClientRPC(null, \u0022Client_ReceiveCastPoint\u0022, component.net.ID);\n\t\t\townerPlayer.SignalBroadcast(Signal.Attack);\n\t\t\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\n\t\t\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\n\t\t\tfloat val = (lureUsed.TryGetComponent\u003CItemModCompostable\u003E(out var component2) ? component2.BaitValue : 0f);\n\t\t\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\n\t\t\tcatchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);\n\t\t\tplayerStartPosition = ownerPlayer.transform.position;\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tCurrentState = CatchState.Waiting;\n\t\t\tInvokeRepeating(CatchProcess, 0f, 0f);\n\t\t\tinQueue = false;\n\t\t\tInterface.CallHook(\u0022OnFishingRodCast\u0022, this, ownerPlayer, currentLure);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "OnLootItem(BasePlayer getComponent\u003CBasePlayer\u003E, Item item)",
    "MethodSignature": "StartLootingItem(Item item)",
    "MethodSourseCode": "\n\tpublic void StartLootingItem(Item item)\n\t{\n\t\tClear();\n\t\tif (item != null \u0026\u0026 item.contents != null)\n\t\t{\n\t\t\tPositionChecks = true;\n\t\t\tcontainers.Add(item.contents);\n\t\t\titem.contents.onDirty \u002B= MarkDirty;\n\t\t\titemSource = item;\n\t\t\tentitySource = item.GetWorldEntity();\n\t\t\tInterface.CallHook(\u0022OnLootItem\u0022, GetComponent\u003CBasePlayer\u003E(), item);\n\t\t\tMarkDirty();\n\t\t}\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnCodeEntered(CodeLock codeLock, BasePlayer rpcPlayer, string text)",
    "MethodSignature": "UnlockWithCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void UnlockWithCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tif (Interface.CallHook(\u0022OnCodeEntered\u0022, this, rpc.player, text) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = text == guestCode;\n\t\tbool flag2 = text == code;\n\t\tif (!(text == code) \u0026\u0026 (!hasGuestCode || !(text == guestCode)))\n\t\t{\n\t\t\tif (UnityEngine.Time.realtimeSinceStartup \u003E lastWrongTime \u002B 60f)\n\t\t\t{\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tDoEffect(effectDenied.resourcePath);\n\t\t\tDoEffect(effectShock.resourcePath);\n\t\t\trpc.player.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, this, useProtection: false);\n\t\t\twrongCodes\u002B\u002B;\n\t\t\tif (wrongCodes \u003E 5)\n\t\t\t{\n\t\t\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning);\n\t\t\t}\n\t\t\tif ((float)wrongCodes \u003E= maxFailedAttempts)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved11, b: true);\n\t\t\t\tInvoke(ClearCodeEntryBlocked, lockoutCooldown);\n\t\t\t}\n\t\t\tlastWrongTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\treturn;\n\t\t}\n\t\tSendNetworkUpdate();\n\t\tif (flag2)\n\t\t{\n\t\t\tif (!whitelistPlayers.Contains(rpc.player.userID))\n\t\t\t{\n\t\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);\n\t\t}\n\t\telse if (flag \u0026\u0026 !guestPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnHelicopterAttack(CH47HelicopterAIController cH47HelicopterAIController, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterAttack\u0022, this, info) == null)\n\t\t{\n\t\t\tbase.OnAttacked(info);\n\t\t\tInitiateAnger();\n\t\t\tSetFlag(Flags.Reserved7, base.healthFraction \u003C= 0.8f);\n\t\t\tSetFlag(Flags.OnFire, base.healthFraction \u003C= 0.33f);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SVSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSetSwitch(!IsOn());\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "ElectricSwitch",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanCatchFish(BasePlayer ownerPlayer, BaseFishingRod baseFishingRod, Item item)",
    "MethodSignature": "CatchProcessBudgeted()",
    "MethodSourseCode": "\n\tprivate void CatchProcessBudgeted()\n\t{\n\t\tinQueue = false;\n\t\tFishingBobber fishingBobber = currentBobber.Get(serverside: true);\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)\n\t\t{\n\t\t\tServer_Cancel(FailReason.UserRequested);\n\t\t\treturn;\n\t\t}\n\t\tVector3 position = ownerPlayer.transform.position;\n\t\tfloat num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));\n\t\tfloat num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));\n\t\tif (num \u003E ((num2 \u003E 1.2f) ? 60f : 180f))\n\t\t{\n\t\t\tServer_Cancel(FailReason.BadAngle);\n\t\t\treturn;\n\t\t}\n\t\tif (num2 \u003E 1.2f \u0026\u0026 (float)lastSightCheck \u003E 0.4f)\n\t\t{\n\t\t\tif (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))\n\t\t\t{\n\t\t\t\tServer_Cancel(FailReason.Obstructed);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastSightCheck = 0f;\n\t\t}\n\t\tif (Vector3.Distance(position, fishingBobber.transform.position) \u003E MaxCastDistance * 2f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TooFarAway);\n\t\t\treturn;\n\t\t}\n\t\tif (Vector3.Distance(playerStartPosition, position) \u003E 1f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.PlayerMoved);\n\t\t\treturn;\n\t\t}\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tif ((float)catchTime \u003C 0f)\n\t\t\t{\n\t\t\t\tClientRPC(null, \u0022Client_HookedSomething\u0022);\n\t\t\t\tCurrentState = CatchState.Catching;\n\t\t\t\tfishingBobber.SetFlag(Flags.Reserved1, b: true);\n\t\t\t\tnextFishStateChange = 0f;\n\t\t\t\tfishCatchDuration = 0f;\n\t\t\t\tstrainTimer = 0f;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tFishState fishState = currentFishState;\n\t\tif ((float)nextFishStateChange \u003C 0f)\n\t\t{\n\t\t\tfloat num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);\n\t\t\tif (currentFishState != 0)\n\t\t\t{\n\t\t\t\tcurrentFishState = (FishState)0;\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 \u002B 1f);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 50)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState = FishState.PullingRight;\n\t\t\t\t}\n\t\t\t\tif (UnityEngine.Random.Range(0, 100) \u003E 60 \u0026\u0026 Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) \u003C MaxCastDistance - 2f)\n\t\t\t\t{\n\t\t\t\t\tcurrentFishState |= FishState.PullingBack;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((float)fishCatchDuration \u003E 120f)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TimeOut);\n\t\t\treturn;\n\t\t}\n\t\tbool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);\n\t\tbool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);\n\t\tbool flag3 = HasReelInInput(ownerPlayer.serverInput);\n\t\tif (flag2 \u0026\u0026 flag)\n\t\t{\n\t\t\tflag2 = (flag = false);\n\t\t}\n\t\tUpdateFlags(flag2, flag, flag3);\n\t\tif (CurrentState == CatchState.Waiting)\n\t\t{\n\t\t\tflag = (flag2 = (flag3 = false));\n\t\t}\n\t\tif (flag2 \u0026\u0026 !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag2 = false;\n\t\t}\n\t\tif (flag \u0026\u0026 !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))\n\t\t{\n\t\t\tflag = false;\n\t\t}\n\t\tfishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);\n\t\tbool flag4 = false;\n\t\tfloat num4 = 0f;\n\t\tif (flag3 || flag2 || flag)\n\t\t{\n\t\t\tflag4 = true;\n\t\t\tnum4 = 0.5f;\n\t\t}\n\t\tif (currentFishState != 0 \u0026\u0026 flag4)\n\t\t{\n\t\t\tif (currentFishState.Contains(FishState.PullingBack) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.5f;\n\t\t\t}\n\t\t\telse if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) \u0026\u0026 flag3)\n\t\t\t{\n\t\t\t\tnum4 = 1.2f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingLeft) \u0026\u0026 flag)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t\telse if (currentFishState.Contains(FishState.PullingRight) \u0026\u0026 flag2)\n\t\t\t{\n\t\t\t\tnum4 = 0.8f;\n\t\t\t}\n\t\t}\n\t\tif (flag3 \u0026\u0026 currentFishState != 0)\n\t\t{\n\t\t\tnum4 \u002B= 1f;\n\t\t}\n\t\tnum4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;\n\t\tif (flag4)\n\t\t{\n\t\t\tstrainTimer \u002B= UnityEngine.Time.deltaTime * num4;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstrainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);\n\t\t}\n\t\tfloat num5 = strainTimer / 6f;\n\t\tSetFlag(Flags.Reserved1, flag4 \u0026\u0026 num5 \u003E 0.25f);\n\t\tif ((float)lastStrainUpdate \u003E 0.4f || fishState != currentFishState)\n\t\t{\n\t\t\tClientRPC(null, \u0022Client_UpdateFishState\u0022, (int)currentFishState, num5);\n\t\t\tlastStrainUpdate = 0f;\n\t\t}\n\t\tif (strainTimer \u003E 7f || ForceFail)\n\t\t{\n\t\t\tServer_Cancel(FailReason.TensionBreak);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(num2 \u003C= FishCatchDistance) \u0026\u0026 !ForceSuccess)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCurrentState = CatchState.Caught;\n\t\t\tif (currentFishTarget != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(currentFishTarget, 1, 0uL);\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanCatchFish\u0022, ownerPlayer, this, item);\n\t\t\t\tif (obj is bool \u0026\u0026 !(bool)obj)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobject obj2 = Interface.CallHook(\u0022OnFishCatch\u0022, item, this, ownerPlayer);\n\t\t\t\tif (obj2 is Item \u0026\u0026 obj2 as Item != item)\n\t\t\t\t{\n\t\t\t\t\titem.Remove();\n\t\t\t\t\titem = (Item)obj2;\n\t\t\t\t}\n\t\t\t\townerPlayer.GiveItem(item, GiveItemReason.Crafted);\n\t\t\t\tif (currentFishTarget.shortname == \u0022skull.human\u0022)\n\t\t\t\t{\n\t\t\t\t\titem.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));\n\t\t\t\t}\n\t\t\t\tif (Rust.GameInfo.HasAchievements \u0026\u0026 !string.IsNullOrEmpty(fishableModifier.SteamStatName))\n\t\t\t\t{\n\t\t\t\t\townerPlayer.stats.Add(fishableModifier.SteamStatName, 1);\n\t\t\t\t\townerPlayer.stats.Save(forceSteamSave: true);\n\t\t\t\t\tfishLookup.CheckCatchAllAchievement(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);\n\t\t\tClientRPC(null, \u0022Client_OnCaughtFish\u0022, currentFishTarget.itemid);\n\t\t\townerPlayer.SignalBroadcast(Signal.Alt_Attack);\n\t\t\tInvoke(ResetLine, 6f);\n\t\t\tfishingBobber.Kill();\n\t\t\tcurrentBobber.Set(null);\n\t\t\tCancelInvoke(CatchProcess);\n\t\t\tInterface.CallHook(\u0022OnFishCaught\u0022, currentFishTarget, this, ownerPlayer);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 163
  },
  {
    "HookSignature": "OnItemRemove(Item item)",
    "MethodSignature": "Remove(float fTime)",
    "MethodSourseCode": "\n\tpublic void Remove(float fTime = 0f)\n\t{\n\t\tif (removeTime \u003E 0f || Interface.CallHook(\u0022OnItemRemove\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (isServer)\n\t\t{\n\t\t\tItemMod[] itemMods = info.itemMods;\n\t\t\tfor (int i = 0; i \u003C itemMods.Length; i\u002B\u002B)\n\t\t\t{\n\t\t\t\titemMods[i].OnRemove(this);\n\t\t\t}\n\t\t}\n\t\tthis.onCycle = null;\n\t\tremoveTime = UnityEngine.Time.time \u002B fTime;\n\t\tthis.OnDirty = null;\n\t\tposition = -1;\n\t\tif (isServer)\n\t\t{\n\t\t\tItemManager.RemoveItem(this, fTime);\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)",
    "MethodSignature": "PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)",
    "MethodSourseCode": "\n\tpublic bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlockTechTreeNodePath\u0022, player, node, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tNodeInstance entryNode = GetEntryNode();\n\t\tif (entryNode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn CheckChainRecursive(player, entryNode, node);\n\t}\n",
    "ClassName": "TechTreeData",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)",
    "MethodSignature": "RefreshSellOrderStockLevel(ItemDefinition itemDef)",
    "MethodSourseCode": "\n\tpublic void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)\n\t{\n\t\tforeach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)\n\t\t{\n\t\t\tif (!(itemDef == null) \u0026\u0026 itemDef.itemid != sellOrder.itemToSellID)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\t\tGetItemsToSell(sellOrder, obj);\n\t\t\tint inStock;\n\t\t\tif (obj.Count \u003C 0)\n\t\t\t{\n\t\t\t\tinStock = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E source = obj;\n\t\t\t\tFunc\u003CItem, int\u003E selector = (Item x) =\u003E x.amount;\n\t\t\t\tInterface.CallHook(\u0022OnRefreshVendingStock\u0022, this, itemDef);\n\t\t\t\tinStock = source.Sum(selector) / sellOrder.itemToSellAmount;\n\t\t\t}\n\t\t\tsellOrder.inStock = inStock;\n\t\t\tfloat itemCondition = 0f;\n\t\t\tfloat itemConditionMax = 0f;\n\t\t\tint instanceData = 0;\n\t\t\tif (obj.Count \u003E 0)\n\t\t\t{\n\t\t\t\tif (obj[0].hasCondition)\n\t\t\t\t{\n\t\t\t\t\titemCondition = obj[0].condition;\n\t\t\t\t\titemConditionMax = obj[0].maxCondition;\n\t\t\t\t}\n\t\t\t\tif (obj[0].info != null \u0026\u0026 obj[0].info.amountType == ItemDefinition.AmountType.Genetics \u0026\u0026 obj[0].instanceData != null)\n\t\t\t\t{\n\t\t\t\t\tinstanceData = obj[0].instanceData.dataInt;\n\t\t\t\t\tsellOrder.inStock = obj[0].amount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsellOrder.itemCondition = itemCondition;\n\t\t\tsellOrder.itemConditionMax = itemConditionMax;\n\t\t\tsellOrder.instanceData = instanceData;\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnEntityVisibilityCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityVisibilityCheck\u0022, ent, player, id, debugName, maximumDistance);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688))\n\t\t\t\t{\n\t\t\t\t\tif (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn ent.IsVisible(player.eyes.position, maximumDistance);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnItemResearched(ResearchTable researchTable, int num)",
    "MethodSignature": "ResearchAttemptFinished()",
    "MethodSourseCode": "\n\tpublic void ResearchAttemptFinished()\n\t{\n\t\tItem targetItem = GetTargetItem();\n\t\tItem scrapItem = GetScrapItem();\n\t\tif (targetItem != null \u0026\u0026 scrapItem != null)\n\t\t{\n\t\t\tint num = ScrapForResearch(targetItem);\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemResearched\u0022, this, num);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tnum = (int)obj;\n\t\t\t}\n\t\t\tif (scrapItem.amount \u003E= num)\n\t\t\t{\n\t\t\t\tif (scrapItem.amount == num)\n\t\t\t\t{\n\t\t\t\t\tbase.inventory.Remove(scrapItem);\n\t\t\t\t\tscrapItem.RemoveFromContainer();\n\t\t\t\t\tscrapItem.Remove();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tscrapItem.UseItem(num);\n\t\t\t\t}\n\t\t\t\tbase.inventory.Remove(targetItem);\n\t\t\t\ttargetItem.Remove();\n\t\t\t\tItem item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);\n\t\t\t\titem.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);\n\t\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t\tif (researchSuccessEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tif (user != null)\n\t\t{\n\t\t\tuser.inventory.loot.SendImmediate();\n\t\t}\n\t\tEndResearch();\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPayForPlacement(BasePlayer player, Planner planner, Construction component)",
    "MethodSignature": "PayForPlacement(BasePlayer player, Construction component)",
    "MethodSourseCode": "\n\tpublic void PayForPlacement(BasePlayer player, Construction component)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForPlacement\u0022, player, this, component) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\tGetItem().UseItem();\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount item in component.defaultGrade.costToBuild)\n\t\t{\n\t\t\tplayer.inventory.Take(list, item.itemDef.itemid, (int)item.amount);\n\t\t\tplayer.Command(\u0022note.inv\u0022, item.itemDef.itemid, item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in list)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityMounted(BaseMountable baseMountable, BasePlayer player)",
    "MethodSignature": "MountPlayer(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void MountPlayer(BasePlayer player)\n\t{\n\t\tif (!(_mounted != null) \u0026\u0026 !(mountAnchor == null) \u0026\u0026 Interface.CallHook(\u0022CanMountEntity\u0022, player, this) == null)\n\t\t{\n\t\t\tplayer.EnsureDismounted();\n\t\t\t_mounted = player;\n\t\t\tTransform transform = mountAnchor.transform;\n\t\t\tplayer.MountObject(this);\n\t\t\tplayer.MovePosition(transform.position);\n\t\t\tplayer.transform.rotation = transform.rotation;\n\t\t\tplayer.ServerRotation = transform.rotation;\n\t\t\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\n\t\t\t_mounted.eyes.NetworkUpdate(transform.rotation);\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, player.transform.position);\n\t\t\tOnPlayerMounted();\n\t\t\tInterface.CallHook(\u0022OnEntityMounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnPhoneAnswered(PhoneController phoneController, PhoneController activeCallTo)",
    "MethodSignature": "AnswerPhone(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\tpublic void AnswerPhone(BaseEntity.RPCMessage msg)\n\t{\n\t\tif (IsInvoking(TimeOutDialing))\n\t\t{\n\t\t\tCancelInvoke(TimeOutDialing);\n\t\t}\n\t\tif (!(activeCallTo == null))\n\t\t{\n\t\t\tBasePlayer player = msg.player;\n\t\t\tif (Interface.CallHook(\u0022OnPhoneAnswer\u0022, this, activeCallTo) == null)\n\t\t\t{\n\t\t\t\tUpdateServerPlayer(player);\n\t\t\t\tBeginCall();\n\t\t\t\tactiveCallTo.BeginCall();\n\t\t\t\tInterface.CallHook(\u0022OnPhoneAnswered\u0022, this, activeCallTo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnRemoveDying(GrowableEntity growableEntity, BasePlayer receiver)",
    "MethodSignature": "RemoveDying(BasePlayer receiver)",
    "MethodSourseCode": "\n\tpublic void RemoveDying(BasePlayer receiver)\n\t{\n\t\tif (State == PlantProperties.State.Dying \u0026\u0026 !(Properties.removeDyingItem == null) \u0026\u0026 Interface.CallHook(\u0022OnRemoveDying\u0022, this, receiver) == null)\n\t\t{\n\t\t\tif (Properties.removeDyingEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tItem item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);\n\t\t\tif (receiver != null)\n\t\t\t{\n\t\t\t\treceiver.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 0.5f, Vector3.up * 1f);\n\t\t\t}\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, IndustrialCrafter industrialCrafter)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (NeedsBuildingPrivilegeToUse \u0026\u0026 !player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (OnlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Already in use\u0022);\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, LootPanelName);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "IndustrialCrafter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, StorageContainer storageContainer)",
    "MethodSignature": "PlayerOpenLoot(BasePlayer player, string panelToOpen, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = \u0022\u0022, bool doPositionChecks = true)\n\t{\n\t\tif (Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, LockedMessage);\n\t\t\treturn false;\n\t\t}\n\t\tif (onlyOneUser \u0026\u0026 IsOpen())\n\t\t{\n\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, InUseMessage);\n\t\t\treturn false;\n\t\t}\n\t\tif (panelToOpen == \u0022\u0022)\n\t\t{\n\t\t\tpanelToOpen = panelName;\n\t\t}\n\t\tif (!CanOpenLootPanel(player, panelToOpen))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player.inventory.loot.StartLootingEntity(this, doPositionChecks))\n\t\t{\n\t\t\tSetFlag(Flags.Open, b: true);\n\t\t\tAddContainers(player.inventory.loot);\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, panelToOpen);\n\t\t\tSendNetworkUpdate();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "StorageContainer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEngineLoadoutRefresh(Rust.Modular.EngineStorage rust.Modular.EngineStorage)",
    "MethodSignature": "RefreshLoadoutData()",
    "MethodSourseCode": "\n\tpublic void RefreshLoadoutData()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEngineLoadoutRefresh\u0022, this) == null)\n\t\t{\n\t\t\tisUsable = base.inventory.IsFull() \u0026\u0026 base.inventory.itemList.All((Item item) =\u003E !item.isBroken);\n\t\t\taccelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;\n\t\t\ttopSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;\n\t\t\tfuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;\n\t\t\tSendNetworkUpdate();\n\t\t\tGetEngineModule()?.RefreshPerformanceStats(this);\n\t\t}\n\t}\n",
    "ClassName": "EngineStorage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnIngredientsCollect(ItemCrafter itemCrafter, ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player)",
    "MethodSignature": "CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)\n\t{\n\t\tif (Interface.CallHook(\u0022OnIngredientsCollect\u0022, this, bp, task, amount, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount ingredient in bp.ingredients)\n\t\t{\n\t\t\tCollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);\n\t\t}\n\t\ttask.potentialOwners = new List\u003Culong\u003E();\n\t\tforeach (Item item in list)\n\t\t{\n\t\t\titem.CollectedForCrafting(player);\n\t\t\tif (!task.potentialOwners.Contains(player.userID))\n\t\t\t{\n\t\t\t\ttask.potentialOwners.Add(player.userID);\n\t\t\t}\n\t\t}\n\t\ttask.takenItems = list;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity potentialtarget, HelicopterTurret helicopterTurret)",
    "MethodSignature": "InFiringArc(BaseCombatEntity potentialtarget)",
    "MethodSourseCode": "\n\tpublic bool InFiringArc(BaseCombatEntity potentialtarget)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeTargeted\u0022, potentialtarget, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn AngleToTarget(potentialtarget) \u003C 80f;\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, NPCVendingMachine nPCVendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStashHidden(StashContainer stashContainer, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_HideStash(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_HideStash(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022CanHideStash\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\n\t\t\tSetHidden(isHidden: true);\n\t\t\tInterface.CallHook(\u0022OnStashHidden\u0022, this, rpc.player);\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnRfFrequencyChanged(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnDefaultItemsReceived(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tGiveDefaultItemWithSkin(\u0022client.rockskin\u0022, \u0022rock\u0022);\n\t\tGiveDefaultItemWithSkin(\u0022client.torchskin\u0022, \u0022torch\u0022);\n\t\tif (IsBirthday())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL), containerWear);\n\t\t}\n\t\tif (IsChristmas())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\n\t\t{\n\t\t\tulong num = 0uL;\n\t\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\n\t\t\tif (infoInt \u003E 0 \u0026\u0026 (base.baseEntity.blueprints.steamInventory.HasItem(infoInt) || flag2))\n\t\t\t{\n\t\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\n\t\t\t\tif (itemDefinition != null \u0026\u0026 ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\n\t\t\t\t{\n\t\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\t\t\tif (itemDefinition2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\n\t\t\t\t\t}\n\t\t\t\t\tif (num == 0L \u0026\u0026 itemDefinition.skins != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\n\t\t\t\t\t\tfor (int i = 0; i \u003C skins.Length; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\n\t\t\t\t\t\t\tif (skin.id == infoInt \u0026\u0026 skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin \u0026\u0026 itemSkin.Redirect != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "CanSamSiteShoot(SamSite samSite)",
    "MethodSignature": "WeaponTick()",
    "MethodSourseCode": "\n\tpublic void WeaponTick()\n\t{\n\t\tif (IsDead() || UnityEngine.Time.time \u003C lockOnTime || UnityEngine.Time.time \u003C nextBurstTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (firedCount \u003E= 6)\n\t\t{\n\t\t\tfloat timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;\n\t\t\tnextBurstTime = UnityEngine.Time.time \u002B timeBetweenBursts;\n\t\t\tfiredCount = 0;\n\t\t\treturn;\n\t\t}\n\t\tEnsureReloaded();\n\t\tif (Interface.CallHook(\u0022CanSamSiteShoot\u0022, this) == null \u0026\u0026 HasAmmo())\n\t\t{\n\t\t\tbool num = ammoItem != null \u0026\u0026 ammoItem.amount == lowAmmoThreshold;\n\t\t\tif (!staticRespawn \u0026\u0026 ammoItem != null)\n\t\t\t{\n\t\t\t\tammoItem.UseItem();\n\t\t\t}\n\t\t\tfiredCount\u002B\u002B;\n\t\t\tfloat speedMultiplier = 1f;\n\t\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t\t{\n\t\t\t\tspeedMultiplier = currentTarget.SAMTargetType.speedMultiplier;\n\t\t\t}\n\t\t\tFireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);\n\t\t\tEffect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get(\u0022Tube \u0022 \u002B (currentTubeIndex \u002B 1)), Vector3.zero, Vector3.up);\n\t\t\tcurrentTubeIndex\u002B\u002B;\n\t\t\tif (currentTubeIndex \u003E= tubes.Length)\n\t\t\t{\n\t\t\t\tcurrentTubeIndex = 0;\n\t\t\t}\n\t\t\tif (num)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "CanHelicopterStrafeTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "ValidStrafeTarget(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool ValidStrafeTarget(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterStrafeTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn !ply.IsNearEnemyBase();\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootEntity(BasePlayer getComponent\u003CBasePlayer\u003E, BaseEntity targetEntity)",
    "MethodSignature": "StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks)",
    "MethodSourseCode": "\n\tpublic bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)\n\t{\n\t\tClear();\n\t\tif (!targetEntity)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!targetEntity.OnStartBeingLooted(base.baseEntity))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tAssert.IsTrue(targetEntity.isServer, \u0022Assure is server\u0022);\n\t\tPositionChecks = doPositionChecks;\n\t\tentitySource = targetEntity;\n\t\titemSource = null;\n\t\tInterface.CallHook(\u0022OnLootEntity\u0022, GetComponent\u003CBasePlayer\u003E(), targetEntity);\n\t\tMarkDirty();\n\t\tif (targetEntity is ILootableEntity lootableEntity)\n\t\t{\n\t\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PlayerLoot",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnFeedbackReported(BasePlayer basePlayer, string text, string text2, Facepunch.Models.ReportType reportType)",
    "MethodSignature": "OnFeedbackReport(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void OnFeedbackReport(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tstring text2 = msg.read.StringMultiLine();\n\t\tReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 5);\n\t\tif (ConVar.Server.printReportsToConsole)\n\t\t{\n\t\t\tDebugEx.Log($\u0022[FeedbackReport] {this} reported {reportType} - \\\u0022{text}\\\u0022 \\\u0022{text2}\\\u0022\u0022);\n\t\t\tRCon.Broadcast(RCon.LogType.Report, new\n\t\t\t{\n\t\t\t\tPlayerId = UserIDString,\n\t\t\t\tPlayerName = displayName,\n\t\t\t\tSubject = text,\n\t\t\t\tMessage = text2,\n\t\t\t\tType = reportType\n\t\t\t});\n\t\t}\n\t\tif (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\n\t\t{\n\t\t\tstring image = msg.read.StringMultiLine(60000);\n\t\t\tFacepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);\n\t\t\tfeedback.Type = reportType;\n\t\t\tfeedback.Message = text2;\n\t\t\tfeedback.Subject = text;\n\t\t\tFacepunch.Models.Feedback feedback2 = feedback;\n\t\t\tfeedback2.AppInfo.Image = image;\n\t\t\tFacepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);\n\t\t}\n\t\tInterface.CallHook(\u0022OnFeedbackReported\u0022, this, text, text2, reportType);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerSpawn(BasePlayer basePlayer, Network.Connection connection)",
    "MethodSignature": "SpawnNewPlayer(Network.Connection connection)",
    "MethodSourseCode": "\n\tprivate BasePlayer SpawnNewPlayer(Network.Connection connection)\n\t{\n\t\tBasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();\n\t\tBasePlayer basePlayer = GameManager.server.CreateEntity(\u0022assets/prefabs/player/player.prefab\u0022, spawnPoint.pos, spawnPoint.rot).ToPlayer();\n\t\tif (Interface.CallHook(\u0022OnPlayerSpawn\u0022, basePlayer, connection) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tbasePlayer.health = 0f;\n\t\tbasePlayer.lifestate = BaseCombatEntity.LifeState.Dead;\n\t\tbasePlayer.ResetLifeStateOnSpawn = false;\n\t\tbasePlayer.limitNetworking = true;\n\t\tbasePlayer.Spawn();\n\t\tbasePlayer.limitNetworking = false;\n\t\tbasePlayer.PlayerInit(connection);\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);\n\t\t}\n\t\telse if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 \u0026\u0026 !basePlayer.hasPreviousLife))\n\t\t{\n\t\t\tbasePlayer.Respawn();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbasePlayer.SendRespawnOptions();\n\t\t}\n\t\tDebugEx.Log($\u0022{basePlayer.displayName} with steamid {basePlayer.userID} joined from ip {basePlayer.net.connection.ipaddress}\u0022);\n\t\tDebugEx.Log($\u0022\\tNetworkId {basePlayer.userID} is {basePlayer.net.ID} ({basePlayer.displayName})\u0022);\n\t\tif (basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)\n\t\t{\n\t\t\tDebugEx.Log($\u0022\\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}\u0022);\n\t\t}\n\t\treturn basePlayer;\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVehicleLockableCheck(ModularCarCodeLock modularCarCodeLock)",
    "MethodSignature": "CanHaveALock()",
    "MethodSourseCode": "\n\tpublic bool CanHaveALock()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnVehicleLockableCheck\u0022, this);\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (!(obj is bool))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!owner.IsDead())\n\t\t{\n\t\t\treturn owner.HasDriverMountPoints();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "ModularCarCodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnXmasLootDistribute(XMasRefill xMasRefill)",
    "MethodSignature": "ServerInit()",
    "MethodSourseCode": "\n\tpublic override void ServerInit()\n\t{\n\t\tbase.ServerInit();\n\t\tif (!XMas.enabled)\n\t\t{\n\t\t\tInvoke(RemoveMe, 0.1f);\n\t\t\treturn;\n\t\t}\n\t\tgoodKids = ((BasePlayer.activePlayerList != null) ? new List\u003CBasePlayer\u003E(BasePlayer.activePlayerList) : new List\u003CBasePlayer\u003E());\n\t\tstockings = ((Stocking.stockings != null) ? new List\u003CStocking\u003E(Stocking.stockings.Values) : new List\u003CStocking\u003E());\n\t\tInvoke(RemoveMe, 60f);\n\t\tif (Interface.CallHook(\u0022OnXmasLootDistribute\u0022, this) == null)\n\t\t{\n\t\t\tInvokeRepeating(DistributeLoot, 3f, 0.02f);\n\t\t\tInvoke(SendBells, 0.5f);\n\t\t}\n\t}\n",
    "ClassName": "XMasRefill",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnServerInitialize()",
    "MethodSignature": "Initialize(bool loadSave, string saveFile, bool allowOutOfDateSaves, bool skipInitialSpawn)",
    "MethodSourseCode": "\n\tpublic void Initialize(bool loadSave = true, string saveFile = \u0022\u0022, bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\n\t{\n\t\tInterface.CallHook(\u0022OnServerInitialize\u0022);\n\t\tpersistance = new UserPersistance(ConVar.Server.rootFolder);\n\t\tplayerStateManager = new PlayerStateManager(persistance);\n\t\tSpawnMapEntities();\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.UpdateDistributions\u0022))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.UpdateDistributions();\n\t\t\t}\n\t\t}\n\t\tif (loadSave)\n\t\t{\n\t\t\tWorld.LoadedFromSave = true;\n\t\t\tWorld.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSaveRestore.SaveCreatedTime = DateTime.UtcNow;\n\t\t\tWorld.LoadedFromSave = false;\n\t\t}\n\t\tSaveRestore.InitializeWipeId();\n\t\tif ((bool)SingletonComponent\u003CSpawnHandler\u003E.Instance)\n\t\t{\n\t\t\tif (!skipInitialSpawn)\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.InitialSpawn\u0022, 200))\n\t\t\t\t{\n\t\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.InitialSpawn();\n\t\t\t\t}\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022SpawnHandler.StartSpawnTick\u0022, 200))\n\t\t\t{\n\t\t\t\tSingletonComponent\u003CSpawnHandler\u003E.Instance.StartSpawnTick();\n\t\t\t}\n\t\t}\n\t\tCreateImportantEntities();\n\t\tauth = GetComponent\u003CConnectionAuth\u003E();\n\t\tFacepunch.Rust.Analytics.Azure.Initialize();\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDoorKnocked(DoorKnocker doorKnocker, BasePlayer player)",
    "MethodSignature": "Knock(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void Knock(BasePlayer player)\n\t{\n\t\tClientRPC(null, \u0022ClientKnock\u0022, player.transform.position);\n\t\tInterface.CallHook(\u0022OnDoorKnocked\u0022, this, player);\n\t}\n",
    "ClassName": "DoorKnocker",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnExplosiveThrown(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoThrow(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void DoThrow(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tfloat num = Mathf.Clamp01(msg.read.Float());\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!canThrowUnderwater \u0026\u0026 msg.player.IsHeadUnderwater())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItem ownerItem = GetOwnerItem();\n\t\tif (ownerItem != null \u0026\u0026 ownerItem.instanceData != null \u0026\u0026 ownerItem.HasFlag(Item.Flag.IsOn))\n\t\t{\n\t\t\tbaseEntity.gameObject.SendMessage(\u0022SetFrequency\u0022, GetOwnerItem().instanceData.dataInt, SendMessageOptions.DontRequireReceiver);\n\t\t}\n\t\tbaseEntity.SetCreatorEntity(msg.player);\n\t\tbaseEntity.skinID = skinID;\n\t\tbaseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) \u002B normalized * maxThrowVelocity * num \u002B msg.player.estimatedVelocity * 0.5f);\n\t\tif (tumbleVelocity \u003E 0f)\n\t\t{\n\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);\n\t\t}\n\t\tbaseEntity.Spawn();\n\t\tSetUpThrownWeapon(baseEntity);\n\t\tStartAttackCooldown(repeatDelay);\n\t\tInterface.CallHook(\u0022OnExplosiveThrown\u0022, msg.player, baseEntity, this);\n\t\tUseItemAmount(1);\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player != null))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\n\t\tif (timedExplosive != null)\n\t\t{\n\t\t\tfloat num2 = 0f;\n\t\t\tforeach (DamageTypeEntry damageType in timedExplosive.damageTypes)\n\t\t\t{\n\t\t\t\tnum2 \u002B= damageType.amount;\n\t\t\t}\n\t\t\tSensation sensation = default(Sensation);\n\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\tsensation.Position = player.transform.position;\n\t\t\tsensation.Radius = 50f;\n\t\t\tsensation.DamagePotential = num2;\n\t\t\tsensation.InitiatorPlayer = player;\n\t\t\tsensation.Initiator = player;\n\t\t\tsensation.UsedEntity = timedExplosive;\n\t\t\tSense.Stimulate(sensation);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSensation sensation = default(Sensation);\n\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\tsensation.Position = player.transform.position;\n\t\t\tsensation.Radius = 50f;\n\t\t\tsensation.DamagePotential = 0f;\n\t\t\tsensation.InitiatorPlayer = player;\n\t\t\tsensation.Initiator = player;\n\t\t\tsensation.UsedEntity = this;\n\t\t\tSense.Stimulate(sensation);\n\t\t}\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "CanAssignBed(BasePlayer msgPlayer, SleepingBag sleepingBag, ulong num)",
    "MethodSignature": "AssignToFriend(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AssignToFriend(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract() || deployerUserID != msg.player.userID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong num = msg.read.UInt64();\n\t\tif (num == 0L || Interface.CallHook(\u0022CanAssignBed\u0022, msg.player, this, num) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null)\n\t\t{\n\t\t\tBaseGameMode.CanAssignBedResult? canAssignBedResult = activeGameMode.CanAssignBed(msg.player, this, num, 1, -1);\n\t\t\tif (canAssignBedResult.HasValue)\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(num);\n\t\t\t\tif (!canAssignBedResult.Value.Result)\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Red_Normal, cannotAssignBedPhrase, basePlayer?.displayName ?? \u0022other player\u0022);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbasePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());\n\t\t\t\t}\n\t\t\t\tif (!canAssignBedResult.Value.Result)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdeployerUserID = num;\n\t\tFacepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);\n\t\tSendNetworkUpdate();\n\t\tCheckForOnlineAndDead();\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnLiftUse(ProceduralLift proceduralLift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null \u0026\u0026 !IsBusy())\n\t\t{\n\t\t\tMoveToFloor((floorIndex \u002B 1) % stops.Length);\n\t\t}\n\t}\n",
    "ClassName": "ProceduralLift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSignLocked(Signage signage, BasePlayer msgPlayer)",
    "MethodSignature": "LockSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void LockSign(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanUpdateSign(msg.player))\n\t\t{\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tbase.OwnerID = msg.player.userID;\n\t\t\tInterface.CallHook(\u0022OnSignLocked\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnBigWheelLoss(BigWheelGame bigWheelGame, Item slot2, BigWheelBettingTerminal terminal)",
    "MethodSignature": "Payout()",
    "MethodSourseCode": "\n\tpublic void Payout()\n\t{\n\t\tHitNumber currentHitType = GetCurrentHitType();\n\t\tGuid value = Guid.NewGuid();\n\t\tforeach (BigWheelBettingTerminal terminal in terminals)\n\t\t{\n\t\t\tif (terminal.isClient)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tItem slot = terminal.inventory.GetSlot((int)currentHitType.hitType);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\n\t\t\t\tint amount = slot.amount;\n\t\t\t\tif (Interface.CallHook(\u0022OnBigWheelWin\u0022, this, slot, terminal, num) == null)\n\t\t\t\t{\n\t\t\t\t\tslot.amount \u002B= slot.amount * num;\n\t\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\t\tslot.MoveToContainer(terminal.inventory, 5);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i \u003C 5; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot2 = terminal.inventory.GetSlot(i);\n\t\t\t\tif (slot2 != null \u0026\u0026 Interface.CallHook(\u0022OnBigWheelLoss\u0022, this, slot2, terminal) == null)\n\t\t\t\t{\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);\n\t\t\t\t\tslot2.Remove();\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || flag2)\n\t\t\t{\n\t\t\t\tterminal.ClientRPC(null, \u0022WinOrLoseSound\u0022, flag);\n\t\t\t}\n\t\t}\n\t\tItemManager.DoRemoves();\n\t\tSetTerminalsLocked(isLocked: false);\n\t}\n",
    "ClassName": "BigWheelGame",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnTeamCreate(BasePlayer basePlayer)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.CreateTeam();\n\t\t\tPlayerTeam playerTeam2 = playerTeam;\n\t\t\tplayerTeam2.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam2.AddPlayer(basePlayer);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\u0022created\u0022, playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition, int skinItemId)",
    "MethodSignature": "CanCraft(int itemid, int skinItemId, ulong playerId)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(int itemid, int skinItemId, ulong playerId)\n\t{\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, itemDefinition, skinItemId);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (skinItemId != 0 \u0026\u0026 !base.baseEntity.UnlockAllSkins \u0026\u0026 !CheckSkinOwnership(skinItemId, playerId))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (base.baseEntity.currentCraftLevel \u003C (float)itemDefinition.Blueprint.workbenchLevelRequired)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (HasUnlocked(itemDefinition))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PlayerBlueprints",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnHelicopterStrafeEnter(PatrolHelicopterAI patrolHelicopterAI, UnityEngine.Vector3 strafePos)",
    "MethodSignature": "State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm)",
    "MethodSourseCode": "\n\tpublic void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterStrafeEnter\u0022, this, strafePos) == null)\n\t\t{\n\t\t\tif (CanUseNapalm() \u0026\u0026 shouldUseNapalm)\n\t\t\t{\n\t\t\t\tuseNapalm = shouldUseNapalm;\n\t\t\t\tlastNapalmTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t}\n\t\t\tlastStrafeTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t_currentState = aiState.STRAFE;\n\t\t\tint mask = LayerMask.GetMask(\u0022Terrain\u0022, \u0022World\u0022, \u0022Construction\u0022, \u0022Water\u0022);\n\t\t\tif (TransformUtil.GetGroundInfo(strafePos, out var pos, out var _, 100f, mask, base.transform))\n\t\t\t{\n\t\t\t\tstrafe_target_position = pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstrafe_target_position = strafePos;\n\t\t\t}\n\t\t\tnumRocketsLeft = 12;\n\t\t\tlastRocketTime = 0f;\n\t\t\tmovementLockingAiming = true;\n\t\t\tVector3 randomOffset = GetRandomOffset(strafePos, 175f, 192.5f);\n\t\t\tSetTargetDestination(randomOffset, 10f);\n\t\t\tSetIdealRotation(GetYawRotationTo(randomOffset));\n\t\t\tputtingDistance = true;\n\t\t}\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSpinWheel(BasePlayer rpcPlayer, SpinnerWheel spinnerWheel)",
    "MethodSignature": "RPC_Spin(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Spin(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 AllowPlayerSpins() \u0026\u0026 (AnyoneSpin() || rpc.player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022OnSpinWheel\u0022, rpc.player, this) == null \u0026\u0026 !(velocity \u003E 15f))\n\t\t{\n\t\t\tvelocity \u002B= UnityEngine.Random.Range(4f, 7f);\n\t\t}\n\t}\n",
    "ClassName": "SpinnerWheel",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnExplosiveDropped(BasePlayer msgPlayer, BaseEntity baseEntity, ThrownWeapon thrownWeapon)",
    "MethodSignature": "DoDrop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void DoDrop(RPCMessage msg)\n\t{\n\t\tif (!HasItemAmount() || HasAttackCooldown() || (!canThrowUnderwater \u0026\u0026 msg.player.IsHeadUnderwater()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 vector = msg.read.Vector3();\n\t\tVector3 normalized = msg.read.Vector3().normalized;\n\t\tif (msg.player.isMounted || msg.player.HasParent())\n\t\t{\n\t\t\tvector = msg.player.eyes.position;\n\t\t}\n\t\telse if (!ValidateEyePos(msg.player, vector))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));\n\t\tif (baseEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (canStick \u0026\u0026 UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1236478737))\n\t\t{\n\t\t\tVector3 point = hitInfo.point;\n\t\t\tVector3 normal = hitInfo.normal;\n\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(hitInfo);\n\t\t\tCollider collider = hitInfo.collider;\n\t\t\tif ((bool)entity \u0026\u0026 entity is StabilityEntity \u0026\u0026 baseEntity is TimedExplosive)\n\t\t\t{\n\t\t\t\tentity = entity.ToServer\u003CBaseEntity\u003E();\n\t\t\t\tTimedExplosive timedExplosive = baseEntity as TimedExplosive;\n\t\t\t\ttimedExplosive.onlyDamageParent = true;\n\t\t\t\ttimedExplosive.DoStick(point, normal, entity, collider);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(msg.player, timedExplosive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbaseEntity.SetVelocity(normalized);\n\t\t}\n\t\tbaseEntity.creatorEntity = msg.player;\n\t\tbaseEntity.skinID = skinID;\n\t\tbaseEntity.Spawn();\n\t\tSetUpThrownWeapon(baseEntity);\n\t\tStartAttackCooldown(repeatDelay);\n\t\tInterface.CallHook(\u0022OnExplosiveDropped\u0022, msg.player, baseEntity, this);\n\t\tUseItemAmount(1);\n\t}\n",
    "ClassName": "ThrownWeapon",
    "HookLineInvoke": 52
  },
  {
    "HookSignature": "OnTrapDisarm(Landmine landmine, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_Disarm(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_Disarm(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.userID != triggerPlayerID \u0026\u0026 Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapDisarm\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tSetFlag(Flags.On, b: false);\n\t\t\tif (UnityEngine.Random.Range(0, 100) \u003C 15)\n\t\t\t{\n\t\t\t\tInvoke(TryExplode, 0.05f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trpc.player.GiveItem(ItemManager.CreateByName(\u0022trap.landmine\u0022, 1, 0uL), GiveItemReason.PickedUp);\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "Landmine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tTechTreeData.NodeInstance byID = techTree.GetByID(num);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTree.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTree.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \u0022techtree\u0022, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint num2 = ResearchTable.ScrapForResearch(byID.itemDef, ResearchTable.ResearchType.TechTree);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num2)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num2);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \u0022techtree\u0022, this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnPlayerSleepEnded(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void EndSleeping()\n\t{\n\t\tif (IsSleeping() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSleepEnd\u0022, this) == null)\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\n\t\t\tsleepStartTime = -1f;\n\t\t\tsleepingPlayerList.Remove(this);\n\t\t\tif (userID \u003C 10000000 \u0026\u0026 !bots.Contains(this))\n\t\t\t{\n\t\t\t\tbots.Add(this);\n\t\t\t}\n\t\t\tCancelInvoke(ScheduledDeath);\n\t\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\n\t\t\tif (RelationshipManager.TeamsEnabled())\n\t\t\t{\n\t\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\n\t\t\t}\n\t\t\tEnablePlayerCollider();\n\t\t\tAddPlayerRigidbody();\n\t\t\tSetServerFall(wantsOn: false);\n\t\t\tif (HasParent())\n\t\t\t{\n\t\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\t\tForceUpdateTriggers();\n\t\t\t}\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\n\t\t\tEACServer.LogPlayerSpawn(this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnCupboardAuthorize(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "AddSelfAuthorize(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void AddSelfAuthorize(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardAuthorize\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tAddPlayer(rpc.player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntitySpawned(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Spawn()",
    "MethodSourseCode": "\n\tpublic virtual void Spawn()\n\t{\n\t\tSpawnShared();\n\t\tif (net == null)\n\t\t{\n\t\t\tnet = Network.Net.sv.CreateNetworkable();\n\t\t}\n\t\tcreationFrame = UnityEngine.Time.frameCount;\n\t\tPreInitShared();\n\t\tInitShared();\n\t\tServerInit();\n\t\tPostInitShared();\n\t\tUpdateNetworkGroup();\n\t\tisSpawned = true;\n\t\tInterface.CallHook(\u0022OnEntitySpawned\u0022, this);\n\t\tSendNetworkUpdateImmediate(justCreated: true);\n\t\tif (Rust.Application.isLoading \u0026\u0026 !Rust.Application.isLoadingSave)\n\t\t{\n\t\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnContainerDropItems(ItemContainer container)",
    "MethodSignature": "DropItems(ItemContainer container, Vector3 position)",
    "MethodSourseCode": "\tpublic static void DropItems(ItemContainer container, Vector3 position)\n\t{\n\t\tif (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook(\u0022OnContainerDropItems\u0022, container) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 0.25f;\n\t\tItem[] array = container.itemList.ToArray();\n\t\tforeach (Item item in array)\n\t\t{\n\t\t\tfloat num2 = UnityEngine.Random.Range(0f, 2f);\n\t\t\titem.RemoveFromContainer();\n\t\t\tBaseEntity baseEntity = item.CreateWorldObject(position \u002B new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));\n\t\t\tif (baseEntity == null)\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (baseEntity is DroppedItem droppedItem \u0026\u0026 container.entityOwner is LootContainer)\n\t\t\t{\n\t\t\t\tdroppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;\n\t\t\t}\n\t\t\tif (num2 \u003E 0f)\n\t\t\t{\n\t\t\t\tbaseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);\n\t\t\t\tbaseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "DropUtil",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPhoneDialFail(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(null, \u0022ClientOnDialFailed\u0022, (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanResearchItem(BasePlayer player, Item targetItem)",
    "MethodSignature": "DoResearch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void DoResearch(RPCMessage msg)\n\t{\n\t\tif (IsResearching())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tItem targetItem = GetTargetItem();\n\t\tif (targetItem != null \u0026\u0026 Interface.CallHook(\u0022CanResearchItem\u0022, player, targetItem) == null \u0026\u0026 targetItem.amount \u003C= 1 \u0026\u0026 IsItemResearchable(targetItem))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnItemResearch\u0022, this, targetItem, player);\n\t\t\ttargetItem.CollectedForCrafting(player);\n\t\t\tresearchFinishedTime = UnityEngine.Time.realtimeSinceStartup \u002B researchDuration;\n\t\t\tInvoke(ResearchAttemptFinished, researchDuration);\n\t\t\tbase.inventory.SetLocked(isLocked: true);\n\t\t\tint scrapCost = ScrapForResearch(targetItem);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\tif (researchStartEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t\tmsg.player.GiveAchievement(\u0022RESEARCH_ITEM\u0022);\n\t\t}\n\t}\n",
    "ClassName": "ResearchTable",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnMlrsTargetSet(MLRS mLRS, UnityEngine.Vector3 trueTargetHitPos, BasePlayer _mounted)",
    "MethodSignature": "SetUserTargetHitPos(Vector3 worldPos)",
    "MethodSourseCode": "\n\tpublic void SetUserTargetHitPos(Vector3 worldPos)\n\t{\n\t\tif (UserTargetHitPos == worldPos)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tVector3 position = TerrainMeta.Position;\n\t\t\tVector3 vector = position \u002B TerrainMeta.Size;\n\t\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\n\t\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\n\t\t\tworldPos.y = GetSurfaceHeight(worldPos);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnMlrsTarget\u0022, this, worldPos, _mounted) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tUserTargetHitPos = worldPos;\n\t\tif (base.isServer)\n\t\t{\n\t\t\ttrueTargetHitPos = UserTargetHitPos;\n\t\t\tforeach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)\n\t\t\t{\n\t\t\t\tVector3 center = allSafeZone.triggerCollider.bounds.center;\n\t\t\t\tcenter.y = 0f;\n\t\t\t\tfloat num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) \u002B targetAreaRadius;\n\t\t\t\ttrueTargetHitPos.y = 0f;\n\t\t\t\tif (Vector3.Distance(center, trueTargetHitPos) \u003C num)\n\t\t\t\t{\n\t\t\t\t\tVector3 vector2 = trueTargetHitPos - center;\n\t\t\t\t\ttrueTargetHitPos = center \u002B vector2.normalized * num;\n\t\t\t\t\ttrueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnMlrsTargetSet\u0022, this, trueTargetHitPos, _mounted);\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 38
  },
  {
    "HookSignature": "IOnNpcTarget(BaseNpc baseNpc, BaseEntity target)",
    "MethodSignature": "GetWantsToAttack(BaseEntity target)",
    "MethodSourseCode": "\n\tpublic float GetWantsToAttack(BaseEntity target)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022IOnNpcTarget\u0022, this, target);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\treturn WantsToAttack(target);\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWindmillUpdated(ElectricWindmill electricWindmill)",
    "MethodSignature": "WindUpdate()",
    "MethodSourseCode": "\n\tpublic void WindUpdate()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWindmillUpdate\u0022, this) == null)\n\t\t{\n\t\t\tserverWindSpeed = GetWindSpeedScale();\n\t\t\tif (!AmIVisible())\n\t\t\t{\n\t\t\t\tserverWindSpeed = 0f;\n\t\t\t}\n\t\t\tint num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);\n\t\t\tbool num2 = currentEnergy != num;\n\t\t\tcurrentEnergy = num;\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t\tInterface.CallHook(\u0022OnWindmillUpdated\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ElectricWindmill",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "CanEntityBeHostile(BasePlayer basePlayer)",
    "MethodSignature": "IsHostile()",
    "MethodSourseCode": "\n\tpublic override bool IsHostile()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanEntityBeHostile\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn State.unHostileTimestamp \u003E TimeEx.currentTimestamp;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTrapSnapped(BaseTrapTrigger baseTrapTrigger, UnityEngine.GameObject obj, UnityEngine.Collider col)",
    "MethodSignature": "OnObjectAdded(GameObject obj, Collider col)",
    "MethodSourseCode": "\n\tinternal override void OnObjectAdded(GameObject obj, Collider col)\n\t{\n\t\tInterface.CallHook(\u0022OnTrapSnapped\u0022, this, obj, col);\n\t\tbase.OnObjectAdded(obj, col);\n\t\t_trap.ObjectEntered(obj);\n\t}\n",
    "ClassName": "BaseTrapTrigger",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity ent)",
    "MethodSignature": "VisibilityTest(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic bool VisibilityTest(BaseEntity ent)\n\t{\n\t\tif (ent == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!(Vector3.Distance(ent.transform.position, base.transform.position) \u003C viewDistance))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool flag = false;\n\t\tif (ent is BasePlayer)\n\t\t{\n\t\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\t\tVector3 position = mainTurret.transform.position;\n\t\t\tflag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position \u002B Vector3.up * 0.1f, position);\n\t\t\tif (!flag \u0026\u0026 basePlayer.isMounted \u0026\u0026 basePlayer.GetMounted().VehicleParent() != null \u0026\u0026 basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)\n\t\t\t{\n\t\t\t\tflag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tflag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Standard vis test!\u0022);\n\t\t\tflag = IsVisible(ent.CenterPoint());\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanBradleyApcTarget\u0022, this, ent);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn flag;\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnNpcConversationStart(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor)",
    "MethodSignature": "Server_BeginTalking(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void Server_BeginTalking(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tCleanupConversingPlayers();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor != null)\n\t\t{\n\t\t\tif (conversingPlayers.Contains(player))\n\t\t\t{\n\t\t\t\tOnConversationEnded(player);\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnNpcConversationStart\u0022, this, player, conversationFor) == null)\n\t\t\t{\n\t\t\t\tconversingPlayers.Add(player);\n\t\t\t\tUpdateFlags();\n\t\t\t\tOnConversationStarted(player);\n\t\t\t\tClientRPCPlayer(null, player, \u0022Client_StartConversation\u0022, GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(player));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnSprayRemove(SprayCanSpray sprayCanSpray, BasePlayer player)",
    "MethodSignature": "Server_RequestWaterClear(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tprivate void Server_RequestWaterClear(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 Menu_WaterClear_ShowIf(player) \u0026\u0026 Interface.CallHook(\u0022OnSprayRemove\u0022, this, player) == null)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "SprayCanSpray",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnReactiveTargetReset(ReactiveTarget reactiveTarget)",
    "MethodSignature": "ResetTarget()",
    "MethodSourseCode": "\n\tpublic void ResetTarget()\n\t{\n\t\tif (IsKnockedDown() \u0026\u0026 CanToggle())\n\t\t{\n\t\t\tCancelInvoke(ResetTarget);\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tknockdownHealth = 100f;\n\t\t\tSendPowerBurst();\n\t\t\tInterface.CallHook(\u0022OnReactiveTargetReset\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "ReactiveTarget",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnMissionStart(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionStart(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionStart(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMissionStart\u0022, this, instance, assignee) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetupRewards(instance, assignee);\n\t\tSetupPositions(instance, assignee);\n\t\tAddBlockers(instance);\n\t\tfor (int i = 0; i \u003C objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tobjectives[i].Get().MissionStarted(i, instance);\n\t\t}\n\t\tif (acceptEffect.isValid)\n\t\t{\n\t\t\tDoMissionEffect(acceptEffect.resourcePath, assignee);\n\t\t}\n\t\tMissionEntityEntry[] array = missionEntities;\n\t\tforeach (MissionEntityEntry missionEntityEntry in array)\n\t\t{\n\t\t\tif (missionEntityEntry.entityRef.isValid)\n\t\t\t{\n\t\t\t\tVector3 missionPoint = instance.GetMissionPoint(missionEntityEntry.spawnPositionToUse, assignee);\n\t\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);\n\t\t\t\tMissionEntity missionEntity = baseEntity.gameObject.AddComponent\u003CMissionEntity\u003E();\n\t\t\t\tmissionEntity.Setup(assignee, instance, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);\n\t\t\t\tinstance.createdEntities.Add(missionEntity);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t\tforeach (MissionEntity createdEntity in instance.createdEntities)\n\t\t{\n\t\t\tcreatedEntity.MissionStarted(assignee, instance);\n\t\t}\n\t\tInterface.CallHook(\u0022OnMissionStarted\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVendingShopRename(VendingMachine vendingMachine, string obj, BasePlayer player)",
    "MethodSignature": "RPC_UpdateShopName(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_UpdateShopName(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tstring obj = msg.read.String(32);\n\t\tif (CanPlayerAdmin(player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopRename\u0022, this, obj, player) == null)\n\t\t{\n\t\t\tshopName = obj;\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnFireworkDamage(BaseFirework baseFirework, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tbase.OnAttacked(info);\n\t\tif (base.isServer \u0026\u0026 Interface.CallHook(\u0022OnFireworkDamage\u0022, this, info) == null \u0026\u0026 info.damageTypes.Has(DamageType.Heat))\n\t\t{\n\t\t\tStaggeredTryLightFuse();\n\t\t}\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Hurt(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Hurt(HitInfo info)\n\t{\n\t\tif (IsDead() || (IsImmortalTo(info) \u0026\u0026 info.damageTypes.Total() \u003E= 0f) || Interface.CallHook(\u0022IOnBasePlayerHurt\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.Server.pve \u0026\u0026 (bool)info.Initiator \u0026\u0026 info.Initiator is BasePlayer \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\t(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);\n\t\t\treturn;\n\t\t}\n\t\tif (info.damageTypes.Has(DamageType.Fun_Water))\n\t\t{\n\t\t\tbool flag = true;\n\t\t\tItem activeItem = GetActiveItem();\n\t\t\tif (activeItem != null \u0026\u0026 (activeItem.info.shortname == \u0022gun.water\u0022 || activeItem.info.shortname == \u0022pistol.water\u0022))\n\t\t\t{\n\t\t\t\tfloat value = metabolism.wetness.value;\n\t\t\t\tmetabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);\n\t\t\t\tbool flag2 = metabolism.wetness.value \u003E= ConVar.Server.funWaterDamageThreshold;\n\t\t\t\tflag = !flag2;\n\t\t\t\tif (info.InitiatorPlayer != null)\n\t\t\t\t{\n\t\t\t\t\tif (flag2 \u0026\u0026 value \u003C ConVar.Server.funWaterDamageThreshold)\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_SOAKED\u0022);\n\t\t\t\t\t}\n\t\t\t\t\tif (metabolism.radiation_level.Fraction() \u003E 0.2f \u0026\u0026 !string.IsNullOrEmpty(\u0022SUMMER_RADICAL\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo.InitiatorPlayer.GiveAchievement(\u0022SUMMER_RADICAL\u0022);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\n\t\t\t}\n\t\t}\n\t\tif (info.damageTypes.Get(DamageType.Drowned) \u003E 5f \u0026\u0026 drownEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(drownEffect.resourcePath, this, StringPool.Get(\u0022head\u0022), Vector3.zero, Vector3.zero);\n\t\t}\n\t\tif (modifiers != null)\n\t\t{\n\t\t\tif (info.damageTypes.Has(DamageType.Radiation))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));\n\t\t\t}\n\t\t\tif (info.damageTypes.Has(DamageType.RadiationExposure))\n\t\t\t{\n\t\t\t\tinfo.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));\n\t\t\t}\n\t\t}\n\t\tmetabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);\n\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\tif ((bool)initiatorPlayer \u0026\u0026 initiatorPlayer != this)\n\t\t{\n\t\t\tif (initiatorPlayer.InSafeZone() || InSafeZone())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.MarkHostileFor(300f);\n\t\t\t}\n\t\t\tif (initiatorPlayer.IsNpc \u0026\u0026 initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer \u0026\u0026 info.damageTypes.Get(DamageType.Explosion) \u003E 0f)\n\t\t\t{\n\t\t\t\tinfo.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);\n\t\t\t}\n\t\t}\n\t\tbase.Hurt(info);\n\t\tif ((bool)BaseGameMode.GetActiveGameMode(serverside: true))\n\t\t{\n\t\t\tBasePlayer instigator = info?.InitiatorPlayer;\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);\n\t\t}\n\t\tEACServer.LogPlayerTakeDamage(this, info);\n\t\tmetabolism.SendChangesToClient();\n\t\tif (info.PointStart != Vector3.zero \u0026\u0026 (info.damageTypes.Total() \u003E= 0f || IsGod()))\n\t\t{\n\t\t\tint arg = (int)info.damageTypes.GetMajorityDamageType();\n\t\t\tif (info.Weapon != null \u0026\u0026 info.damageTypes.Has(DamageType.Bullet))\n\t\t\t{\n\t\t\t\tBaseProjectile component = info.Weapon.GetComponent\u003CBaseProjectile\u003E();\n\t\t\t\tif (component != null \u0026\u0026 component.IsSilenced())\n\t\t\t\t{\n\t\t\t\t\targ = 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tClientRPCPlayerAndSpectators(null, this, \u0022DirectionalDamage\u0022, info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));\n\t\t}\n\t\tcachedNonSuicideHitInfo = info;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarksSendControl(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "SendControlBookmarks(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void SendControlBookmarks(BasePlayer player)\n\t{\n\t\tif (!(player == null))\n\t\t{\n\t\t\tstring text = GenerateControlBookmarkString();\n\t\t\tif (Interface.CallHook(\u0022OnBookmarksSendControl\u0022, this, player, text) == null)\n\t\t\t{\n\t\t\t\tClientRPCPlayer(null, player, \u0022ReceiveBookmarks\u0022, text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnTrapTrigger(BearTrap bearTrap, UnityEngine.GameObject obj)",
    "MethodSignature": "ObjectEntered(GameObject obj)",
    "MethodSourseCode": "\n\tpublic override void ObjectEntered(GameObject obj)\n\t{\n\t\tif (Armed() \u0026\u0026 Interface.CallHook(\u0022OnTrapTrigger\u0022, this, obj) == null)\n\t\t{\n\t\t\thurtTarget = obj;\n\t\t\tInvoke(DelayedFire, 0.05f);\n\t\t}\n\t}\n",
    "ClassName": "BearTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcConversationResponded(NPCTalking nPCTalking, BasePlayer player, ConversationData conversationFor, ConversationData.ResponseNode responseNode)",
    "MethodSignature": "Server_ResponsePressed(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void Server_ResponsePressed(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tint num2 = msg.read.Int32();\n\t\tConversationData conversationFor = GetConversationFor(player);\n\t\tif (conversationFor == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\n\t\tif (responseNode != null \u0026\u0026 Interface.CallHook(\u0022OnNpcConversationRespond\u0022, this, player, conversationFor, responseNode) == null)\n\t\t{\n\t\t\tif (responseNode.conditions.Length != 0)\n\t\t\t{\n\t\t\t\tUpdateFlags();\n\t\t\t}\n\t\t\tbool flag = responseNode.PassesConditions(player, this);\n\t\t\tif (flag \u0026\u0026 !string.IsNullOrEmpty(responseNode.actionString))\n\t\t\t{\n\t\t\t\tOnConversationAction(player, responseNode.actionString);\n\t\t\t}\n\t\t\tint speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));\n\t\t\tif (speechNodeIndex == -1)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tForceSpeechNode(player, speechNodeIndex);\n\t\t\tInterface.CallHook(\u0022OnNpcConversationResponded\u0022, this, player, conversationFor, responseNode);\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnPlayerDeath(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "Die(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void Die(HitInfo info = null)\n\t{\n\t\tusing (TimeWarning.New(\u0022Player.Die\u0022))\n\t\t{\n\t\t\tif (!IsDead())\n\t\t\t{\n\t\t\t\tif (Belt != null \u0026\u0026 ShouldDropActiveItem())\n\t\t\t\t{\n\t\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\n\t\t\t\t\tBelt.DropActive(GetDropPosition(), GetInheritedDropVelocity() \u002B vector.normalized * 3f);\n\t\t\t\t}\n\t\t\t\tif (!WoundInsteadOfDying(info) \u0026\u0026 Interface.CallHook(\u0022OnPlayerDeath\u0022, this, info) == null)\n\t\t\t\t{\n\t\t\t\t\tSleepingBag.OnPlayerDeath(this);\n\t\t\t\t\tbase.Die(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance byID, BasePlayer player)",
    "MethodSignature": "RPC_TechTreeUnlock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_TechTreeUnlock(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tTechTreeData.NodeInstance byID = techTree.GetByID(num);\n\t\tif (byID == null)\n\t\t{\n\t\t\tDebug.Log(\u0022Node for unlock not found :\u0022 \u002B num);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!techTree.PlayerCanUnlock(player, byID))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (byID.IsGroup())\n\t\t\t{\n\t\t\t\tforeach (int output in byID.outputs)\n\t\t\t\t{\n\t\t\t\t\tTechTreeData.NodeInstance byID2 = techTree.GetByID(output);\n\t\t\t\t\tif (byID2 != null \u0026\u0026 byID2.itemDef != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayer.blueprints.Unlock(byID2.itemDef);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, \u0022techtree\u0022, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Player unlocked group :\u0022 \u002B byID.groupName);\n\t\t\t}\n\t\t\telse if (byID.itemDef != null \u0026\u0026 Interface.CallHook(\u0022OnTechTreeNodeUnlock\u0022, this, byID, player) == null)\n\t\t\t{\n\t\t\t\tint num2 = ResearchTable.ScrapForResearch(byID.itemDef, ResearchTable.ResearchType.TechTree);\n\t\t\t\tint itemid = ItemManager.FindItemDefinition(\u0022scrap\u0022).itemid;\n\t\t\t\tif (player.inventory.GetAmount(itemid) \u003E= num2)\n\t\t\t\t{\n\t\t\t\t\tplayer.inventory.Take(null, itemid, num2);\n\t\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\n\t\t\t\t\tInterface.CallHook(\u0022OnTechTreeNodeUnlocked\u0022, this, byID, player);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \u0022techtree\u0022, this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnCorpsePopulate(HumanNPC humanNPC, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(\u0022assets/prefabs/npc/scientist/scientist_corpse.prefab\u0022) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\tnPCPlayerCorpse.playerName = OverrideCorpseName();\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tnPCPlayerCorpse.TakeChildren(this);\n\t\t\t\tfor (int i = 0; i \u003C nPCPlayerCorpse.containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer = nPCPlayerCorpse.containers[i];\n\t\t\t\t\tif (i != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\titemContainer.Clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlots.Length; j\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[j];\n\t\t\t\t\t\tfor (int k = 0; k \u003C lootSpawnSlot.numberToSpawn; k\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnPlayerCorpseSpawned(BasePlayer basePlayer, PlayerCorpse playerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic virtual BaseCorpse CreateCorpse()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerCorpseSpawn\u0022, this) != null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring strCorpsePrefab = \u0022assets/prefabs/player/player_corpse.prefab\u0022;\n\t\t\tbool flag = false;\n\t\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t\t{\n\t\t\t\tforeach (Item item in inventory.containerWear.itemList)\n\t\t\t\t{\n\t\t\t\t\tif (item != null \u0026\u0026 item.info.TryGetComponent\u003CItemCorpseOverride\u003E(out var component))\n\t\t\t\t\t{\n\t\t\t\t\t\tstrCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) \u003E 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);\n\t\t\t\t\t\tflag = component.BlockWearableCopy;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab) as PlayerCorpse;\n\t\t\tif ((bool)playerCorpse)\n\t\t\t{\n\t\t\t\tplayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tif (!flag)\n\t\t\t\t{\n\t\t\t\t\tplayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);\n\t\t\t\t}\n\t\t\t\tplayerCorpse.playerName = displayName;\n\t\t\t\tplayerCorpse.playerSteamID = userID;\n\t\t\t\tplayerCorpse.underwearSkin = GetUnderwearSkin();\n\t\t\t\tplayerCorpse.Spawn();\n\t\t\t\tplayerCorpse.TakeChildren(this);\n\t\t\t\tResourceDispenser component2 = playerCorpse.GetComponent\u003CResourceDispenser\u003E();\n\t\t\t\tint num = 2;\n\t\t\t\tif (lifeStory != null)\n\t\t\t\t{\n\t\t\t\t\tnum \u002B= Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);\n\t\t\t\t}\n\t\t\t\tcomponent2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition(\u0022fat.animal\u0022), num));\n\t\t\t\tInterface.CallHook(\u0022OnPlayerCorpseSpawned\u0022, this, playerCorpse);\n\t\t\t\treturn playerCorpse;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t\tstatic float GetFloatBasedOnUserID(ulong steamid, ulong seed)\n\t\t{\n\t\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\t\tUnityEngine.Random.InitState((int)(seed \u002B steamid));\n\t\t\tfloat result = UnityEngine.Random.Range(0f, 1f);\n\t\t\tUnityEngine.Random.state = state;\n\t\t\treturn result;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 43
  },
  {
    "HookSignature": "CanBeTargeted(BaseCombatEntity obj, AutoTurret autoTurret)",
    "MethodSignature": "ObjectVisible(BaseCombatEntity obj)",
    "MethodSourseCode": "\n\tpublic bool ObjectVisible(BaseCombatEntity obj)\n\t{\n\t\tobject obj2 = Interface.CallHook(\u0022CanBeTargeted\u0022, obj, this);\n\t\tif (obj2 is bool)\n\t\t{\n\t\t\treturn (bool)obj2;\n\t\t}\n\t\tList\u003CRaycastHit\u003E obj3 = Facepunch.Pool.GetList\u003CRaycastHit\u003E();\n\t\tVector3 position = eyePos.transform.position;\n\t\tif (GamePhysics.CheckSphere(position, 0.1f, 2097152))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tVector3 vector = AimOffset(obj);\n\t\tfloat num = Vector3.Distance(vector, position);\n\t\tVector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);\n\t\tfor (int i = 0; (float)i \u003C (CheckPeekers() ? 3f : 1f); i\u002B\u002B)\n\t\t{\n\t\t\tVector3 normalized = (vector \u002B vector2 * visibilityOffsets[i] - position).normalized;\n\t\t\tobj3.Clear();\n\t\t\tGamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);\n\t\t\tfor (int j = 0; j \u003C obj3.Count; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tBaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);\n\t\t\t\tif ((!(entity != null) || !entity.isClient) \u0026\u0026 (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) \u0026\u0026 (!(entity != null) || !entity.EqualNetID(this)))\n\t\t\t\t{\n\t\t\t\t\tif (entity != null \u0026\u0026 (entity == obj || entity.EqualNetID(obj)))\n\t\t\t\t\t{\n\t\t\t\t\t\tFacepunch.Pool.FreeList(ref obj3);\n\t\t\t\t\t\tpeekIndex = i;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(entity != null) || entity.ShouldBlockProjectiles())\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj3);\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemCraftFinished(ItemCraftTask task, Item item)",
    "MethodSignature": "FinishCrafting(ItemCraftTask task)",
    "MethodSourseCode": "\n\tpublic void FinishCrafting(ItemCraftTask task)\n\t{\n\t\ttask.amount--;\n\t\ttask.numCrafted\u002B\u002B;\n\t\tulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);\n\t\tItem item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);\n\t\titem.amount = task.blueprint.amountToCreate;\n\t\tint amount = item.amount;\n\t\t_ = task.owner.currentCraftLevel;\n\t\tbool inSafezone = task.owner.InSafeZone();\n\t\tif (item.hasCondition \u0026\u0026 task.conditionScale != 1f)\n\t\t{\n\t\t\titem.maxCondition *= task.conditionScale;\n\t\t\titem.condition = item.maxCondition;\n\t\t}\n\t\titem.OnVirginSpawn();\n\t\tforeach (ItemAmount ingredient in task.blueprint.ingredients)\n\t\t{\n\t\t\tint num = (int)ingredient.amount;\n\t\t\tif (task.takenItems == null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforeach (Item takenItem in task.takenItems)\n\t\t\t{\n\t\t\t\tif (takenItem.info == ingredient.itemDef)\n\t\t\t\t{\n\t\t\t\t\tint num2 = Mathf.Min(takenItem.amount, num);\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item.info.shortname);\n\t\t\t\t\ttakenItem.UseItem(num);\n\t\t\t\t\tnum -= num2;\n\t\t\t\t}\n\t\t\t\t_ = 0;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);\n\t\tFacepunch.Rust.Analytics.Azure.OnCraftItem(item.info.shortname, item.amount, base.baseEntity, task.workbenchEntity, inSafezone);\n\t\ttask.owner.Command(\u0022note.craft_done\u0022, task.taskUID, 1, task.amount);\n\t\tInterface.CallHook(\u0022OnItemCraftFinished\u0022, task, item);\n\t\tif (task.instanceData != null)\n\t\t{\n\t\t\titem.instanceData = task.instanceData;\n\t\t}\n\t\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\n\t\t{\n\t\t\ttask.owner.GiveAchievement(task.blueprint.UnlockAchievment);\n\t\t}\n\t\tif (task.owner.inventory.GiveItem(item))\n\t\t{\n\t\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, amount);\n\t\t\treturn;\n\t\t}\n\t\tItemContainer itemContainer = containers.First();\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, amount);\n\t\ttask.owner.Command(\u0022note.inv\u0022, item.info.itemid, -item.amount);\n\t\titem.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnBradleyApcPatrol(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Patrol()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Patrol()\n\t{\n\t\tif (patrolPath == null || UnityEngine.Time.time \u003C nextPatrolTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextPatrolTime = UnityEngine.Time.time \u002B 20f;\n\t\tif ((HasPath() \u0026\u0026 !IsAtFinalDestination()) || Interface.CallHook(\u0022OnBradleyApcPatrol\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);\n\t\tIAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\n\t\tbool flag = false;\n\t\tList\u003CIAIPathNode\u003E nodes = Facepunch.Pool.GetList\u003CIAIPathNode\u003E();\n\t\tIAIPathNode iAIPathNode;\n\t\tif (GetEngagementPath(ref nodes))\n\t\t{\n\t\t\tflag = true;\n\t\t\tiAIPathNode = nodes[nodes.Count - 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tiAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t}\n\t\tif (!(Vector3.Distance(finalDestination, closestToPoint.Position) \u003E 2f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (closestToPoint == iAIPathNode)\n\t\t{\n\t\t\tcurrentPath.Clear();\n\t\t\tcurrentPath.Add(closestToPoint.Position);\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.Position;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcurrentPath.Clear();\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(nodes[i].Position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (IAIPathNode item in path)\n\t\t\t{\n\t\t\t\tcurrentPath.Add(item.Position);\n\t\t\t}\n\t\t\tcurrentPathIndex = -1;\n\t\t\tpathLooping = false;\n\t\t\tfinalDestination = closestToPoint.Position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "CanAccessVendingMachine(DeliveryDroneConfig config, VendingMachine vendingMachine)",
    "MethodSignature": "GetDeliveryEligibleVendingMachines(List\u003CNetworkableId\u003E vendingMachineIds)",
    "MethodSourseCode": "\n\tpublic void GetDeliveryEligibleVendingMachines(List\u003CNetworkableId\u003E vendingMachineIds)\n\t{\n\t\tif ((float)_deliveryEligibleLastCalculated \u003C 5f)\n\t\t{\n\t\t\tif (vendingMachineIds == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t{\n\t\t\t\tforeach (NetworkableId item in _deliveryEligible)\n\t\t\t\t{\n\t\t\t\t\tvendingMachineIds.Add(item);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_deliveryEligibleLastCalculated = 0f;\n\t\t_deliveryEligible.Clear();\n\t\tforeach (MapMarker serverMapMarker in MapMarker.serverMapMarkers)\n\t\t{\n\t\t\tif (serverMapMarker is VendingMachineMapMarker vendingMachineMapMarker \u0026\u0026 !(vendingMachineMapMarker.server_vendingMachine == null))\n\t\t\t{\n\t\t\t\tVendingMachine server_vendingMachine = vendingMachineMapMarker.server_vendingMachine;\n\t\t\t\tif (!(server_vendingMachine == null) \u0026\u0026 (IsEligible(server_vendingMachine, config.vendingMachineOffset, 1) || IsEligible(server_vendingMachine, config.vendingMachineOffset \u002B Vector3.forward * config.maxDistanceFromVendingMachine, 2)))\n\t\t\t\t{\n\t\t\t\t\t_deliveryEligible.Add(server_vendingMachine.net.ID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vendingMachineIds == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (NetworkableId item2 in _deliveryEligible)\n\t\t{\n\t\t\tvendingMachineIds.Add(item2);\n\t\t}\n\t\tbool IsEligible(VendingMachine vendingMachine, Vector3 offset, int n)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022CanAccessVendingMachine\u0022, config, vendingMachine);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\tif (vendingMachine is NPCVendingMachine)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!vendingMachine.IsBroadcasting())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!config.IsVendingMachineAccessible(vendingMachine, offset, out var _))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n",
    "ClassName": "MarketTerminal",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "OnConversationAction(BasePlayer player, string action)",
    "MethodSourseCode": "\n\tpublic virtual void OnConversationAction(BasePlayer player, string action)\n\t{\n\t\tif (action == \u0022openvending\u0022)\n\t\t{\n\t\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\n\t\t\tif (vendingMachine != null \u0026\u0026 Vector3.Distance(player.transform.position, base.transform.position) \u003C 5f)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, player) == null)\n\t\t\t\t{\n\t\t\t\t\tvendingMachine.PlayerOpenLoot(player, \u0022vendingmachine.customer\u0022, doPositionChecks: false);\n\t\t\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, player);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\u0022scrap\u0022);\n\t\tNPCConversationResultAction[] array = conversationResultActions;\n\t\tforeach (NPCConversationResultAction nPCConversationResultAction in array)\n\t\t{\n\t\t\tif (!(nPCConversationResultAction.action == action))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCleanupConversingPlayers();\n\t\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\n\t\t\t{\n\t\t\t\tif (!(conversingPlayer == player) \u0026\u0026 !(conversingPlayer == null))\n\t\t\t\t{\n\t\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\u0022startbusy\u0022);\n\t\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = nPCConversationResultAction.scrapCost;\n\t\t\tList\u003CItem\u003E list = player.inventory.FindItemIDs(itemDefinition.itemid);\n\t\t\tforeach (Item item in list)\n\t\t\t{\n\t\t\t\tnum -= item.amount;\n\t\t\t}\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\u0022toopoor\u0022);\n\t\t\t\tForceSpeechNode(player, speechNodeIndex2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\n\t\t\tnum = nPCConversationResultAction.scrapCost;\n\t\t\tforeach (Item item2 in list)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Min(num, item2.amount);\n\t\t\t\titem2.UseItem(num2);\n\t\t\t\tnum -= num2;\n\t\t\t\tif (num \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastActionPlayer = player;\n\t\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\n\t\t\tlastActionPlayer = null;\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnConveyorFiltersChange(IndustrialConveyor industrialConveyor, BasePlayer msgPlayer, ProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList)",
    "MethodSignature": "RPC_ChangeFilters(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tprivate void RPC_ChangeFilters(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tmode = (ConveyorMode)msg.read.Int32();\n\t\tfilterItems.Clear();\n\t\tProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = ProtoBuf.IndustrialConveyor.ItemFilterList.Deserialize(msg.read);\n\t\tif (itemFilterList.filters == null || Interface.CallHook(\u0022OnConveyorFiltersChange\u0022, this, msg.player, itemFilterList) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Mathf.Min(itemFilterList.filters.Count, 24);\n\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\n\t\t{\n\t\t\tif (filterItems.Count \u003E= 12)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tItemFilter item = new ItemFilter(itemFilterList.filters[i]);\n\t\t\tif (item.TargetItem != null || item.TargetCategory.HasValue)\n\t\t\t{\n\t\t\t\tfilterItems.Add(item);\n\t\t\t}\n\t\t}\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "IndustrialConveyor",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnMapMarkerAdd(BasePlayer basePlayer, ProtoBuf.MapNote MapNoteDeserialize)",
    "MethodSignature": "Server_AddMarker(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(8uL)]\n\tpublic void Server_AddMarker(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkerAdd\u0022, this, MapNote.Deserialize(msg.read)) == null)\n\t\t{\n\t\t\tmsg.read.Position = 13L;\n\t\t\tif (State.pointsOfInterest == null)\n\t\t\t{\n\t\t\t\tState.pointsOfInterest = Facepunch.Pool.GetList\u003CMapNote\u003E();\n\t\t\t}\n\t\t\tif (State.pointsOfInterest.Count \u003E= ConVar.Server.maximumMapMarkers)\n\t\t\t{\n\t\t\t\tmsg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMapNote mapNote = MapNote.Deserialize(msg.read);\n\t\t\tValidateMapNote(mapNote);\n\t\t\tmapNote.colourIndex = State.pointsOfInterest.Count;\n\t\t\tState.pointsOfInterest.Add(mapNote);\n\t\t\tDirtyPlayerState();\n\t\t\tSendMarkersToClient();\n\t\t\tTeamUpdate();\n\t\t\tInterface.CallHook(\u0022OnMapMarkerAdded\u0022, this, mapNote);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnExcavatorGather(ExcavatorArm excavatorArm, Item item)",
    "MethodSignature": "ProduceResources()",
    "MethodSourseCode": "\n\tpublic void ProduceResources()\n\t{\n\t\tfloat num = resourceProductionTickRate / timeForFullResources;\n\t\tfloat num2 = resourcesToMine[resourceMiningIndex].amount * num;\n\t\tpendingResources[resourceMiningIndex].amount \u002B= num2;\n\t\tItemAmount[] array = pendingResources;\n\t\tforeach (ItemAmount itemAmount in array)\n\t\t{\n\t\t\tif (!(itemAmount.amount \u003E= (float)outputPiles.Count))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);\n\t\t\titemAmount.amount -= num3 * 2;\n\t\t\tforeach (ExcavatorOutputPile outputPile in outputPiles)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);\n\t\t\t\tif (Interface.CallHook(\u0022OnExcavatorGather\u0022, this, item) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\n\t\t\t\tif (!item.MoveToContainer(outputPile.inventory))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnPlayerSpectateEnd(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StopSpectating()",
    "MethodSourseCode": "\n\tpublic void StopSpectating()\n\t{\n\t\tif (IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectateEnd\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetParent(null);\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: false);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanHackCrate(BasePlayer msgPlayer, HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "RPC_Hack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Hack(RPCMessage msg)\n\t{\n\t\tif (!IsBeingHacked() \u0026\u0026 Interface.CallHook(\u0022CanHackCrate\u0022, msg.player, this) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\n\t\t\tOriginalHackerPlayer = msg.player.userID;\n\t\t\tStartHacking();\n\t\t}\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcDuck(HumanNPC humanNPC)",
    "MethodSignature": "SetDucked(bool flag)",
    "MethodSourseCode": "\n\tpublic void SetDucked(bool flag)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcDuck\u0022, this) == null)\n\t\t{\n\t\t\tmodelState.ducked = flag;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "HumanNPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPayForUpgrade(BasePlayer player, BuildingBlock buildingBlock, ConstructionGrade g)",
    "MethodSignature": "PayForUpgrade(ConstructionGrade g, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void PayForUpgrade(ConstructionGrade g, BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPayForUpgrade\u0022, player, this, g) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItem\u003E list = new List\u003CItem\u003E();\n\t\tforeach (ItemAmount item in g.costToBuild)\n\t\t{\n\t\t\tplayer.inventory.Take(list, item.itemid, (int)item.amount);\n\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);\n\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022upgrade_block\u0022, itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);\n\t\t\tplayer.Command(\u0022note.inv \u0022 \u002B item.itemid \u002B \u0022 \u0022 \u002B item.amount * -1f);\n\t\t}\n\t\tforeach (Item item2 in list)\n\t\t{\n\t\t\titem2.Remove();\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSignature": "AddViolation(BasePlayer ply, AntiHackType type, float amount)",
    "MethodSourseCode": "\n\tpublic static void AddViolation(BasePlayer ply, AntiHackType type, float amount)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerViolation\u0022, ply, type, amount) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022AntiHack.AddViolation\u0022))\n\t\t{\n\t\t\tply.lastViolationType = type;\n\t\t\tply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\tply.violationLevel \u002B= amount;\n\t\t\tif ((ConVar.AntiHack.debuglevel \u003E= 2 \u0026\u0026 amount \u003E 0f) || (ConVar.AntiHack.debuglevel \u003E= 3 \u0026\u0026 type != AntiHackType.NoClip) || ConVar.AntiHack.debuglevel \u003E= 4)\n\t\t\t{\n\t\t\t\tLogToConsole(ply, type, \u0022Added violation of \u0022 \u002B amount \u002B \u0022 in frame \u0022 \u002B UnityEngine.Time.frameCount \u002B \u0022 (now has \u0022 \u002B ply.violationLevel \u002B \u0022)\u0022);\n\t\t\t}\n\t\t\tEnforceViolations(ply);\n\t\t}\n\t}\n",
    "ClassName": "AntiHack",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureRepair(BaseCombatEntity baseCombatEntity, BasePlayer player)",
    "MethodSignature": "DoRepair(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void DoRepair(BasePlayer player)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tif (!repair.enabled || Interface.CallHook(\u0022OnStructureRepair\u0022, this, player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = 30f;\n\t\tif (SecondsSinceAttacked \u003C= num)\n\t\t{\n\t\t\tOnRepairFailed(player2, $\u0022Unable to repair: Recently damaged. Repairable in: {num - SecondsSinceAttacked:N0}s.\u0022);\n\t\t\treturn;\n\t\t}\n\t\tfloat num2 = MaxHealth() - Health();\n\t\tfloat num3 = num2 / MaxHealth();\n\t\tif (num2 \u003C= 0f || num3 \u003C= 0f)\n\t\t{\n\t\t\tOnRepairFailed(player2, \u0022Unable to repair: Not damaged.\u0022);\n\t\t\treturn;\n\t\t}\n\t\tList\u003CItemAmount\u003E list = RepairCost(num3);\n\t\tif (list == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num4 = list.Sum((ItemAmount x) =\u003E x.amount);\n\t\tfloat healthBefore = health;\n\t\tif (num4 \u003E 0f)\n\t\t{\n\t\t\tfloat num5 = list.Min((ItemAmount x) =\u003E Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));\n\t\t\tif (float.IsNaN(num5))\n\t\t\t{\n\t\t\t\tnum5 = 0f;\n\t\t\t}\n\t\t\tnum5 = Mathf.Min(num5, 50f / num2);\n\t\t\tif (num5 \u003C= 0f)\n\t\t\t{\n\t\t\t\tOnRepairFailedResources(player2, list);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint num6 = 0;\n\t\t\tforeach (ItemAmount item in list)\n\t\t\t{\n\t\t\t\tint amount = Mathf.CeilToInt(num5 * item.amount);\n\t\t\t\tint num7 = player2.inventory.Take(null, item.itemid, amount);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022repair_entity\u0022, item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);\n\t\t\t\tif (num7 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tnum6 \u002B= num7;\n\t\t\t\t\tplayer2.Command(\u0022note.inv\u0022, item.itemid, num7 * -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat num8 = (float)num6 / num4;\n\t\t\thealth \u002B= num2 * num8;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\thealth \u002B= num2;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);\n\t\tif (Health() \u003E= MaxHealth())\n\t\t{\n\t\t\tOnRepairFinished();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOnRepair();\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEventTrigger(TriggeredEventPrefab triggeredEventPrefab)",
    "MethodSignature": "RunEvent()",
    "MethodSourseCode": "\n\tprivate void RunEvent()\n\t{\n\t\tif (Interface.CallHook(\u0022OnEventTrigger\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDebug.Log(\u0022[event] \u0022 \u002B targetPrefab.resourcePath);\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);\n\t\tif (!baseEntity)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity.SendMessage(\u0022TriggeredEventSpawn\u0022, SendMessageOptions.DontRequireReceiver);\n\t\tbaseEntity.Spawn();\n\t\tif (!shouldBroadcastSpawn)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t{\n\t\t\tif ((bool)activePlayer \u0026\u0026 activePlayer.IsConnected)\n\t\t\t{\n\t\t\t\tactivePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "TriggeredEventPrefab",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLootSpawn(LootContainer lootContainer)",
    "MethodSignature": "SpawnLoot()",
    "MethodSourseCode": "\n\tpublic virtual void SpawnLoot()\n\t{\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\tDebug.Log(\u0022CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tbase.inventory.Clear();\n\t\tItemManager.DoRemoves();\n\t\tif (Interface.CallHook(\u0022OnLootSpawn\u0022, this) == null)\n\t\t{\n\t\t\tPopulateLoot();\n\t\t\tif (shouldRefreshContents)\n\t\t\t{\n\t\t\t\tInvoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LootContainer",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanBeAwardedAdventGift(AdventCalendar adventCalendar, BasePlayer player)",
    "MethodSignature": "WasAwardedTodaysGift(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool WasAwardedTodaysGift(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeAwardedAdventGift\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn !(bool)obj;\n\t\t}\n\t\tif (!playerRewardHistory.ContainsKey(player.userID))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tDateTime now = DateTime.Now;\n\t\tif (now.Month != startMonth)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tint num = now.Day - startDay;\n\t\tif (num \u003C 0 || num \u003E= days.Length)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (playerRewardHistory[player.userID].Contains(num))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "AdventCalendar",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSleepingBagDestroy(SleepingBag sleepingBag2, BasePlayer player)",
    "MethodSignature": "DestroyBag(BasePlayer player, NetworkableId sleepingBag)",
    "MethodSourseCode": "\n\tpublic static bool DestroyBag(BasePlayer player, NetworkableId sleepingBag)\n\t{\n\t\tSleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);\n\t\tif (sleepingBag2 == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnSleepingBagDestroy\u0022, sleepingBag2, player) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (sleepingBag2.canBePublic)\n\t\t{\n\t\t\tsleepingBag2.SetPublic(isPublic: true);\n\t\t\tsleepingBag2.deployerUserID = 0uL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsleepingBag2.Kill();\n\t\t}\n\t\tplayer.SendRespawnOptions();\n\t\tInterface.CallHook(\u0022OnSleepingBagDestroyed\u0022, sleepingBag2, player);\n\t\treturn true;\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnIORefCleared(IOEntity.IORef iOEntity.IORef, IOEntity obj)",
    "MethodSignature": "Clear()",
    "MethodSourseCode": "\n\t\tpublic void Clear()\n\t\t{\n\t\t\tIOEntity obj = ioEnt;\n\t\t\tioEnt = null;\n\t\t\tentityRef.Set(null);\n\t\t\tInterface.CallHook(\u0022OnIORefCleared\u0022, this, obj);\n\t\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanPurchaseItem(BasePlayer buyer, Item item2, System.Action\u003CBasePlayer, Item\u003E onItemPurchased, VendingMachine vendingMachine, ItemContainer targetContainer)",
    "MethodSignature": "DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved, Action\u003CBasePlayer, Item\u003E onItemPurchased, MarketTerminal droneMarketTerminal)",
    "MethodSourseCode": "\n\tpublic bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action\u003CBasePlayer, Item\u003E onCurrencyRemoved = null, Action\u003CBasePlayer, Item\u003E onItemPurchased = null, MarketTerminal droneMarketTerminal = null)\n\t{\n\t\tif (sellOrderId \u003C 0 || sellOrderId \u003E= sellOrders.sellOrders.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (targetContainer == null \u0026\u0026 Vector3.Distance(buyer.transform.position, base.transform.position) \u003E 4f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnVendingTransaction\u0022, this, buyer, sellOrderId, numberOfTransactions, targetContainer);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];\n\t\tList\u003CItem\u003E obj2 = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\tGetItemsToSell(sellOrder, obj2);\n\t\tif (obj2 == null || obj2.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tnumberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);\n\t\tint num = sellOrder.itemToSellAmount * numberOfTransactions;\n\t\tint num2 = obj2.Sum((Item x) =\u003E x.amount);\n\t\tif (num \u003E num2)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tList\u003CItem\u003E source = buyer.inventory.FindItemIDs(sellOrder.currencyID);\n\t\tif (sellOrder.currencyIsBP)\n\t\t{\n\t\t\tsource = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)\n\t\t\t\twhere x.blueprintTarget == sellOrder.currencyID\n\t\t\t\tselect x).ToList();\n\t\t}\n\t\tsource = source.Where((Item x) =\u003E !x.hasCondition || (x.conditionNormalized \u003E= 0.5f \u0026\u0026 x.maxConditionNormalized \u003E 0.5f)).ToList();\n\t\tif (source.Count == 0)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\tint num3 = source.Sum((Item x) =\u003E x.amount);\n\t\tint num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;\n\t\tif (num3 \u003C num4)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn false;\n\t\t}\n\t\ttransactionActive = true;\n\t\tint num5 = 0;\n\t\tforeach (Item item3 in source)\n\t\t{\n\t\t\tint num6 = Mathf.Min(num4 - num5, item3.amount);\n\t\t\tItem item = ((item3.amount \u003E num6) ? item3.SplitItem(num6) : item3);\n\t\t\tTakeCurrencyItem(item);\n\t\t\tonCurrencyRemoved?.Invoke(buyer, item);\n\t\t\tnum5 \u002B= num6;\n\t\t\tif (num5 \u003E= num4)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem * numberOfTransactions, sellOrder.currencyIsBP, numberOfTransactions, droneMarketTerminal);\n\t\tint num7 = 0;\n\t\tforeach (Item item4 in obj2)\n\t\t{\n\t\t\tint num8 = num - num7;\n\t\t\tItem item2 = ((item4.amount \u003E num8) ? item4.SplitItem(num8) : item4);\n\t\t\tif (item2 == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022Vending machine error, contact developers!\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum7 \u002B= item2.amount;\n\t\t\t\tobject obj3 = Interface.CallHook(\u0022CanPurchaseItem\u0022, buyer, item2, onItemPurchased, this, targetContainer);\n\t\t\t\tif (obj3 is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj3;\n\t\t\t\t}\n\t\t\t\tRecordSaleAnalytics(item2);\n\t\t\t\tif (targetContainer == null)\n\t\t\t\t{\n\t\t\t\t\tGiveSoldItem(item2, buyer);\n\t\t\t\t}\n\t\t\t\telse if (!item2.MoveToContainer(targetContainer))\n\t\t\t\t{\n\t\t\t\t\titem2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);\n\t\t\t\t}\n\t\t\t\tonItemPurchased?.Invoke(buyer, item2);\n\t\t\t}\n\t\t\tif (num7 \u003E= num)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\tUpdateEmptyFlag();\n\t\ttransactionActive = false;\n\t\treturn true;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 79
  },
  {
    "HookSignature": "CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight)",
    "MethodSignature": "SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight, bool sendImmediate)",
    "MethodSourseCode": "\n\tpublic void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)\n\t{\n\t\tif (!contacts)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tulong userID = player.userID;\n\t\tulong userID2 = otherPlayer.userID;\n\t\tif (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null \u0026\u0026 otherPlayer.IsNpc) || Interface.CallHook(\u0022CanSetRelationship\u0022, player, otherPlayer, type, weight) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerRelationships playerRelationships = GetRelationships(userID);\n\t\tif (!CleanupOldContacts(playerRelationships, userID))\n\t\t{\n\t\t\tCleanupOldContacts(playerRelationships, userID, RelationshipType.Enemy);\n\t\t}\n\t\tPlayerRelationshipInfo relations = playerRelationships.GetRelations(userID2);\n\t\tbool flag = false;\n\t\tif (relations.type != type)\n\t\t{\n\t\t\tflag = true;\n\t\t\trelations.weight = 0;\n\t\t}\n\t\trelations.type = type;\n\t\trelations.weight \u002B= weight;\n\t\tfloat num = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;\n\t\tif (flag || relations.mugshotCrc == 0 || num \u003E= mugshotUpdateInterval)\n\t\t{\n\t\t\tbool flag2 = otherPlayer.IsAlive();\n\t\t\tbool num2 = player.SecondsSinceAttacked \u003E 10f \u0026\u0026 !player.IsAiming;\n\t\t\tfloat num3 = 100f;\n\t\t\tif (num2)\n\t\t\t{\n\t\t\t\tVector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;\n\t\t\t\tbool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) \u003E= 0.6f;\n\t\t\t\tfloat num4 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);\n\t\t\t\tif (flag2 \u0026\u0026 num4 \u003C num3 \u0026\u0026 flag3)\n\t\t\t\t{\n\t\t\t\t\tClientRPCPlayer(null, player, \u0022CLIENT_DoMugshot\u0022, userID2);\n\t\t\t\t\trelations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sendImmediate)\n\t\t{\n\t\t\tSendRelationshipsFor(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMarkRelationshipsDirtyFor(player);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTeamPromote(RelationshipManager.PlayerTeam playerTeam, BasePlayer lookingAtPlayer)",
    "MethodSignature": "promote(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void promote(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);\n\t\tif (!(lookingAtPlayer == null) \u0026\u0026 !lookingAtPlayer.IsDead() \u0026\u0026 !(lookingAtPlayer == basePlayer) \u0026\u0026 lookingAtPlayer.currentTeam == basePlayer.currentTeam)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];\n\t\t\tif (playerTeam != null \u0026\u0026 playerTeam.teamLeader == basePlayer.userID \u0026\u0026 Interface.CallHook(\u0022OnTeamPromote\u0022, playerTeam, lookingAtPlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.SetTeamLeader(lookingAtPlayer.userID);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnActiveItemChange(BasePlayer basePlayer, Item activeItem, ItemId itemID)",
    "MethodSignature": "UpdateActiveItem(ItemId itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(ItemId itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = default(ItemId);\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t\tNotifyGesturesNewItemEquipped();\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer)",
    "MethodSignature": "acceptinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void acceptinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamAcceptInvite\u0022, playerTeam, basePlayer) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.AcceptInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFReceiver rFReceiver, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild())\n\t\t{\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tMarkDirty();\n\t\t\t\tSendNetworkUpdate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFReceiver",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnNetworkSubscriptionsGather(NetworkVisibilityGrid networkVisibilityGrid, Network.Visibility.Group group, System.Collections.Generic.List\u003CNetwork.Visibility.Group\u003E groups, int radius)",
    "MethodSignature": "GetVisibleFrom(Group group, List\u003CGroup\u003E groups, int radius)",
    "MethodSourseCode": "\n\tprivate void GetVisibleFrom(Group group, List\u003CGroup\u003E groups, int radius)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNetworkSubscriptionsGather\u0022, this, group, groups, radius) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CGroup\u003E groups2 = groups;\n\t\tgroups2.Add(Network.Net.sv.visibility.Get(0u));\n\t\tint iD = (int)group.ID;\n\t\tif (iD \u003C startID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tvar (num, num2, groupLayer2) = DeconstructGroupId(iD);\n\t\tAddLayers(num, num2, groupLayer2);\n\t\tfor (int i = 1; i \u003C= radius; i\u002B\u002B)\n\t\t{\n\t\t\tAddLayers(num - i, num2, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2, groupLayer2);\n\t\t\tAddLayers(num, num2 - i, groupLayer2);\n\t\t\tAddLayers(num, num2 \u002B i, groupLayer2);\n\t\t\tfor (int j = 1; j \u003C i; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tAddLayers(num - i, num2 - j, groupLayer2);\n\t\t\t\tAddLayers(num - i, num2 \u002B j, groupLayer2);\n\t\t\t\tAddLayers(num \u002B i, num2 - j, groupLayer2);\n\t\t\t\tAddLayers(num \u002B i, num2 \u002B j, groupLayer2);\n\t\t\t\tAddLayers(num - j, num2 - i, groupLayer2);\n\t\t\t\tAddLayers(num \u002B j, num2 - i, groupLayer2);\n\t\t\t\tAddLayers(num - j, num2 \u002B i, groupLayer2);\n\t\t\t\tAddLayers(num \u002B j, num2 \u002B i, groupLayer2);\n\t\t\t}\n\t\t\tAddLayers(num - i, num2 - i, groupLayer2);\n\t\t\tAddLayers(num - i, num2 \u002B i, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2 - i, groupLayer2);\n\t\t\tAddLayers(num \u002B i, num2 \u002B i, groupLayer2);\n\t\t}\n\t\tvoid Add(int groupX, int groupY, int groupLayer)\n\t\t{\n\t\t\tgroups2.Add(Network.Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));\n\t\t}\n\t\tvoid AddLayers(int groupX, int groupY, int groupLayer)\n\t\t{\n\t\t\tAdd(groupX, groupY, groupLayer);\n\t\t\tif (groupLayer == 0)\n\t\t\t{\n\t\t\t\tAdd(groupX, groupY, 1);\n\t\t\t}\n\t\t\tif (groupLayer == 1)\n\t\t\t{\n\t\t\t\tAdd(groupX, groupY, 2);\n\t\t\t\tAdd(groupX, groupY, 0);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "NetworkVisibilityGrid",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretAuthorize(AutoTurret autoTurret, BasePlayer player)",
    "MethodSignature": "AddSelfAuthorize(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void AddSelfAuthorize(BasePlayer player)\n\t{\n\t\tBasePlayer player2 = player;\n\t\tif (!IsOnline() \u0026\u0026 player2.CanBuild() \u0026\u0026 !AtMaxAuthCapacity() \u0026\u0026 Interface.CallHook(\u0022OnTurretAuthorize\u0022, this, player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.RemoveAll((PlayerNameID x) =\u003E x.userid == player2.userID);\n\t\t\tPlayerNameID playerNameID = new PlayerNameID();\n\t\t\tplayerNameID.userid = player2.userID;\n\t\t\tplayerNameID.username = player2.displayName;\n\t\t\tauthorizedPlayers.Add(playerNameID);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022added\u0022, player2.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnItemPickup(Item thisItem, BasePlayer msgPlayer)",
    "MethodSignature": "Pickup(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Pickup(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 this.item != null \u0026\u0026 allowPickup \u0026\u0026 Interface.CallHook(\u0022OnItemPickup\u0022, this.item, msg.player) == null)\n\t\t{\n\t\t\tClientRPC(null, \u0022PickupSound\u0022);\n\t\t\tItem item = this.item;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);\n\t\t\tRemoveItem();\n\t\t\tmsg.player.GiveItem(item, GiveItemReason.PickedUp);\n\t\t\tmsg.player.SignalBroadcast(Signal.Gesture, \u0022pickup_item\u0022);\n\t\t}\n\t}\n",
    "ClassName": "WorldItem",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnVehicleModuleMove(BaseVehicleModule moduleForItem, BaseModularVehicle baseModularVehicle, BasePlayer player)",
    "MethodSignature": "CanMoveFrom(BasePlayer player, Item item)",
    "MethodSourseCode": "\n\tpublic bool CanMoveFrom(BasePlayer player, Item item)\n\t{\n\t\tBaseVehicleModule moduleForItem = GetModuleForItem(item);\n\t\tif (moduleForItem != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnVehicleModuleMove\u0022, moduleForItem, this, player);\n\t\t\tif (obj != null)\n\t\t\t{\n\t\t\t\tif (!(obj is bool))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\treturn moduleForItem.CanBeMovedNow();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseModularVehicle",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnConnectionQueue(Network.Connection connection)",
    "MethodSignature": "Join(Connection connection)",
    "MethodSourseCode": "\n\tinternal void Join(Connection connection)\n\t{\n\t\tif (Interface.CallHook(\u0022OnConnectionQueue\u0022, connection) == null)\n\t\t{\n\t\t\tconnection.state = Connection.State.InQueue;\n\t\t\tqueue.Add(connection);\n\t\t\tnextMessageTime = 0f;\n\t\t\tif (CanJumpQueue(connection))\n\t\t\t{\n\t\t\t\tJoinGame(connection);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerRevive(BasePlayer getOwnerPlayer, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\n\t\tItemModConsumable component = ownerItemDefinition.GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\n\t\t\tif (player != ownerPlayer)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t\t{\n\t\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player is BasePet)\n\t\t\t{\n\t\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "CanUseFuel(EntityFuelSystem entityFuelSystem, StorageContainer fuelContainer, float seconds, float fuelUsedPerSecond)",
    "MethodSignature": "TryUseFuel(float seconds, float fuelUsedPerSecond)",
    "MethodSourseCode": "\n\tpublic int TryUseFuel(float seconds, float fuelUsedPerSecond)\n\t{\n\t\tStorageContainer fuelContainer = GetFuelContainer();\n\t\tobject obj = Interface.CallHook(\u0022CanUseFuel\u0022, this, fuelContainer, seconds, fuelUsedPerSecond);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\tif (fuelContainer == null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tItem slot = fuelContainer.inventory.GetSlot(0);\n\t\tif (slot == null || slot.amount \u003C 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tpendingFuel \u002B= seconds * fuelUsedPerSecond;\n\t\tif (pendingFuel \u003E= 1f)\n\t\t{\n\t\t\tint num = Mathf.FloorToInt(pendingFuel);\n\t\t\tslot.UseItem(num);\n\t\t\tFacepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, \u0022fuel_system\u0022);\n\t\t\tpendingFuel -= num;\n\t\t\treturn num;\n\t\t}\n\t\treturn 0;\n\t}\n",
    "ClassName": "EntityFuelSystem",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEngineStarted(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnItemSubmit(Item slot, Mailbox mailbox, BasePlayer fromPlayer)",
    "MethodSignature": "SubmitInputItems(BasePlayer fromPlayer)",
    "MethodSourseCode": "\n\tpublic void SubmitInputItems(BasePlayer fromPlayer)\n\t{\n\t\tItem slot = base.inventory.GetSlot(mailInputSlot);\n\t\tif (IsFull() || slot == null || Interface.CallHook(\u0022OnItemSubmit\u0022, slot, this, fromPlayer) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (MoveItemToStorage(slot))\n\t\t{\n\t\t\tif (slot.position != mailInputSlot)\n\t\t\t{\n\t\t\t\tEffect.server.Run(mailDropSound.resourcePath, GetDropPosition());\n\t\t\t\tif (fromPlayer != null \u0026\u0026 !PlayerIsOwner(fromPlayer))\n\t\t\t\t{\n\t\t\t\t\tSetFlag(Flags.On, b: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslot.Drop(GetDropPosition(), GetDropVelocity());\n\t\t}\n\t}\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnWaterPurified(WaterPurifier waterPurifier, float timeCooked)",
    "MethodSignature": "ConvertWater(float timeCooked)",
    "MethodSourseCode": "\n\tprotected void ConvertWater(float timeCooked)\n\t{\n\t\tif (stopWhenOutputFull)\n\t\t{\n\t\t\tItem slot = waterStorage.inventory.GetSlot(0);\n\t\t\tif (slot != null \u0026\u0026 slot.amount \u003E= slot.MaxStackable())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnWaterPurify\u0022, this, timeCooked) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = timeCooked * ((float)waterToProcessPerMinute / 60f);\n\t\tdirtyWaterProcssed \u002B= num;\n\t\tif (dirtyWaterProcssed \u003E= 1f)\n\t\t{\n\t\t\tItem slot2 = base.inventory.GetSlot(0);\n\t\t\tint num2 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);\n\t\t\tnum = num2;\n\t\t\tslot2.UseItem(num2);\n\t\t\tdirtyWaterProcssed -= num2;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tpendingFreshWater \u002B= num / (float)freshWaterRatio;\n\t\tif (!(pendingFreshWater \u003E= 1f))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num3 = Mathf.FloorToInt(pendingFreshWater);\n\t\tpendingFreshWater -= num3;\n\t\tItem slot3 = waterStorage.inventory.GetSlot(0);\n\t\tif (slot3 != null \u0026\u0026 slot3.info != freshWater)\n\t\t{\n\t\t\tslot3.RemoveFromContainer();\n\t\t\tslot3.Remove();\n\t\t}\n\t\tif (slot3 == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(freshWater, num3, 0uL);\n\t\t\tif (!item.MoveToContainer(waterStorage.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tslot3.amount \u002B= num3;\n\t\t\tslot3.amount = Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);\n\t\t\twaterStorage.inventory.MarkDirty();\n\t\t}\n\t\tInterface.CallHook(\u0022OnWaterPurified\u0022, this, timeCooked);\n\t\twaterStorage.SendNetworkUpdate();\n\t}\n",
    "ClassName": "WaterPurifier",
    "HookLineInvoke": 53
  },
  {
    "HookSignature": "CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)",
    "MethodSignature": "CanPlayerAdmin(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanPlayerAdmin(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanAdministerVending\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PlayerBehind(player))\n\t\t{\n\t\t\treturn OccupiedCheck(player);\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTurretClearList(AutoTurret autoTurret, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void ClearList(RPCMessage rpc)\n\t{\n\t\tif (!booting \u0026\u0026 !IsOnline() \u0026\u0026 IsAuthed(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnTurretClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) =\u003E x.userid), \u0022clear\u0022, rpc.player.userID);\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSignature": "LoseCondition(float amount)",
    "MethodSourseCode": "\n\tpublic void LoseCondition(float amount)\n\t{\n\t\tif (hasCondition \u0026\u0026 !Debugging.disablecondition \u0026\u0026 Interface.CallHook(\u0022IOnLoseCondition\u0022, this, amount) == null)\n\t\t{\n\t\t\tfloat num = condition;\n\t\t\tcondition -= amount;\n\t\t\tif (ConVar.Global.developer \u003E 0)\n\t\t\t{\n\t\t\t\tDebug.Log(info.shortname \u002B \u0022 was damaged by: \u0022 \u002B amount \u002B \u0022cond is: \u0022 \u002B condition \u002B \u0022/\u0022 \u002B maxCondition);\n\t\t\t}\n\t\t\tif (condition \u003C= 0f \u0026\u0026 condition \u003C num)\n\t\t\t{\n\t\t\t\tOnBroken();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanReceiveCall(PhoneController phoneController)",
    "MethodSignature": "CanReceiveCall()",
    "MethodSourseCode": "\n\tprivate bool CanReceiveCall()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanReceiveCall\u0022, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (RequirePower \u0026\u0026 !IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (RequireParent \u0026\u0026 !base.baseEntity.HasParent())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNetworkGroupEntered(BaseNetworkable baseNetworkable, Network.Visibility.Group group)",
    "MethodSignature": "OnNetworkGroupEnter(Group group)",
    "MethodSourseCode": "\n\tpublic virtual void OnNetworkGroupEnter(Group group)\n\t{\n\t\tInterface.CallHook(\u0022OnNetworkGroupEntered\u0022, this, group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanNpcEat(BaseNpc baseNpc, BaseEntity best)",
    "MethodSignature": "WantsToEat(BaseEntity best)",
    "MethodSourseCode": "\n\tpublic virtual bool WantsToEat(BaseEntity best)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNpcEat\u0022, this, best);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!best.HasTrait(TraitFlag.Food))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (best.HasTrait(TraitFlag.Alive))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcAttack(BaseNpc baseNpc, BaseEntity AttackTarget)",
    "MethodSignature": "StartAttack()",
    "MethodSourseCode": "\n\tpublic virtual void StartAttack()\n\t{\n\t\tif ((bool)AttackTarget \u0026\u0026 AttackReady() \u0026\u0026 Interface.CallHook(\u0022OnNpcAttack\u0022, this, AttackTarget) == null \u0026\u0026 !((AttackTarget.ServerPosition - ServerPosition).magnitude \u003E AttackRange))\n\t\t{\n\t\t\tnextAttackTime = UnityEngine.Time.realtimeSinceStartup \u002B AttackRate;\n\t\t\tBaseCombatEntity combatTarget = CombatTarget;\n\t\t\tif ((bool)combatTarget)\n\t\t\t{\n\t\t\t\tcombatTarget.Hurt(AttackDamage, AttackDamageType, this);\n\t\t\t\tStamina.Use(AttackCost);\n\t\t\t\tBusyTimer.Activate(0.5f);\n\t\t\t\tSignalBroadcast(Signal.Attack);\n\t\t\t\tClientRPC(null, \u0022Attack\u0022, AttackTarget.ServerPosition);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseNpc",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTerrainInitialized()",
    "MethodSignature": "PostSetupComponents()",
    "MethodSourseCode": "\n\tpublic void PostSetupComponents()\n\t{\n\t\tTerrainExtension[] components = GetComponents\u003CTerrainExtension\u003E();\n\t\tfor (int i = 0; i \u003C components.Length; i\u002B\u002B)\n\t\t{\n\t\t\tcomponents[i].PostSetup();\n\t\t}\n\t\tInterface.CallHook(\u0022OnTerrainInitialized\u0022);\n\t}\n",
    "ClassName": "TerrainMeta",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnRfFrequencyChange(RFBroadcaster rFBroadcaster, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!CanChangeFrequency(msg.player) || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\treturn;\n\t\t}\n\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsPowered());\n\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tfrequency = num;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t\tHurt(MaxHealth() * 0.01f, DamageType.Decay, this);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnRfFrequencyChanged(RFBroadcaster rFBroadcaster, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!CanChangeFrequency(msg.player) || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t\treturn;\n\t\t}\n\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsPowered());\n\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t{\n\t\t\tfrequency = num;\n\t\t\tMarkDirty();\n\t\t\tSendNetworkUpdate();\n\t\t\tHurt(MaxHealth() * 0.01f, DamageType.Decay, this);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "RFBroadcaster",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnWireConnect(BasePlayer player, BaseNetworkable baseNetworkable, int num2, BaseNetworkable baseNetworkable2, int num3, System.Collections.Generic.List\u003CUnityEngine.Vector3\u003E list)",
    "MethodSignature": "MakeConnection(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\t[RPC_Server.FromOwner]\n\tpublic void MakeConnection(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!CanPlayerUseWires(player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003E 18)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CVector3\u003E list = new List\u003CVector3\u003E();\n\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\n\t\t{\n\t\t\tVector3 item = msg.read.Vector3();\n\t\t\tlist.Add(item);\n\t\t}\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tint num2 = msg.read.Int32();\n\t\tNetworkableId uid2 = msg.read.EntityID();\n\t\tint num3 = msg.read.Int32();\n\t\tWireColour wireColour = IntToColour(msg.read.Int32());\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tIOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent\u003CIOEntity\u003E());\n\t\tif (iOEntity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(uid2);\n\t\tIOEntity iOEntity2 = ((baseNetworkable2 == null) ? null : baseNetworkable2.GetComponent\u003CIOEntity\u003E());\n\t\tif (!(iOEntity2 == null) \u0026\u0026 ValidateLine(list, iOEntity, iOEntity2, player, num3) \u0026\u0026 !(Vector3.Distance(baseNetworkable2.transform.position, baseNetworkable.transform.position) \u003E maxWireLength) \u0026\u0026 num2 \u003C iOEntity.inputs.Length \u0026\u0026 num3 \u003C iOEntity2.outputs.Length \u0026\u0026 !(iOEntity.inputs[num2].connectedTo.Get() != null) \u0026\u0026 !(iOEntity2.outputs[num3].connectedTo.Get() != null) \u0026\u0026 (!iOEntity.inputs[num2].rootConnectionsOnly || iOEntity2.IsRootEntity()) \u0026\u0026 CanModifyEntity(player, iOEntity) \u0026\u0026 CanModifyEntity(player, iOEntity2) \u0026\u0026 Interface.CallHook(\u0022OnWireConnect\u0022, player, baseNetworkable, num2, baseNetworkable2, num3, list) == null)\n\t\t{\n\t\t\tiOEntity.inputs[num2].connectedTo.Set(iOEntity2);\n\t\t\tiOEntity.inputs[num2].connectedToSlot = num3;\n\t\t\tiOEntity.inputs[num2].wireColour = wireColour;\n\t\t\tiOEntity.inputs[num2].connectedTo.Init();\n\t\t\tiOEntity2.outputs[num3].connectedTo.Set(iOEntity);\n\t\t\tiOEntity2.outputs[num3].connectedToSlot = num2;\n\t\t\tiOEntity2.outputs[num3].linePoints = list.ToArray();\n\t\t\tiOEntity2.outputs[num3].wireColour = wireColour;\n\t\t\tiOEntity2.outputs[num3].connectedTo.Init();\n\t\t\tiOEntity2.outputs[num3].worldSpaceLineEndRotation = iOEntity.transform.TransformDirection(iOEntity.inputs[num2].handleDirection);\n\t\t\tiOEntity2.MarkDirtyForceUpdateOutputs();\n\t\t\tiOEntity2.SendNetworkUpdate();\n\t\t\tiOEntity.SendNetworkUpdate();\n\t\t\tiOEntity2.SendChangedToRoot(forceUpdate: true);\n\t\t\tiOEntity2.RefreshIndustrialPreventBuilding();\n\t\t\tif (wireType == IOEntity.IOType.Industrial)\n\t\t\t{\n\t\t\t\tiOEntity.NotifyIndustrialNetworkChanged();\n\t\t\t\tiOEntity2.NotifyIndustrialNetworkChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "OnEntityControl(PoweredRemoteControlEntity poweredRemoteControlEntity, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsPowered())\n\t\t{\n\t\t\treturn IsStatic();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PoweredRemoteControlEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnLiquidVesselFill(BaseLiquidVessel baseLiquidVessel, BasePlayer ownerPlayer, LiquidContainer facingLiquidContainer)",
    "MethodSignature": "FillCheck()",
    "MethodSourseCode": "\n\tpublic void FillCheck()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;\n\t\tVector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);\n\t\tLiquidContainer facingLiquidContainer = GetFacingLiquidContainer();\n\t\tif (Interface.CallHook(\u0022OnLiquidVesselFill\u0022, this, ownerPlayer, facingLiquidContainer) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (facingLiquidContainer == null \u0026\u0026 CanFillFromWorld())\n\t\t{\n\t\t\tAddLiquid(WaterResource.GetAtPoint(pos), Mathf.FloorToInt(f));\n\t\t}\n\t\telse if (facingLiquidContainer != null \u0026\u0026 facingLiquidContainer.HasLiquidItem())\n\t\t{\n\t\t\tint num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tItem liquidItem = facingLiquidContainer.GetLiquidItem();\n\t\t\t\tint num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));\n\t\t\t\tAddLiquid(liquidItem.info, num2);\n\t\t\t\tliquidItem.UseItem(num2);\n\t\t\t\tfacingLiquidContainer.OpenTap(2f);\n\t\t\t}\n\t\t}\n\t\tlastFillTime = UnityEngine.Time.realtimeSinceStartup;\n\t}\n",
    "ClassName": "BaseLiquidVessel",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnHorseLead(BaseRidableAnimal baseRidableAnimal, BasePlayer player)",
    "MethodSignature": "RPC_Lead(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Lead(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 !AnyMounted() \u0026\u0026 !IsForSale())\n\t\t{\n\t\t\tbool num = IsLeading();\n\t\t\tbool flag = msg.read.Bit();\n\t\t\tif (num != flag \u0026\u0026 Interface.CallHook(\u0022OnHorseLead\u0022, this, player) == null)\n\t\t\t{\n\t\t\t\tSetLeading(flag ? player : null);\n\t\t\t\tLeadingChanged();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "CanLock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void TryLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 code.Length == 4 \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, rpc.player, this) == null \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectLocked.resourcePath);\n\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneCallStarted(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tif (IsMobile \u0026\u0026 activeCallTo != null \u0026\u0026 !activeCallTo.RequirePower)\n\t\t\t{\n\t\t\t\t_ = currentPlayer != null;\n\t\t\t}\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnPlayerSleepEnd(BasePlayer basePlayer)",
    "MethodSignature": "EndSleeping()",
    "MethodSourseCode": "\n\tpublic virtual void EndSleeping()\n\t{\n\t\tif (IsSleeping() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSleepEnd\u0022, this) == null)\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Sleeping, b: false);\n\t\t\tsleepStartTime = -1f;\n\t\t\tsleepingPlayerList.Remove(this);\n\t\t\tif (userID \u003C 10000000 \u0026\u0026 !bots.Contains(this))\n\t\t\t{\n\t\t\t\tbots.Add(this);\n\t\t\t}\n\t\t\tCancelInvoke(ScheduledDeath);\n\t\t\tInvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));\n\t\t\tif (RelationshipManager.TeamsEnabled())\n\t\t\t{\n\t\t\t\tInvokeRandomized(TeamUpdate, 1f, 4f, 1f);\n\t\t\t}\n\t\t\tEnablePlayerCollider();\n\t\t\tAddPlayerRigidbody();\n\t\t\tSetServerFall(wantsOn: false);\n\t\t\tif (HasParent())\n\t\t\t{\n\t\t\t\tSetParent(null, worldPositionStays: true);\n\t\t\t\tForceUpdateTriggers();\n\t\t\t}\n\t\t\tinventory.containerMain.OnChanged();\n\t\t\tinventory.containerBelt.OnChanged();\n\t\t\tinventory.containerWear.OnChanged();\n\t\t\tInterface.CallHook(\u0022OnPlayerSleepEnded\u0022, this);\n\t\t\tEACServer.LogPlayerSpawn(this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnClientAuth(Network.Connection packetConnection)",
    "MethodSignature": "OnGiveUserInformation(Message packet)",
    "MethodSourseCode": "\n\tprivate void OnGiveUserInformation(Message packet)\n\t{\n\t\tif (packet.connection.state != 0)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.state = Network.Connection.State.Connecting;\n\t\tif (packet.read.UInt8() != 228)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Connection Protocol\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.userid = packet.read.UInt64();\n\t\tpacket.connection.protocol = packet.read.UInt32();\n\t\tpacket.connection.os = packet.read.String(128);\n\t\tpacket.connection.username = packet.read.String();\n\t\tif (string.IsNullOrEmpty(packet.connection.os))\n\t\t{\n\t\t\tthrow new Exception(\u0022Invalid OS\u0022);\n\t\t}\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tpacket.connection.username = packet.connection.username.Replace(\u0027\\n\u0027, \u0027 \u0027).Replace(\u0027\\r\u0027, \u0027 \u0027).Replace(\u0027\\t\u0027, \u0027 \u0027)\n\t\t\t.Trim();\n\t\tif (string.IsNullOrEmpty(packet.connection.username))\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Username\u0022);\n\t\t\treturn;\n\t\t}\n\t\tstring text = string.Empty;\n\t\tstring branch = ConVar.Server.branch;\n\t\tif (packet.read.Unread \u003E= 4)\n\t\t{\n\t\t\ttext = packet.read.String(128);\n\t\t}\n\t\tInterface.CallHook(\u0022OnClientAuth\u0022, packet.connection);\n\t\tif (branch != string.Empty \u0026\u0026 branch != text)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their branch is \u0027\u0022, text, \u0022\u0027 not \u0027\u0022, branch, \u0022\u0027\u0022));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Steam Beta: Requires \u0027\u0022 \u002B branch \u002B \u0022\u0027 branch!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003E 2388)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2388));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Server update required!\u0022);\n\t\t}\n\t\telse if (packet.connection.protocol \u003C 2388)\n\t\t{\n\t\t\tDebugEx.Log(string.Concat(\u0022Kicking \u0022, packet.connection, \u0022 - their protocol is \u0022, packet.connection.protocol, \u0022 not \u0022, 2388));\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Wrong Connection Protocol: Client update required!\u0022);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpacket.connection.token = packet.read.BytesWithSize(512u);\n\t\t\tif (packet.connection.token == null || packet.connection.token.Length \u003C 1)\n\t\t\t{\n\t\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid Token\u0022);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tauth.OnNewConnection(packet.connection);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 40
  },
  {
    "HookSignature": "OnItemUse(Item item, int amountToConsume)",
    "MethodSignature": "UseItem(int amountToConsume)",
    "MethodSourseCode": "\n\tpublic void UseItem(int amountToConsume = 1)\n\t{\n\t\tif (amountToConsume \u003E 0)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnItemUse\u0022, this, amountToConsume);\n\t\t\tif (obj is int)\n\t\t\t{\n\t\t\t\tamountToConsume = (int)obj;\n\t\t\t}\n\t\t\tamount -= amountToConsume;\n\t\t\tif (amount \u003C= 0)\n\t\t\t{\n\t\t\t\tamount = 0;\n\t\t\t\tRemove();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMarkDirty();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnHotAirBalloonToggle(HotAirBalloon hotAirBalloon, BasePlayer msgPlayer)",
    "MethodSignature": "EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHotAirBalloonToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool b = msg.read.Bit();\n\t\t\tSetFlag(Flags.On, b);\n\t\t\tif (IsOn())\n\t\t\t{\n\t\t\t\tInvoke(ScheduleOff, 60f);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCancelInvoke(ScheduleOff);\n\t\t\t\tInterface.CallHook(\u0022OnHotAirBalloonToggled\u0022, this, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HotAirBalloon",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnFireworkDesignChanged(PatternFirework patternFirework, ProtoBuf.PatternFirework.Design design, BasePlayer rpcPlayer)",
    "MethodSignature": "ServerSetFireworkDesign(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tprivate void ServerSetFireworkDesign(RPCMessage rpc)\n\t{\n\t\tif (!PlayerCanModify(rpc.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\n\t\tif (Interface.CallHook(\u0022OnFireworkDesignChange\u0022, this, design, rpc.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (design?.stars != null)\n\t\t{\n\t\t\twhile (design.stars.Count \u003E MaxStars)\n\t\t\t{\n\t\t\t\tint index = design.stars.Count - 1;\n\t\t\t\tdesign.stars[index].Dispose();\n\t\t\t\tdesign.stars.RemoveAt(index);\n\t\t\t}\n\t\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\n\t\t\t{\n\t\t\t\tstar.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));\n\t\t\t\tstar.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);\n\t\t\t}\n\t\t\tdesign.editedBy = rpc.player.userID;\n\t\t}\n\t\tDesign?.Dispose();\n\t\tDesign = design;\n\t\tInterface.CallHook(\u0022OnFireworkDesignChanged\u0022, this, design, rpc.player);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 32
  },
  {
    "HookSignature": "OnRespawnInformationGiven(BasePlayer basePlayer, ProtoBuf.RespawnInformation respawnInformation)",
    "MethodSignature": "SendRespawnOptions()",
    "MethodSourseCode": "\n\tpublic void SendRespawnOptions()\n\t{\n\t\tusing RespawnInformation respawnInformation = Facepunch.Pool.Get\u003CRespawnInformation\u003E();\n\t\trespawnInformation.spawnOptions = Facepunch.Pool.Get\u003CList\u003CRespawnInformation.SpawnOptions\u003E\u003E();\n\t\tSleepingBag[] array = SleepingBag.FindForPlayer(userID, ignoreTimers: true);\n\t\tforeach (SleepingBag sleepingBag in array)\n\t\t{\n\t\t\tRespawnInformation.SpawnOptions spawnOptions = Facepunch.Pool.Get\u003CRespawnInformation.SpawnOptions\u003E();\n\t\t\tspawnOptions.id = sleepingBag.net.ID;\n\t\t\tspawnOptions.name = sleepingBag.niceName;\n\t\t\tspawnOptions.worldPosition = sleepingBag.transform.position;\n\t\t\tspawnOptions.type = sleepingBag.RespawnType;\n\t\t\tspawnOptions.unlockSeconds = sleepingBag.GetUnlockSeconds(userID);\n\t\t\tspawnOptions.occupied = sleepingBag.IsOccupied();\n\t\t\trespawnInformation.spawnOptions.Add(spawnOptions);\n\t\t}\n\t\trespawnInformation.previousLife = previousLifeStory;\n\t\trespawnInformation.fadeIn = previousLifeStory != null \u0026\u0026 previousLifeStory.timeDied \u003E Epoch.Current - 5;\n\t\tInterface.CallHook(\u0022OnRespawnInformationGiven\u0022, this, respawnInformation);\n\t\tClientRPCPlayer(null, this, \u0022OnRespawnInformation\u0022, respawnInformation);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnAmmoSwitch(BaseProjectile baseProjectile, BasePlayer ownerPlayer, ItemDefinition itemDefinition)",
    "MethodSignature": "SwitchAmmoTo(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void SwitchAmmoTo(RPCMessage msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num == primaryMagazine.ammoType.itemid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);\n\t\tif (itemDefinition == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemModProjectile component = itemDefinition.GetComponent\u003CItemModProjectile\u003E();\n\t\tif ((bool)component \u0026\u0026 component.IsAmmo(primaryMagazine.definition.ammoTypes) \u0026\u0026 Interface.CallHook(\u0022OnAmmoSwitch\u0022, this, ownerPlayer, itemDefinition) == null)\n\t\t{\n\t\t\tif (primaryMagazine.contents \u003E 0)\n\t\t\t{\n\t\t\t\townerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));\n\t\t\t\tprimaryMagazine.contents = 0;\n\t\t\t}\n\t\t\tprimaryMagazine.ammoType = itemDefinition;\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tItemManager.DoRemoves();\n\t\t\townerPlayer.inventory.ServerUpdate(0f);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnLockerSwap(Locker locker, int num, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_Equip(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Equip(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= 3 || Interface.CallHook(\u0022OnLockerSwap\u0022, this, num, msg.player) != null || IsEquipping())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tint num2 = num * 13;\n\t\tbool flag = false;\n\t\tfor (int i = 0; i \u003C player.inventory.containerWear.capacity; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = player.inventory.containerWear.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tslot.RemoveFromContainer();\n\t\t\t\tclothingBuffer[i] = slot;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j \u003C 7; j\u002B\u002B)\n\t\t{\n\t\t\tint num3 = num2 \u002B j;\n\t\t\tItem slot2 = base.inventory.GetSlot(num3);\n\t\t\tItem item = clothingBuffer[j];\n\t\t\tif (slot2 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (slot2.info.category != ItemCategory.Attire || !slot2.MoveToContainer(player.inventory.containerWear, j))\n\t\t\t\t{\n\t\t\t\t\tslot2.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (item.info.category != ItemCategory.Attire || !item.MoveToContainer(base.inventory, num3))\n\t\t\t\t{\n\t\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tclothingBuffer[j] = null;\n\t\t}\n\t\tfor (int k = 0; k \u003C 6; k\u002B\u002B)\n\t\t{\n\t\t\tint num4 = num2 \u002B k \u002B 7;\n\t\t\tint iTargetPos = k;\n\t\t\tItem slot3 = base.inventory.GetSlot(num4);\n\t\t\tItem slot4 = player.inventory.containerBelt.GetSlot(k);\n\t\t\tslot4?.RemoveFromContainer();\n\t\t\tif (slot3 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!slot3.MoveToContainer(player.inventory.containerBelt, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tslot3.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (slot4 != null)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tif (!slot4.MoveToContainer(base.inventory, num4))\n\t\t\t\t{\n\t\t\t\t\tslot4.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tEffect.server.Run(equipSound.resourcePath, player, StringPool.Get(\u0022spine3\u0022), Vector3.zero, Vector3.zero);\n\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\tInvoke(ClearEquipping, 1.5f);\n\t\t}\n\t}\n",
    "ClassName": "Locker",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityReskinned(BaseEntity baseEntity2, ItemSkinDirectory.Skin skin, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeItemSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void ChangeItemSkin(RPCMessage msg)\n\t{\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tint targetSkin = msg.read.Int32();\n\t\tif (msg.player == null || !msg.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (msg.player.UnlockAllSkins)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (targetSkin != 0 \u0026\u0026 !flag \u0026\u0026 !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))\n\t\t{\n\t\t\tSprayFailResponse(SprayFailReason.SkinNotOwned);\n\t\t\treturn;\n\t\t}\n\t\tif (baseNetworkable != null \u0026\u0026 baseNetworkable is BaseEntity baseEntity2)\n\t\t{\n\t\t\tVector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);\n\t\t\tif (!msg.player.IsVisible(position, 3f))\n\t\t\t{\n\t\t\t\tSprayFailResponse(SprayFailReason.LineOfSight);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (baseNetworkable is Door door)\n\t\t\t{\n\t\t\t\tif (!door.GetPlayerLockPermission(msg.player))\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022Door must be openable\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (door.IsOpen())\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022Door must be closed\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def))\n\t\t\t{\n\t\t\t\tSprayFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemDefinition itemDefinition = null;\n\t\t\tulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);\n\t\t\tItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E x.id == targetSkin);\n\t\t\tif (Interface.CallHook(\u0022OnEntityReskin\u0022, baseEntity2, skin, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin)\n\t\t\t{\n\t\t\t\tif (itemSkin.Redirect != null)\n\t\t\t\t{\n\t\t\t\t\titemDefinition = itemSkin.Redirect;\n\t\t\t\t}\n\t\t\t\telse if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) \u0026\u0026 def.isRedirectOf != null)\n\t\t\t\t{\n\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) \u0026\u0026 def.isRedirectOf != null))\n\t\t\t{\n\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t}\n\t\t\tif (itemDefinition == null)\n\t\t\t{\n\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\tbaseEntity2.SendNetworkUpdate();\n\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\n\t\t\t\t{\n\t\t\t\t\tSprayFailResponse(reason2);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning(\u0022Cannot find resource path of redirect entity to spawn! \u0022 \u002B itemDefinition.gameObject.name);\n\t\t\t\t\tSprayFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tVector3 position2 = baseEntity2.transform.position;\n\t\t\t\tQuaternion rotation = baseEntity2.transform.rotation;\n\t\t\t\tBaseEntity entity = baseEntity2.GetParentEntity();\n\t\t\t\tfloat health = baseEntity2.Health();\n\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\n\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\n\t\t\t\tbool flag2 = baseEntity2 is Door;\n\t\t\t\tDictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary2 = new Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E();\n\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\n\t\t\t\tList\u003CChildPreserveInfo\u003E obj = Facepunch.Pool.GetList\u003CChildPreserveInfo\u003E();\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\n\t\t\t\t\t{\n\t\t\t\t\t\tobj.Add(new ChildPreserveInfo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTargetEntity = child,\n\t\t\t\t\t\t\tTargetBone = child.parentBone,\n\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\n\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tforeach (ChildPreserveInfo item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C baseEntity2.children.Count; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbaseEntity2.Kill();\n\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, position2, rotation);\n\t\t\t\tbaseEntity2.SetParent(entity);\n\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) \u0026\u0026 def2.isRedirectOf != null)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = 0uL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t}\n\t\t\t\tif (baseEntity2 is DecayEntity decayEntity)\n\t\t\t\t{\n\t\t\t\t\tdecayEntity.AttachToBuilding(null);\n\t\t\t\t}\n\t\t\t\tbaseEntity2.Spawn();\n\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\n\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\n\t\t\t\t}\n\t\t\t\tif (dictionary2.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\n\t\t\t\t\tif (!flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j \u003C baseEntity2.children.Count; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tforeach (KeyValuePair\u003CContainerSet, List\u003CItem\u003E\u003E item2 in dictionary2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item3 in item2.Value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebug.Log($\u0022Deleting {item3} as it has no new container\u0022);\n\t\t\t\t\t\t\titem3.Remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tforeach (ChildPreserveInfo item4 in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\titem4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);\n\t\t\t\t\t\titem4.TargetEntity.transform.localPosition = item4.LocalPosition;\n\t\t\t\t\t\titem4.TargetEntity.transform.localRotation = item4.LocalRotation;\n\t\t\t\t\t\titem4.TargetEntity.SendNetworkUpdate();\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.SetSlots(slots);\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnEntityReskinned\u0022, baseEntity2, skin, msg.player);\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t}\n\t\t\tClientRPC(null, \u0022Client_ReskinResult\u0022, 1, baseEntity2.net.ID);\n\t\t}\n\t\tLoseCondition(ConditionLossPerReskin);\n\t\tClientRPC(null, \u0022Client_ChangeSprayColour\u0022, -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E copy)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\n\t\t\t{\n\t\t\t\tContainerSet containerSet = default(ContainerSet);\n\t\t\t\tcontainerSet.ContainerIndex = index;\n\t\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key = containerSet;\n\t\t\t\tif (copy.ContainsKey(key))\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item5 in copy[key])\n\t\t\t\t\t{\n\t\t\t\t\t\titem5.MoveToContainer(itemContainerEntity.inventory);\n\t\t\t\t\t}\n\t\t\t\t\tcopy.Remove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void SaveEntityStorage(BaseEntity baseEntity, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary, int index)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\n\t\t\t{\n\t\t\t\tContainerSet containerSet2 = default(ContainerSet);\n\t\t\t\tcontainerSet2.ContainerIndex = index;\n\t\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key2 = containerSet2;\n\t\t\t\tif (!dictionary.ContainsKey(key2))\n\t\t\t\t{\n\t\t\t\t\tdictionary.Add(key2, new List\u003CItem\u003E());\n\t\t\t\t\tforeach (Item item6 in itemContainerEntity2.inventory.itemList)\n\t\t\t\t\t{\n\t\t\t\t\t\tdictionary[key2].Add(item6);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item7 in dictionary[key2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem7.RemoveFromContainer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Multiple containers with the same prefab id being added during vehicle reskin\u0022);\n\t\t\t}\n\t\t}\n\t\tvoid SprayFailResponse(SprayFailReason reason)\n\t\t{\n\t\t\tClientRPC(null, \u0022Client_ReskinResult\u0022, 0, (int)reason);\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 179
  },
  {
    "HookSignature": "OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)",
    "MethodSignature": "GiveEffectsTo(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void GiveEffectsTo(BasePlayer player)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition ownerItemDefinition = GetOwnerItemDefinition();\n\t\tItemModConsumable component = ownerItemDefinition.GetComponent\u003CItemModConsumable\u003E();\n\t\tif (!component)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022No consumable for medicaltool :\u0022 \u002B base.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnHealingItemUse\u0022, this, player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\n\t\t\tif (player != ownerPlayer)\n\t\t\t{\n\t\t\t\tif (Interface.CallHook(\u0022OnPlayerRevive\u0022, GetOwnerPlayer(), player) != null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (player.IsWounded() \u0026\u0026 canRevive)\n\t\t\t\t{\n\t\t\t\t\tplayer.StopWounded(ownerPlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tforeach (ItemModConsumable.ConsumableEffect effect in component.effects)\n\t\t\t{\n\t\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount, effect.time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player is BasePet)\n\t\t\t{\n\t\t\t\tplayer.SendNetworkUpdateImmediate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MedicalTool",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "OnRfFrequencyChange(PagerEntity pagerEntity, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (!(msg.player == null) \u0026\u0026 msg.player.CanBuild() \u0026\u0026 !(UnityEngine.Time.time \u003C nextChangeTime))\n\t\t{\n\t\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\t\tint num = msg.read.Int32();\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) == null)\n\t\t\t{\n\t\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: true);\n\t\t\t\tfrequency = num;\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PagerEntity",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnEntityDestroy(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "OnKilled(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnKilled(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityDestroy\u0022, this) == null)\n\t\t{\n\t\t\tif (!OutOfCrates())\n\t\t\t{\n\t\t\t\tDropCrate();\n\t\t\t}\n\t\t\tbase.OnKilled(info);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExcavatorSuppliesRequested(ExcavatorSignalComputer excavatorSignalComputer, BasePlayer rpcPlayer, BaseEntity baseEntity)",
    "MethodSignature": "RequestSupplies(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tpublic void RequestSupplies(RPCMessage rpc)\n\t{\n\t\tif (HasFlag(Flags.Reserved7) \u0026\u0026 IsPowered() \u0026\u0026 chargePower \u003E= chargeNeededForSupplies \u0026\u0026 Interface.CallHook(\u0022OnExcavatorSuppliesRequest\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(supplyPlanePrefab.resourcePath);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tVector3 position = dropPoints[UnityEngine.Random.Range(0, dropPoints.Length)].position;\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\n\t\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnExcavatorSuppliesRequested\u0022, this, rpc.player, baseEntity);\n\t\t\tchargePower -= chargeNeededForSupplies;\n\t\t\tSetFlag(Flags.Reserved7, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorSignalComputer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer currentPlayer)",
    "MethodSignature": "OnDialFailed(Telephone.DialFailReason reason)",
    "MethodSourseCode": "\n\tpublic void OnDialFailed(Telephone.DialFailReason reason)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneDialFail\u0022, this, reason, currentPlayer) == null)\n\t\t{\n\t\t\tSetPhoneState(Telephone.CallState.Idle);\n\t\t\tbase.baseEntity.ClientRPC(null, \u0022ClientOnDialFailed\u0022, (int)reason);\n\t\t\tactiveCallTo = null;\n\t\t\tif (IsInvoking(TimeOutCall))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutCall);\n\t\t\t}\n\t\t\tif (IsInvoking(TriggerTimeOut))\n\t\t\t{\n\t\t\t\tCancelInvoke(TriggerTimeOut);\n\t\t\t}\n\t\t\tif (IsInvoking(TimeOutDialing))\n\t\t\t{\n\t\t\t\tCancelInvoke(TimeOutDialing);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPhoneDialFailed\u0022, this, reason, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnHorseHitch(RidableHorse horse, HitchTrough.HitchSpot hitch)",
    "MethodSignature": "AttemptToHitch(RidableHorse horse, HitchSpot hitch)",
    "MethodSourseCode": "\n\tpublic bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)\n\t{\n\t\tif (horse == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (hitch == null)\n\t\t{\n\t\t\thitch = GetClosest(horse.transform.position);\n\t\t}\n\t\tif (hitch != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnHorseHitch\u0022, horse, hitch);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\thitch.SetOccupiedBy(horse);\n\t\t\thorse.SetHitch(this);\n\t\t\thorse.transform.SetPositionAndRotation(hitch.spot.position, hitch.spot.rotation);\n\t\t\thorse.DismountAllPlayers();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "HitchTrough",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)",
    "MethodSignature": "DoAction(Item item, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void DoAction(Item item, BasePlayer player)\n\t{\n\t\tif (item.amount \u003C 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGameObjectRef gameObjectRef = GetConsumeEffect();\n\t\tif (gameObjectRef.isValid)\n\t\t{\n\t\t\tVector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));\n\t\t\tEffect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);\n\t\t}\n\t\tplayer.metabolism.MarkConsumption();\n\t\tItemModConsumable consumable = GetConsumable();\n\t\tif (!string.IsNullOrEmpty(consumable.achievementWhenEaten))\n\t\t{\n\t\t\tplayer.GiveAchievement(consumable.achievementWhenEaten);\n\t\t}\n\t\tFacepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);\n\t\tfloat num = Mathf.Max(consumable.amountToConsume, 1);\n\t\tfloat num2 = Mathf.Min(item.amount, num);\n\t\tfloat num3 = num2 / num;\n\t\tfloat num4 = item.conditionNormalized;\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\tnum4 = consumable.conditionFractionToLose;\n\t\t}\n\t\tforeach (ItemModConsumable.ConsumableEffect effect in consumable.effects)\n\t\t{\n\t\t\tif (Mathf.Clamp01(player.healthFraction \u002B player.metabolism.pending_health.Fraction()) \u003E effect.onlyIfHealthLessThan)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (effect.type == MetabolismAttribute.Type.Health)\n\t\t\t{\n\t\t\t\tif (effect.amount \u003C 0f)\n\t\t\t\t{\n\t\t\t\t\tplayer.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position \u002B player.transform.forward * 1f));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplayer.health \u002B= effect.amount * num3 * num4;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);\n\t\t\t}\n\t\t}\n\t\tif (player.modifiers != null \u0026\u0026 Interface.CallHook(\u0022OnPlayerAddModifiers\u0022, player, item, consumable) == null)\n\t\t{\n\t\t\tplayer.modifiers.Add(consumable.modifiers);\n\t\t}\n\t\tif (product != null)\n\t\t{\n\t\t\tItemAmountRandom[] array = product;\n\t\t\tforeach (ItemAmountRandom itemAmountRandom in array)\n\t\t\t{\n\t\t\t\tint num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);\n\t\t\t\tif (num5 \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tItem item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);\n\t\t\t\t\tplayer.GiveItem(item2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (string.IsNullOrEmpty(eatGesture))\n\t\t{\n\t\t\tplayer.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);\n\t\t}\n\t\tFacepunch.Rust.Analytics.Server.Consume(base.gameObject.name);\n\t\tif (consumable.conditionFractionToLose \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem.UseItem((int)num2);\n\t\t}\n\t}\n",
    "ClassName": "ItemModConsume",
    "HookLineInvoke": 50
  },
  {
    "HookSignature": "OnFireworkDesignChange(PatternFirework patternFirework, ProtoBuf.PatternFirework.Design design, BasePlayer rpcPlayer)",
    "MethodSignature": "ServerSetFireworkDesign(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\tprivate void ServerSetFireworkDesign(RPCMessage rpc)\n\t{\n\t\tif (!PlayerCanModify(rpc.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);\n\t\tif (Interface.CallHook(\u0022OnFireworkDesignChange\u0022, this, design, rpc.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (design?.stars != null)\n\t\t{\n\t\t\twhile (design.stars.Count \u003E MaxStars)\n\t\t\t{\n\t\t\t\tint index = design.stars.Count - 1;\n\t\t\t\tdesign.stars[index].Dispose();\n\t\t\t\tdesign.stars.RemoveAt(index);\n\t\t\t}\n\t\t\tforeach (ProtoBuf.PatternFirework.Star star in design.stars)\n\t\t\t{\n\t\t\t\tstar.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));\n\t\t\t\tstar.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);\n\t\t\t}\n\t\t\tdesign.editedBy = rpc.player.userID;\n\t\t}\n\t\tDesign?.Dispose();\n\t\tDesign = design;\n\t\tInterface.CallHook(\u0022OnFireworkDesignChanged\u0022, this, design, rpc.player);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "PatternFirework",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnEntityControl(AutoTurret autoTurret, ulong playerID)",
    "MethodSignature": "CanControl(ulong playerID)",
    "MethodSourseCode": "\n\tpublic virtual bool CanControl(ulong playerID)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnEntityControl\u0022, this, playerID);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (booting)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsPowered())\n\t\t{\n\t\t\treturn !PeacekeeperMode();\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBoatPathGenerate()",
    "MethodSignature": "GenerateOceanPatrolPath(float minDistanceFromShore, float minWaterDepth)",
    "MethodSourseCode": "\n\tpublic static List\u003CVector3\u003E GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBoatPathGenerate\u0022);\n\t\tif (obj is List\u003CVector3\u003E)\n\t\t{\n\t\t\treturn (List\u003CVector3\u003E)obj;\n\t\t}\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat num = x * 2f * (float)Math.PI;\n\t\tfloat num2 = 30f;\n\t\tint num3 = Mathf.CeilToInt(num / num2);\n\t\tList\u003CVector3\u003E list = new List\u003CVector3\u003E();\n\t\tfloat num4 = x;\n\t\tfloat y = 0f;\n\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t{\n\t\t\tfloat num5 = (float)i / (float)num3 * 360f;\n\t\t\tlist.Add(new Vector3(Mathf.Sin(num5 * ((float)Math.PI / 180f)) * num4, y, Mathf.Cos(num5 * ((float)Math.PI / 180f)) * num4));\n\t\t}\n\t\tfloat num6 = 4f;\n\t\tfloat num7 = 200f;\n\t\tbool flag = true;\n\t\tfor (int j = 0; j \u003C AI.ocean_patrol_path_iterations \u0026\u0026 flag; j\u002B\u002B)\n\t\t{\n\t\t\tflag = false;\n\t\t\tfor (int k = 0; k \u003C num3; k\u002B\u002B)\n\t\t\t{\n\t\t\t\tVector3 vector = list[k];\n\t\t\t\tint index = ((k == 0) ? (num3 - 1) : (k - 1));\n\t\t\t\tint index2 = ((k != num3 - 1) ? (k \u002B 1) : 0);\n\t\t\t\tVector3 b = list[index2];\n\t\t\t\tVector3 b2 = list[index];\n\t\t\t\tVector3 origin = vector;\n\t\t\t\tVector3 normalized = (Vector3.zero - vector).normalized;\n\t\t\t\tVector3 vector2 = vector \u002B normalized * num6;\n\t\t\t\tif (Vector3.Distance(vector2, b) \u003E num7 || Vector3.Distance(vector2, b2) \u003E num7)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool flag2 = true;\n\t\t\t\tint num8 = 16;\n\t\t\t\tfor (int l = 0; l \u003C num8; l\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tfloat num9 = (float)l / (float)num8 * 360f;\n\t\t\t\t\tVector3 normalized2 = new Vector3(Mathf.Sin(num9 * ((float)Math.PI / 180f)), y, Mathf.Cos(num9 * ((float)Math.PI / 180f))).normalized;\n\t\t\t\t\tVector3 vector3 = vector2 \u002B normalized2 * 1f;\n\t\t\t\t\tGetWaterDepth(vector3);\n\t\t\t\t\tVector3 direction = normalized;\n\t\t\t\t\tif (vector3 != Vector3.zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tdirection = (vector3 - vector2).normalized;\n\t\t\t\t\t}\n\t\t\t\t\tif (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1218511105))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tlist[k] = vector2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Failed to generate ocean patrol path\u0022);\n\t\t\treturn null;\n\t\t}\n\t\tList\u003Cint\u003E list2 = new List\u003Cint\u003E();\n\t\tLineUtility.Simplify(list, 5f, list2);\n\t\tList\u003CVector3\u003E list3 = list;\n\t\tlist = new List\u003CVector3\u003E();\n\t\tforeach (int item in list2)\n\t\t{\n\t\t\tlist.Add(list3[item]);\n\t\t}\n\t\tDebug.Log(\u0022Generated ocean patrol path with node count: \u0022 \u002B list.Count);\n\t\treturn list;\n\t}\n",
    "ClassName": "BaseBoat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanLock(BasePlayer player, KeyLock keyLock)",
    "MethodSignature": "Lock(BasePlayer player)",
    "MethodSourseCode": "\n\tprivate void Lock(BasePlayer player)\n\t{\n\t\tif (!(player == null) \u0026\u0026 player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanLock\u0022, player, this) == null \u0026\u0026 HasLockPermission(player))\n\t\t{\n\t\t\tLockLock(player);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "KeyLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleLockRequest(ModularCarGarage modularCarGarage, BasePlayer player, string text)",
    "MethodSignature": "RPC_RequestAddLock(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_RequestAddLock(RPCMessage msg)\n\t{\n\t\tif (!HasOccupant || carOccupant.CarLock.HasALock)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (player == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnVehicleLockRequest\u0022, this, player, text) == null)\n\t\t{\n\t\t\tItemAmount itemAmount = lockResourceCost;\n\t\t\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) \u003E= itemAmount.amount \u0026\u0026 carOccupant.CarLock.TryAddALock(text, player.userID))\n\t\t\t{\n\t\t\t\tplayer.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));\n\t\t\t\tEffect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "ToStream(Stream stream, SaveInfo saveInfo)",
    "MethodSourseCode": "\n\tpublic void ToStream(Stream stream, SaveInfo saveInfo)\n\t{\n\t\tusing (saveInfo.msg = Facepunch.Pool.Get\u003CProtoBuf.Entity\u003E())\n\t\t{\n\t\t\tSave(saveInfo);\n\t\t\tif (saveInfo.msg.baseEntity == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(string.Concat(this, \u0022: ToStream - no BaseEntity!?\u0022));\n\t\t\t}\n\t\t\tif (saveInfo.msg.baseNetworkable == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(string.Concat(this, \u0022: ToStream - no baseNetworkable!?\u0022));\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022IOnEntitySaved\u0022, this, saveInfo);\n\t\t\tsaveInfo.msg.ToProto(stream);\n\t\t\tPostSave(saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnClientProjectileEffectCreate(Network.Connection sourceConnection, BaseProjectile baseProjectile, string prefabName)",
    "MethodSignature": "CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced, bool forceClientsideEffects)",
    "MethodSourseCode": "\n\tpublic void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnClientProjectileEffectCreate\u0022, sourceConnection, this, prefabName) == null)\n\t\t{\n\t\t\tEffect effect = reusableInstance;\n\t\t\teffect.Clear();\n\t\t\teffect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);\n\t\t\teffect.scale = (silenced ? 0f : 1f);\n\t\t\tif (forceClientsideEffects)\n\t\t\t{\n\t\t\t\teffect.scale = 2f;\n\t\t\t}\n\t\t\teffect.pooledString = prefabName;\n\t\t\teffect.number = seed;\n\t\t\tEffectNetwork.Send(effect);\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRandomItemAward(RandomItemDispenser randomItemDispenser, RandomItemDispenser.RandomItemChance itemChance, BasePlayer forPlayer, UnityEngine.Vector3 distributorPosition)",
    "MethodSignature": "TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)",
    "MethodSourseCode": "\n\tprivate bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)\n\t{\n\t\tif (Interface.CallHook(\u0022OnRandomItemAward\u0022, this, itemChance, forPlayer, distributorPosition) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfloat num = UnityEngine.Random.Range(0f, 1f);\n\t\tif (itemChance.Chance \u003E= num)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif ((bool)forPlayer)\n\t\t\t\t{\n\t\t\t\t\tforPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\titem.Drop(distributorPosition \u002B Vector3.up * 0.5f, Vector3.up);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "RandomItemDispenser",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStructureDemolish(BuildingBlock buildingBlock, BasePlayer msgPlayer, bool false)",
    "MethodSignature": "DoDemolish(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoDemolish(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract() \u0026\u0026 CanDemolish(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnStructureDemolish\u0022, this, msg.player, false) == null)\n\t\t{\n\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);\n\t\t\tKill(DestroyMode.Gib);\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnOvenToggle(BaseOven baseOven, BasePlayer msgPlayer)",
    "MethodSignature": "SVSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprotected virtual void SVSwitch(RPCMessage msg)\n\t{\n\t\tbool flag = msg.read.Bit();\n\t\tif (Interface.CallHook(\u0022OnOvenToggle\u0022, this, msg.player) == null \u0026\u0026 flag != IsOn() \u0026\u0026 (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))\n\t\t{\n\t\t\tif (flag)\n\t\t\t{\n\t\t\t\tStartCooking();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStopCooking();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanPickupLock(BasePlayer rpcPlayer, BaseLock baseLock)",
    "MethodSignature": "RPC_TakeLock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_TakeLock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 !IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanPickupLock\u0022, rpc.player, this) == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnEntityPickedUp(rpc.player, this);\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "BaseLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPhoneCallStart(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)",
    "MethodSignature": "BeginCall()",
    "MethodSourseCode": "\n\tpublic void BeginCall()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPhoneCallStart\u0022, this, activeCallTo, currentPlayer) == null)\n\t\t{\n\t\t\tif (IsMobile \u0026\u0026 activeCallTo != null \u0026\u0026 !activeCallTo.RequirePower)\n\t\t\t{\n\t\t\t\t_ = currentPlayer != null;\n\t\t\t}\n\t\t\tSetPhoneStateWithPlayer(Telephone.CallState.InProcess);\n\t\t\tInvoke(TimeOutCall, TelephoneManager.MaxCallLength);\n\t\t\tInterface.CallHook(\u0022OnPhoneCallStarted\u0022, this, activeCallTo, currentPlayer);\n\t\t}\n\t}\n",
    "ClassName": "PhoneController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFindBurnable(BaseOven baseOven)",
    "MethodSignature": "FindBurnable()",
    "MethodSourseCode": "\n\tpublic Item FindBurnable()\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnFindBurnable\u0022, this);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tforeach (Item item in base.inventory.itemList)\n\t\t{\n\t\t\tif (IsBurnableItem(item))\n\t\t\t{\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExperimentEnd(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnHelicopterDropCrate(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "DropCrate()",
    "MethodSourseCode": "\n\tpublic void DropCrate()\n\t{\n\t\tif (numCrates \u003E 0)\n\t\t{\n\t\t\tVector3 pos = base.transform.position \u002B Vector3.down * 5f;\n\t\t\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnHelicopterDropCrate\u0022, this);\n\t\t\t\tbaseEntity.SendMessage(\u0022SetWasDropped\u0022);\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t\tnumCrates--;\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnPlayerRecovered(BasePlayer basePlayer)",
    "MethodSignature": "RecoverFromWounded()",
    "MethodSourseCode": "\n\tpublic void RecoverFromWounded()\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerRecover\u0022, this) == null)\n\t\t{\n\t\t\tif (IsCrawling())\n\t\t\t{\n\t\t\t\tbase.health = UnityEngine.Random.Range(2f, 6f) \u002B healingWhileCrawling;\n\t\t\t}\n\t\t\thealingWhileCrawling = 0f;\n\t\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\t\tif ((bool)BaseGameMode.GetActiveGameMode(base.isServer))\n\t\t\t{\n\t\t\t\tBaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerRecovered\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnXmasStockingFill(Stocking stocking)",
    "MethodSignature": "SpawnLoot()",
    "MethodSourseCode": "\n\tpublic override void SpawnLoot()\n\t{\n\t\tif (base.inventory == null)\n\t\t{\n\t\t\tDebug.Log(\u0022CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \u0022 \u002B base.name);\n\t\t}\n\t\telse if (IsEmpty() \u0026\u0026 Interface.CallHook(\u0022OnXmasStockingFill\u0022, this) == null)\n\t\t{\n\t\t\tbase.SpawnLoot();\n\t\t\tSetFlag(Flags.On, b: true);\n\t\t\tHurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);\n\t\t}\n\t}\n",
    "ClassName": "Stocking",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnBuildingPrivilege(BaseEntity baseEntity, OBB obb)",
    "MethodSignature": "GetBuildingPrivilege(OBB obb)",
    "MethodSourseCode": "\n\tpublic BuildingPrivlidge GetBuildingPrivilege(OBB obb)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnBuildingPrivilege\u0022, this, obb);\n\t\tif (obj is BuildingPrivlidge)\n\t\t{\n\t\t\treturn (BuildingPrivlidge)obj;\n\t\t}\n\t\tBuildingBlock other = null;\n\t\tBuildingPrivlidge result = null;\n\t\tList\u003CBuildingBlock\u003E obj2 = Facepunch.Pool.GetList\u003CBuildingBlock\u003E();\n\t\tVis.Entities(obb.position, 16f \u002B obb.extents.magnitude, obj2, 2097152);\n\t\tfor (int i = 0; i \u003C obj2.Count; i\u002B\u002B)\n\t\t{\n\t\t\tBuildingBlock buildingBlock = obj2[i];\n\t\t\tif (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) \u003E 16f)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBuildingManager.Building building = buildingBlock.GetBuilding();\n\t\t\tif (building != null)\n\t\t\t{\n\t\t\t\tBuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();\n\t\t\t\tif (!(dominatingBuildingPrivilege == null))\n\t\t\t\t{\n\t\t\t\t\tother = buildingBlock;\n\t\t\t\t\tresult = dominatingBuildingPrivilege;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\treturn result;\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseLockedEntity(BasePlayer player, CodeLock codeLock)",
    "MethodSignature": "OnTryToOpen(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool OnTryToOpen(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseLockedEntity\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!IsLocked())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))\n\t\t{\n\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\treturn true;\n\t\t}\n\t\tDoEffect(effectDenied.resourcePath);\n\t\treturn false;\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEngineStart(MotorRowboat motorRowboat, BasePlayer driver)",
    "MethodSignature": "EngineToggle(bool wantsOn)",
    "MethodSourseCode": "\n\tpublic void EngineToggle(bool wantsOn)\n\t{\n\t\tif (!fuelSystem.HasFuel(forceCheck: true))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer driver = GetDriver();\n\t\tif (!wantsOn || Interface.CallHook(\u0022OnEngineStart\u0022, this, driver) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, wantsOn);\n\t\t\tif (wantsOn)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnEngineStarted\u0022, this, driver);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "MotorRowboat",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnDemoRecordingStarted(string text, BasePlayer basePlayer)",
    "MethodSignature": "StartDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StartDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 !net.connection.IsRecording)\n\t\t{\n\t\t\tstring text = $\u0022demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem\u0022;\n\t\t\tif (Interface.CallHook(\u0022OnDemoRecordingStart\u0022, text, this) == null)\n\t\t\t{\n\t\t\t\tDebug.Log(ToString() \u002B \u0022 recording started: \u0022 \u002B text);\n\t\t\t\tnet.connection.StartRecording(text, new Demo.Header\n\t\t\t\t{\n\t\t\t\t\tversion = Demo.Version,\n\t\t\t\t\tlevel = UnityEngine.Application.loadedLevelName,\n\t\t\t\t\tlevelSeed = World.Seed,\n\t\t\t\t\tlevelSize = World.Size,\n\t\t\t\t\tchecksum = World.Checksum,\n\t\t\t\t\tlocalclient = userID,\n\t\t\t\t\tposition = eyes.position,\n\t\t\t\t\trotation = eyes.HeadForward(),\n\t\t\t\t\tlevelUrl = World.Url,\n\t\t\t\t\trecordedTime = DateTime.Now.ToBinary()\n\t\t\t\t});\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t\tSendGlobalSnapshot();\n\t\t\t\tSendFullSnapshot();\n\t\t\t\tSendEntityUpdate();\n\t\t\t\tTreeManager.SendSnapshot(this);\n\t\t\t\tServerMgr.SendReplicatedVars(net.connection);\n\t\t\t\tInvokeRepeating(MonitorDemoRecording, 10f, 10f);\n\t\t\t\tInterface.CallHook(\u0022OnDemoRecordingStarted\u0022, text, this);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 29
  },
  {
    "HookSignature": "OnOvenTemperature(BaseOven baseOven, int slot)",
    "MethodSignature": "GetTemperature(int slot)",
    "MethodSourseCode": "\n\tpublic float GetTemperature(int slot)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022OnOvenTemperature\u0022, this, slot);\n\t\tif (obj is float)\n\t\t{\n\t\t\treturn (float)obj;\n\t\t}\n\t\tif (!HasFlag(Flags.On))\n\t\t{\n\t\t\treturn 15f;\n\t\t}\n\t\treturn cookingTemperature;\n\t}\n",
    "ClassName": "BaseOven",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUseMailbox(BasePlayer player, Mailbox mailbox)",
    "MethodSignature": "PlayerIsOwner(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool PlayerIsOwner(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUseMailbox\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn player.CanBuild();\n\t}\n",
    "ClassName": "Mailbox",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerRestart(string strNotice, int iSeconds)",
    "MethodSignature": "RestartServer(string strNotice, int iSeconds)",
    "MethodSourseCode": "\n\tpublic static void RestartServer(string strNotice, int iSeconds)\n\t{\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnServerRestartInterrupt\u0022) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Restart interrupted!\u0022);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StopCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnServerRestart\u0022, strNotice, iSeconds) == null)\n\t\t{\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = SingletonComponent\u003CServerMgr\u003E.Instance.ServerRestartWarning(strNotice, iSeconds);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StartCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.UpdateServerInformation();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnServerInformationUpdated()",
    "MethodSignature": "UpdateServerInformation()",
    "MethodSourseCode": "\n\tprivate void UpdateServerInformation()\n\t{\n\t\tif (!SteamServer.IsValid)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022UpdateServerInformation\u0022))\n\t\t{\n\t\t\tSteamServer.ServerName = ConVar.Server.hostname;\n\t\t\tSteamServer.MaxPlayers = ConVar.Server.maxplayers;\n\t\t\tSteamServer.Passworded = false;\n\t\t\tSteamServer.MapName = World.GetServerBrowserMapName();\n\t\t\tstring text = \u0022stok\u0022;\n\t\t\tif (Restarting)\n\t\t\t{\n\t\t\t\ttext = \u0022strst\u0022;\n\t\t\t}\n\t\t\tstring text2 = $\u0022born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}\u0022;\n\t\t\tstring text3 = $\u0022gm{GamemodeName()}\u0022;\n\t\t\tstring text4 = (ConVar.Server.pve ? \u0022,pve\u0022 : string.Empty);\n\t\t\tstring text5 = ConVar.Server.tags?.Trim(\u0027,\u0027) ?? \u0022\u0022;\n\t\t\tstring text6 = ((!string.IsNullOrWhiteSpace(text5)) ? (\u0022,\u0022 \u002B text5) : \u0022\u0022);\n\t\t\tstring text7 = BuildInfo.Current?.Scm?.ChangeId ?? \u00220\u0022;\n\t\t\tSteamServer.GameTags = $\u0022mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent\u003CServerMgr\u003E.Instance.connectionQueue.Queued},v{2388}{text4}{text6},h{AssemblyHash},{text},{text2},{text3},cs{text7}\u0022;\n\t\t\tif (ConVar.Server.description != null \u0026\u0026 ConVar.Server.description.Length \u003E 100)\n\t\t\t{\n\t\t\t\tstring[] array = ConVar.Server.description.SplitToChunks(100).ToArray();\n\t\t\t\tfor (int i = 0; i \u003C 16; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tif (i \u003C array.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, array[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tSteamServer.SetKey($\u0022description_{i:00}\u0022, string.Empty);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSteamServer.SetKey(\u0022description_0\u0022, ConVar.Server.description);\n\t\t\t\tfor (int j = 1; j \u003C 16; j\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tSteamServer.SetKey($\u0022description_{j:00}\u0022, string.Empty);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022hash\u0022, AssemblyHash);\n\t\t\tstring value = World.Seed.ToString();\n\t\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\t\tif (activeGameMode != null \u0026\u0026 !activeGameMode.ingameMap)\n\t\t\t{\n\t\t\t\tvalue = \u00220\u0022;\n\t\t\t}\n\t\t\tSteamServer.SetKey(\u0022world.seed\u0022, value);\n\t\t\tSteamServer.SetKey(\u0022world.size\u0022, World.Size.ToString());\n\t\t\tSteamServer.SetKey(\u0022pve\u0022, ConVar.Server.pve.ToString());\n\t\t\tSteamServer.SetKey(\u0022headerimage\u0022, ConVar.Server.headerimage);\n\t\t\tSteamServer.SetKey(\u0022logoimage\u0022, ConVar.Server.logoimage);\n\t\t\tSteamServer.SetKey(\u0022url\u0022, ConVar.Server.url);\n\t\t\tSteamServer.SetKey(\u0022gmn\u0022, GamemodeName());\n\t\t\tSteamServer.SetKey(\u0022gmt\u0022, GamemodeTitle());\n\t\t\tSteamServer.SetKey(\u0022uptime\u0022, ((int)UnityEngine.Time.realtimeSinceStartup).ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_mb\u0022, Performance.report.memoryAllocations.ToString());\n\t\t\tSteamServer.SetKey(\u0022gc_cl\u0022, Performance.report.memoryCollections.ToString());\n\t\t\tSteamServer.SetKey(\u0022ram_sys\u0022, (Performance.report.memoryUsageSystem / 1000000).ToString());\n\t\t\tSteamServer.SetKey(\u0022fps\u0022, Performance.report.frameRate.ToString());\n\t\t\tSteamServer.SetKey(\u0022fps_avg\u0022, Performance.report.frameRateAverage.ToString(\u00220.00\u0022));\n\t\t\tSteamServer.SetKey(\u0022ent_cnt\u0022, BaseNetworkable.serverEntities.Count.ToString());\n\t\t\tSteamServer.SetKey(\u0022build\u0022, BuildInfo.Current.Scm.ChangeId);\n\t\t}\n\t\tInterface.CallHook(\u0022OnServerInformationUpdated\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 72
  },
  {
    "HookSignature": "OnFireworkStarted(BaseFirework baseFirework)",
    "MethodSignature": "Begin()",
    "MethodSourseCode": "\n\tpublic virtual void Begin()\n\t{\n\t\tSetFlag(Flags.OnFire, b: false);\n\t\tSetFlag(Flags.On, b: true, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate_Flags();\n\t\tInterface.CallHook(\u0022OnFireworkStarted\u0022, this);\n\t\tInvoke(OnExhausted, activityLength);\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerVoice(BasePlayer basePlayer, byte[] data)",
    "MethodSignature": "OnReceivedVoice(byte[] data)",
    "MethodSourseCode": "\n\tpublic void OnReceivedVoice(byte[] data)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerVoice\u0022, this, data) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.VoiceData);\n\t\t\tnetWrite.EntityID(net.ID);\n\t\t\tnetWrite.BytesWithSize(data);\n\t\t\tnetWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))\n\t\t\t{\n\t\t\t\tpriority = Priority.Immediate\n\t\t\t});\n\t\t\tif (activeTelephone != null)\n\t\t\t{\n\t\t\t\tactiveTelephone.OnReceivedVoiceFromUser(data);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityEnter(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityEnter(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityEnter(BaseEntity ent)\n\t{\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif ((bool)basePlayer \u0026\u0026 Interface.CallHook(\u0022OnEntityEnter\u0022, this, ent) == null)\n\t\t{\n\t\t\t_players.Add(basePlayer);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanSwapToSeat(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "CanSwapToThis(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanSwapToThis(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanSwapToSeat\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSurveyGather(SurveyCharge surveyCharge, Item item)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tbase.Explode();\n\t\tif (WaterLevel.Test(base.transform.position, waves: true, this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);\n\t\tif (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime \u003C 10f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\torCreate.lastSurveyTime = Time.realtimeSinceStartup;\n\t\tif (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 point = hitOut.point;\n\t\t_ = hitOut.normal;\n\t\tList\u003CSurveyCrater\u003E obj = Pool.GetList\u003CSurveyCrater\u003E();\n\t\tVis.Entities(base.transform.position, 10f, obj, 1);\n\t\tbool num = obj.Count \u003E 0;\n\t\tPool.FreeList(ref obj);\n\t\tif (num)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tbool flag2 = false;\n\t\tforeach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)\n\t\t{\n\t\t\tif (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM \u0026\u0026 !resource.isLiquid \u0026\u0026 resource.amount \u003E= 1000)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);\n\t\t\t\tint iAmount = 1;\n\t\t\t\tflag = true;\n\t\t\t\tif (resource.isLiquid)\n\t\t\t\t{\n\t\t\t\t\tflag2 = true;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i \u003C num2; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = ItemManager.Create(resource.type, iAmount, 0uL);\n\t\t\t\t\tInterface.CallHook(\u0022OnSurveyGather\u0022, this, item);\n\t\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);\n\t\t\t\t\titem.Drop(base.transform.position \u002B Vector3.up * 1f, GetInheritedDropVelocity() \u002B modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tstring strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SurveyCharge",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnServerMessage(string message, string username, string color, ulong userid)",
    "MethodSignature": "Broadcast(string message, string username, string color, ulong userid)",
    "MethodSourseCode": "\n\tpublic static void Broadcast(string message, string username = \u0022SERVER\u0022, string color = \u0022#eee\u0022, ulong userid = 0uL)\n\t{\n\t\tif (Interface.CallHook(\u0022OnServerMessage\u0022, message, username, color, userid) == null)\n\t\t{\n\t\t\tstring text = username.EscapeRichText();\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=\u0022 \u002B color \u002B \u0022\u003E\u0022 \u002B text \u002B \u0022\u003C/color\u003E \u0022 \u002B message);\n\t\t\tChatEntry ce = default(ChatEntry);\n\t\t\tce.Channel = ChatChannel.Server;\n\t\t\tce.Message = message;\n\t\t\tce.UserId = userid.ToString();\n\t\t\tce.Username = username;\n\t\t\tce.Color = color;\n\t\t\tce.Time = Epoch.Current;\n\t\t\tRecord(ce);\n\t\t}\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnThreatLevelUpdate(BasePlayer basePlayer)",
    "MethodSignature": "EnsureUpdated()",
    "MethodSourseCode": "\n\tpublic void EnsureUpdated()\n\t{\n\t\tif (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime \u003C 30f)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlastUpdateTime = UnityEngine.Time.realtimeSinceStartup;\n\t\tcachedThreatLevel = 0f;\n\t\tif (IsSleeping() || Interface.CallHook(\u0022OnThreatLevelUpdate\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (inventory.containerWear.itemList.Count \u003E 2)\n\t\t{\n\t\t\tcachedThreatLevel \u002B= 1f;\n\t\t}\n\t\tforeach (Item item in inventory.containerBelt.itemList)\n\t\t{\n\t\t\tBaseEntity heldEntity = item.GetHeldEntity();\n\t\t\tif ((bool)heldEntity \u0026\u0026 heldEntity is BaseProjectile \u0026\u0026 !(heldEntity is BowWeapon))\n\t\t\t{\n\t\t\t\tcachedThreatLevel \u002B= 2f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnRfListenerAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddListener(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddListener(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfListenerAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E listenList = GetListenList(frequency);\n\t\t\tif (listenList.Contains(obj))\n\t\t\t{\n\t\t\t\tDebug.Log(\u0022adding same listener twice\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenList.Add(obj);\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfListenerAdded\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerDismountFailed(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsDismount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsDismount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!HasValidDismountPosition(player))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDismountFailed\u0022, player, this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnPlayerWantsDismount\u0022, player, this) == null)\n\t\t{\n\t\t\tAttemptDismount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnServerRestartInterrupt()",
    "MethodSignature": "RestartServer(string strNotice, int iSeconds)",
    "MethodSourseCode": "\n\tpublic static void RestartServer(string strNotice, int iSeconds)\n\t{\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine != null)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnServerRestartInterrupt\u0022) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Restart interrupted!\u0022);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StopCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnServerRestart\u0022, strNotice, iSeconds) == null)\n\t\t{\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine = SingletonComponent\u003CServerMgr\u003E.Instance.ServerRestartWarning(strNotice, iSeconds);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.StartCoroutine(SingletonComponent\u003CServerMgr\u003E.Instance.restartCoroutine);\n\t\t\tSingletonComponent\u003CServerMgr\u003E.Instance.UpdateServerInformation();\n\t\t}\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnCargoShipSpawnCrate(CargoShip cargoShip)",
    "MethodSignature": "RespawnLoot()",
    "MethodSourseCode": "\n\tpublic void RespawnLoot()\n\t{\n\t\tif (Interface.CallHook(\u0022OnCargoShipSpawnCrate\u0022, this) == null)\n\t\t{\n\t\t\tInvokeRepeating(PlayHorn, 0f, 8f);\n\t\t\tSpawnCrate(lockedCratePrefab.resourcePath);\n\t\t\tSpawnCrate(eliteCratePrefab.resourcePath);\n\t\t\tfor (int i = 0; i \u003C 4; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(militaryCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tfor (int j = 0; j \u003C 4; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tSpawnCrate(junkCratePrefab.resourcePath);\n\t\t\t}\n\t\t\tlootRoundsPassed\u002B\u002B;\n\t\t\tif (lootRoundsPassed \u003E= loot_rounds)\n\t\t\t{\n\t\t\t\tCancelInvoke(RespawnLoot);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterRemove(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Remove(obj);\n\t\t\t}\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool flag)",
    "MethodSignature": "ToggleDefenderMode(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tprivate void ToggleDefenderMode(RPCMessage msg)\n\t{\n\t\tif (staticRespawn)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 player.CanBuild())\n\t\t{\n\t\t\tbool flag = msg.read.Bit();\n\t\t\tif (flag != IsInDefenderMode() \u0026\u0026 Interface.CallHook(\u0022OnSamSiteModeToggle\u0022, this, player, flag) == null)\n\t\t\t{\n\t\t\t\tSetFlag(Flag_DefenderMode, flag);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "OnItemStacked(Item slot2, Item item, ItemContainer newcontainer, int num2)",
    "MethodSignature": "MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap)",
    "MethodSourseCode": "\n\tpublic bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\n\t{\n\t\tusing (TimeWarning.New(\u0022MoveToContainer\u0022))\n\t\t{\n\t\t\tbool flag = iTargetPos == -1;\n\t\t\tItemContainer itemContainer = parent;\n\t\t\tIItemContainerEntity itemContainerEntity = default(IItemContainerEntity);\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\tif (allowStack \u0026\u0026 info.stackable \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item2 in from x in newcontainer.FindItemsByItemID(info.itemid)\n\t\t\t\t\t\torderby x.position\n\t\t\t\t\t\tselect x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item2.CanStack(this) \u0026\u0026 (ignoreStackLimit || item2.amount \u003C item2.MaxStackable()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = item2.position;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\titemContainerEntity = newcontainer.GetEntityOwner(returnHeldEntity: true) as IItemContainerEntity;\n\t\t\t\t\tif (itemContainerEntity != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = itemContainerEntity.GetIdealSlot(sourcePlayer, this);\n\t\t\t\t\t\tif (iTargetPos == int.MinValue)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\tif (newcontainer == parent)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) \u0026\u0026 info.isWearable;\n\t\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\n\t\t\t\t\tfor (int i = 0; i \u003C newcontainer.capacity; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag2 \u0026\u0026 slot != null \u0026\u0026 !slot.info.ItemModWearable.CanExistWith(itemModWearable))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newcontainer.availableSlots != null \u0026\u0026 newcontainer.availableSlots.Count \u003E 0 \u0026\u0026 DoItemSlotsConflict(slot))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2 \u0026\u0026 iTargetPos == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!CanMoveTo(newcontainer, iTargetPos))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 newcontainer.SlotTaken(this, iTargetPos))\n\t\t\t{\n\t\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\n\t\t\t\tif (slot2 == this)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (allowStack \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tint num = slot2.MaxStackable();\n\t\t\t\t\tif (slot2.CanStack(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ignoreStackLimit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum = int.MaxValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (slot2.amount \u003E= num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, amount);\n\t\t\t\t\t\tslot2.amount \u002B= num2;\n\t\t\t\t\t\tamount -= num2;\n\t\t\t\t\t\tslot2.MarkDirty();\n\t\t\t\t\t\tMarkDirty();\n\t\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, slot2, this, newcontainer, num2);\n\t\t\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRemoveFromWorld();\n\t\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\t\tRemove();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (parent != null \u0026\u0026 allowSwap \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer2 = parent;\n\t\t\t\t\tint iTargetPos2 = position;\n\t\t\t\t\tItemContainer itemContainer3 = slot2.parent;\n\t\t\t\t\tint num3 = slot2.position;\n\t\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\n\t\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\n\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\n\t\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\n\t\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\t\tSetParent(itemContainer2);\n\t\t\t\t\t\tposition = iTargetPos2;\n\t\t\t\t\t\tslot2.SetParent(itemContainer3);\n\t\t\t\t\t\tslot2.position = num3;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parent == newcontainer)\n\t\t\t{\n\t\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 iTargetPos != position \u0026\u0026 !parent.SlotTaken(this, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tposition = iTargetPos;\n\t\t\t\t\tMarkDirty();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (newcontainer.maxStackSize \u003E 0 \u0026\u0026 newcontainer.maxStackSize \u003C amount)\n\t\t\t{\n\t\t\t\tItem item = SplitItem(newcontainer.maxStackSize);\n\t\t\t\tif (item != null \u0026\u0026 !item.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) \u0026\u0026 (itemContainer == null || !item.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\n\t\t\t\t{\n\t\t\t\t\tVector3 dropPosition = newcontainer.dropPosition;\n\t\t\t\t\tVector3 dropVelocity = newcontainer.dropVelocity;\n\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, itemContainerEntity, this, newcontainer);\n\t\t\t\t\titem.Drop(dropPosition, dropVelocity);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!newcontainer.CanAccept(this))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseEntity entityOwner3 = GetEntityOwner();\n\t\t\tRemoveFromContainer();\n\t\t\tRemoveFromWorld();\n\t\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\n\t\t\tposition = iTargetPos;\n\t\t\tSetParent(newcontainer);\n\t\t\treturn true;\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 104
  },
  {
    "HookSignature": "OnSupplyDropDropped(BaseEntity baseEntity, CargoPlane cargoPlane)",
    "MethodSignature": "Update()",
    "MethodSourseCode": "\n\tprivate void Update()\n\t{\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsecondsTaken \u002B= Time.deltaTime;\n\t\tfloat num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);\n\t\tif (!dropped \u0026\u0026 num \u003E= 0.5f)\n\t\t{\n\t\t\tdropped = true;\n\t\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);\n\t\t\tif ((bool)baseEntity)\n\t\t\t{\n\t\t\t\tbaseEntity.globalBroadcast = true;\n\t\t\t\tbaseEntity.Spawn();\n\t\t\t\tInterface.CallHook(\u0022OnSupplyDropDropped\u0022, baseEntity, this);\n\t\t\t}\n\t\t}\n\t\tbase.transform.position = Vector3.Lerp(startPos, endPos, num);\n\t\tbase.transform.hasChanged = true;\n\t\tif (num \u003E= 1f)\n\t\t{\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnBradleyApcInitialize(BradleyAPC bradleyAPC)",
    "MethodSignature": "Initialize()",
    "MethodSourseCode": "\n\tpublic void Initialize()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcInitialize\u0022, this) == null)\n\t\t{\n\t\t\tmyRigidBody.centerOfMass = centerOfMass.localPosition;\n\t\t\tdestination = base.transform.position;\n\t\t\tfinalDestination = base.transform.position;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoShipEgress(CargoShip cargoShip)",
    "MethodSignature": "StartEgress()",
    "MethodSourseCode": "\n\tpublic void StartEgress()\n\t{\n\t\tif (!egressing \u0026\u0026 Interface.CallHook(\u0022OnCargoShipEgress\u0022, this) == null)\n\t\t{\n\t\t\tegressing = true;\n\t\t\tCancelInvoke(PlayHorn);\n\t\t\tradiation.SetActive(value: true);\n\t\t\tSetFlag(Flags.Reserved8, b: true);\n\t\t\tInvokeRepeating(UpdateRadiation, 10f, 1f);\n\t\t\tInvoke(DelayedDestroy, 60f * egress_duration_minutes);\n\t\t}\n\t}\n",
    "ClassName": "CargoShip",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcTarget(BaseEntity owner, BaseEntity entity)",
    "MethodSignature": "GetNearest(List\u003CBaseEntity\u003E entities, float rangeFraction)",
    "MethodSourseCode": "\n\tprivate BaseEntity GetNearest(List\u003CBaseEntity\u003E entities, float rangeFraction)\n\t{\n\t\tif (entities == null || entities.Count == 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tfloat num = float.PositiveInfinity;\n\t\tBaseEntity result = null;\n\t\tforeach (BaseEntity entity in entities)\n\t\t{\n\t\t\tif (!(entity == null) \u0026\u0026 !(entity.Health() \u003C= 0f) \u0026\u0026 Interface.CallHook(\u0022OnNpcTarget\u0022, owner, entity) == null)\n\t\t\t{\n\t\t\t\tfloat num2 = Vector3.Distance(entity.transform.position, owner.transform.position);\n\t\t\t\tif (num2 \u003C= rangeFraction * maxRange \u0026\u0026 num2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tresult = entity;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "AIBrainSenses",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnCrateHack(HackableLockedCrate hackableLockedCrate)",
    "MethodSignature": "StartHacking()",
    "MethodSourseCode": "\n\tpublic void StartHacking()\n\t{\n\t\tInterface.CallHook(\u0022OnCrateHack\u0022, this);\n\t\tBroadcastEntityMessage(\u0022HackingStarted\u0022, 20f, 256);\n\t\tSetFlag(Flags.Reserved1, b: true);\n\t\tInvokeRepeating(HackProgress, 1f, 1f);\n\t\tClientRPC(null, \u0022UpdateHackProgress\u0022, 0, (int)requiredHackSeconds);\n\t\tRefreshDecay();\n\t}\n",
    "ClassName": "HackableLockedCrate",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCargoPlaneSignaled(BaseEntity baseEntity, SupplySignal supplySignal)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tBaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\n\t\t\tbaseEntity.SendMessage(\u0022InitDropPosition\u0022, base.transform.position \u002B vector, SendMessageOptions.DontRequireReceiver);\n\t\t\tbaseEntity.Spawn();\n\t\t\tInterface.CallHook(\u0022OnCargoPlaneSignaled\u0022, baseEntity, this);\n\t\t}\n\t\tInvoke(FinishUp, 210f);\n\t\tSetFlag(Flags.On, b: true);\n\t\tSendNetworkUpdateImmediate();\n\t}\n",
    "ClassName": "SupplySignal",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "OnConversationAction(BasePlayer player, string action)",
    "MethodSourseCode": "\n\tpublic virtual void OnConversationAction(BasePlayer player, string action)\n\t{\n\t\tif (action == \u0022openvending\u0022)\n\t\t{\n\t\t\tInvisibleVendingMachine vendingMachine = GetVendingMachine();\n\t\t\tif (vendingMachine != null \u0026\u0026 Vector3.Distance(player.transform.position, base.transform.position) \u003C 5f)\n\t\t\t{\n\t\t\t\tForceEndConversation(player);\n\t\t\t\tif (Interface.CallHook(\u0022OnVendingShopOpen\u0022, vendingMachine, player) == null)\n\t\t\t\t{\n\t\t\t\t\tvendingMachine.PlayerOpenLoot(player, \u0022vendingmachine.customer\u0022, doPositionChecks: false);\n\t\t\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, vendingMachine, player);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(\u0022scrap\u0022);\n\t\tNPCConversationResultAction[] array = conversationResultActions;\n\t\tforeach (NPCConversationResultAction nPCConversationResultAction in array)\n\t\t{\n\t\t\tif (!(nPCConversationResultAction.action == action))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCleanupConversingPlayers();\n\t\t\tforeach (BasePlayer conversingPlayer in conversingPlayers)\n\t\t\t{\n\t\t\t\tif (!(conversingPlayer == player) \u0026\u0026 !(conversingPlayer == null))\n\t\t\t\t{\n\t\t\t\t\tint speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex(\u0022startbusy\u0022);\n\t\t\t\t\tForceSpeechNode(conversingPlayer, speechNodeIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = nPCConversationResultAction.scrapCost;\n\t\t\tList\u003CItem\u003E list = player.inventory.FindItemIDs(itemDefinition.itemid);\n\t\t\tforeach (Item item in list)\n\t\t\t{\n\t\t\t\tnum -= item.amount;\n\t\t\t}\n\t\t\tif (num \u003E 0)\n\t\t\t{\n\t\t\t\tint speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex(\u0022toopoor\u0022);\n\t\t\t\tForceSpeechNode(player, speechNodeIndex2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);\n\t\t\tnum = nPCConversationResultAction.scrapCost;\n\t\t\tforeach (Item item2 in list)\n\t\t\t{\n\t\t\t\tint num2 = Mathf.Min(num, item2.amount);\n\t\t\t\titem2.UseItem(num2);\n\t\t\t\tnum -= num2;\n\t\t\t\tif (num \u003C= 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastActionPlayer = player;\n\t\t\tBroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);\n\t\t\tlastActionPlayer = null;\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnTeamRejectInvite(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "rejectinvite(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void rejectinvite(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (!(basePlayer == null) \u0026\u0026 basePlayer.currentTeam == 0L)\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(uLong);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\tbasePlayer.ClearPendingInvite();\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnTeamRejectInvite\u0022, basePlayer, playerTeam) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RejectInvite(basePlayer);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnMaxStackable(Item item)",
    "MethodSignature": "MaxStackable()",
    "MethodSourseCode": "\n\tpublic int MaxStackable()\n\t{\n\t\tint num = info.stackable;\n\t\tif (parent != null \u0026\u0026 parent.maxStackSize \u003E 0)\n\t\t{\n\t\t\tnum = Mathf.Min(parent.maxStackSize, num);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnMaxStackable\u0022, this);\n\t\tif (obj is int)\n\t\t{\n\t\t\treturn (int)obj;\n\t\t}\n\t\treturn num;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnBradleyApcThink(BradleyAPC bradleyAPC)",
    "MethodSignature": "DoSimpleAI()",
    "MethodSourseCode": "\n\tpublic void DoSimpleAI()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);\n\t\tif (Interface.CallHook(\u0022OnBradleyApcThink\u0022, this) != null || !DoAI)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (targetList.Count \u003E 0)\n\t\t{\n\t\t\tif (targetList[0].IsValid() \u0026\u0026 targetList[0].IsVisible())\n\t\t\t{\n\t\t\t\tmainGunTarget = targetList[0].entity as BaseCombatEntity;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmainGunTarget = null;\n\t\t\t}\n\t\t\tUpdateMovement_Hunt();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmainGunTarget = null;\n\t\t\tUpdateMovement_Patrol();\n\t\t}\n\t\tAdvancePathMovement(force: false);\n\t\tfloat num = Vector3.Distance(base.transform.position, destination);\n\t\tfloat value = Vector3.Distance(base.transform.position, finalDestination);\n\t\tif (num \u003E stoppingDist)\n\t\t{\n\t\t\tVector3 lhs = Direction2D(destination, base.transform.position);\n\t\t\tfloat num2 = Vector3.Dot(lhs, base.transform.right);\n\t\t\tfloat num3 = Vector3.Dot(lhs, base.transform.right);\n\t\t\tfloat num4 = Vector3.Dot(lhs, -base.transform.right);\n\t\t\tif (Vector3.Dot(lhs, -base.transform.forward) \u003E num2)\n\t\t\t{\n\t\t\t\tif (num3 \u003E= num4)\n\t\t\t\t{\n\t\t\t\t\tturning = 1f;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tturning = -1f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tturning = Mathf.Clamp(num2 * 3f, -1f, 1f);\n\t\t\t}\n\t\t\tfloat throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));\n\t\t\tAvoidObstacles(ref throttleScaleFromTurn);\n\t\t\tfloat num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);\n\t\t\tif (!(throttle \u003E 0f) || !(num5 \u003C 0.5f))\n\t\t\t{\n\t\t\t\ttimeSinceSeemingStuck = 0f;\n\t\t\t}\n\t\t\telse if ((float)timeSinceSeemingStuck \u003E 10f)\n\t\t\t{\n\t\t\t\ttimeSinceStuckReverseStart = 0f;\n\t\t\t\ttimeSinceSeemingStuck = 0f;\n\t\t\t}\n\t\t\tfloat num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));\n\t\t\tif ((float)timeSinceStuckReverseStart \u003C 3f)\n\t\t\t{\n\t\t\t\tthrottle = -0.75f;\n\t\t\t\tturning = 1f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrottle = (0.1f \u002B Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn \u002B num6;\n\t\t\t}\n\t\t}\n\t\tDoWeaponAiming();\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnEntityMarkHostile(BaseCombatEntity baseCombatEntity, float duration)",
    "MethodSignature": "MarkHostileFor(float duration)",
    "MethodSourseCode": "\n\tpublic virtual void MarkHostileFor(float duration = 60f)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntityMarkHostile\u0022, this, duration) == null)\n\t\t{\n\t\t\tfloat b = UnityEngine.Time.realtimeSinceStartup \u002B duration;\n\t\t\tunHostileTime = Mathf.Max(unHostileTime, b);\n\t\t}\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerDrink(BasePlayer rpcPlayer, LiquidContainer liquidContainer)",
    "MethodSignature": "SVDrink(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void SVDrink(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.metabolism.CanConsume() || Interface.CallHook(\u0022OnPlayerDrink\u0022, rpc.player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tforeach (Item item in base.inventory.itemList)\n\t\t{\n\t\t\tItemModConsume component = item.info.GetComponent\u003CItemModConsume\u003E();\n\t\t\tif (!(component == null) \u0026\u0026 component.CanDoAction(item, rpc.player))\n\t\t\t{\n\t\t\t\tcomponent.DoAction(item, rpc.player);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "LiquidContainer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnSprinklerSplashed(Sprinkler sprinkler)",
    "MethodSignature": "DoSplash()",
    "MethodSourseCode": "\n\tprivate void DoSplash()\n\t{\n\t\tusing (TimeWarning.New(\u0022SprinklerSplash\u0022))\n\t\t{\n\t\t\tint num = WaterPerSplash;\n\t\t\tif ((float)updateSplashableCache \u003E SplashFrequency * 4f || forceUpdateSplashables)\n\t\t\t{\n\t\t\t\tcachedSplashables.Clear();\n\t\t\t\tforceUpdateSplashables = false;\n\t\t\t\tupdateSplashableCache = 0f;\n\t\t\t\tVector3 position = Eyes.position;\n\t\t\t\tVector3 up = base.transform.up;\n\t\t\t\tfloat sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;\n\t\t\t\tfloat value = Vector3.Angle(up, Vector3.up) / 180f;\n\t\t\t\tvalue = Mathf.Clamp(value, 0.2f, 1f);\n\t\t\t\tsprinklerEyeHeightOffset *= value;\n\t\t\t\tVector3 startPosition = position \u002B up * (Server.sprinklerRadius * 0.5f);\n\t\t\t\tVector3 endPosition = position \u002B up * sprinklerEyeHeightOffset;\n\t\t\t\tList\u003CBaseEntity\u003E obj = Facepunch.Pool.GetList\u003CBaseEntity\u003E();\n\t\t\t\tVis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1236478737);\n\t\t\t\tif (obj.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tforeach (BaseEntity item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!item.isClient \u0026\u0026 item is ISplashable splashable \u0026\u0026 !cachedSplashables.Contains(splashable) \u0026\u0026 splashable.WantsSplash(currentFuelType, num) \u0026\u0026 item.IsVisible(position) \u0026\u0026 (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcachedSplashables.Add(splashable);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t}\n\t\t\tif (cachedSplashables.Count \u003E 0)\n\t\t\t{\n\t\t\t\tint amount = num / cachedSplashables.Count;\n\t\t\t\tforeach (ISplashable cachedSplashable in cachedSplashables)\n\t\t\t\t{\n\t\t\t\t\tif (!ObjectEx.IsUnityNull(cachedSplashable) \u0026\u0026 cachedSplashable.WantsSplash(currentFuelType, amount))\n\t\t\t\t\t{\n\t\t\t\t\t\tint num2 = cachedSplashable.DoSplash(currentFuelType, amount);\n\t\t\t\t\t\tnum -= num2;\n\t\t\t\t\t\tif (num \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DecayPerSplash \u003E 0f)\n\t\t\t{\n\t\t\t\tHurt(DecayPerSplash);\n\t\t\t}\n\t\t}\n\t\tInterface.CallHook(\u0022OnSprinklerSplashed\u0022, this);\n\t}\n",
    "ClassName": "Sprinkler",
    "HookLineInvoke": 54
  },
  {
    "HookSignature": "OnBookmarkAdd(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "AddBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void AddBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player) || isStatic)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003C nextAddTime)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Slow down...\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (controlBookmarks.Count \u003E= 128)\n\t\t{\n\t\t\tplayer.ChatMessage(\u0022Too many bookmarks, delete some\u0022);\n\t\t\treturn;\n\t\t}\n\t\tnextAddTime = UnityEngine.Time.realtimeSinceStartup \u002B 1f;\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnBookmarkAdd\u0022, this, player, text) == null)\n\t\t{\n\t\t\tForceAddBookmark(text);\n\t\t\tSendControlBookmarks(player);\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnTurretModeToggle(AutoTurret autoTurret)",
    "MethodSignature": "SetPeacekeepermode(bool isOn)",
    "MethodSourseCode": "\n\tpublic void SetPeacekeepermode(bool isOn)\n\t{\n\t\tif (PeacekeeperMode() != isOn)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved1, isOn);\n\t\t\tEffect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInterface.CallHook(\u0022OnTurretModeToggle\u0022, this);\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnCorpsePopulate(GingerbreadNPC gingerbreadNPC, NPCPlayerCorpse nPCPlayerCorpse)",
    "MethodSignature": "CreateCorpse()",
    "MethodSourseCode": "\n\tpublic override BaseCorpse CreateCorpse()\n\t{\n\t\tusing (TimeWarning.New(\u0022Create corpse\u0022))\n\t\t{\n\t\t\tstring corpseResourcePath = CorpseResourcePath;\n\t\t\tNPCPlayerCorpse nPCPlayerCorpse = DropCorpse(corpseResourcePath) as NPCPlayerCorpse;\n\t\t\tif ((bool)nPCPlayerCorpse)\n\t\t\t{\n\t\t\t\tnPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position \u002B Vector3.down * NavAgent.baseOffset;\n\t\t\t\tnPCPlayerCorpse.SetLootableIn(2f);\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));\n\t\t\t\tnPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);\n\t\t\t\tnPCPlayerCorpse.TakeFrom(inventory.containerMain);\n\t\t\t\tnPCPlayerCorpse.playerName = \u0022Gingerbread\u0022;\n\t\t\t\tnPCPlayerCorpse.playerSteamID = userID;\n\t\t\t\tnPCPlayerCorpse.Spawn();\n\t\t\t\tItemContainer[] containers = nPCPlayerCorpse.containers;\n\t\t\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tcontainers[i].Clear();\n\t\t\t\t}\n\t\t\t\tif (LootSpawnSlots.Length != 0)\n\t\t\t\t{\n\t\t\t\t\tobject obj = Interface.CallHook(\u0022OnCorpsePopulate\u0022, this, nPCPlayerCorpse);\n\t\t\t\t\tif (obj is BaseCorpse)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (BaseCorpse)obj;\n\t\t\t\t\t}\n\t\t\t\t\tLootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;\n\t\t\t\t\tfor (int i = 0; i \u003C lootSpawnSlots.Length; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tLootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];\n\t\t\t\t\t\tfor (int j = 0; j \u003C lootSpawnSlot.numberToSpawn; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= lootSpawnSlot.probability)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nPCPlayerCorpse;\n\t\t}\n\t}\n",
    "ClassName": "GingerbreadNPC",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnItemCraft(IndustrialCrafter industrialCrafter, ItemBlueprint blueprint)",
    "MethodSignature": "RunJob()",
    "MethodSourseCode": "\n\tprotected override void RunJob()\n\t{\n\t\tbase.RunJob();\n\t\tif (ConVar.Server.industrialCrafterFrequency \u003C= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i \u003C= 3; i\u002B\u002B)\n\t\t{\n\t\t\tItem targetBlueprint = GetTargetBlueprint(i);\n\t\t\tif (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel \u003C targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\n\t\t\tif (Interface.CallHook(\u0022OnItemCraft\u0022, this, blueprint) != null)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tforeach (ItemAmount ingredient in blueprint.ingredients)\n\t\t\t{\n\t\t\t\tif ((float)GetInputAmount(ingredient.itemDef) \u003C ingredient.amount)\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflag = false;\n\t\t\tfor (int j = 8; j \u003C= 11; j\u002B\u002B)\n\t\t\t{\n\t\t\t\tItem slot = inventory.GetSlot(j);\n\t\t\t\tif (slot == null || (slot.info == targetBlueprint.blueprintTargetDef \u0026\u0026 slot.amount \u002B blueprint.amountToCreate \u003C= slot.MaxStackable()))\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\tforeach (ItemAmount ingredient2 in blueprint.ingredients)\n\t\t\t{\n\t\t\t\tConsumeInputIngredient(ingredient2);\n\t\t\t}\n\t\t\tcurrentlyCrafting = targetBlueprint.blueprintTargetDef;\n\t\t\tcurrentlyCraftingAmount = blueprint.amountToCreate;\n\t\t\tfloat time = blueprint.time;\n\t\t\tInvoke(CompleteCraft, time);\n\t\t\tjobFinishes = time;\n\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\tClientRPC((Connection)null, \u0022ClientUpdateCraftTimeRemaining\u0022, (float)jobFinishes, jobFinishes.Duration);\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "IndustrialCrafter",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSignature": "Kick(string reason)",
    "MethodSourseCode": "\n\tpublic void Kick(string reason)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(net.connection, reason);\n\t\t\tInterface.CallHook(\u0022OnPlayerKicked\u0022, this, reason);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnMlrsFire(MLRS mLRS, BasePlayer owner)",
    "MethodSignature": "Fire(BasePlayer owner)",
    "MethodSourseCode": "\n\tpublic void Fire(BasePlayer owner)\n\t{\n\t\tUpdateStorageState();\n\t\tif (CanFire \u0026\u0026 !(_mounted == null) \u0026\u0026 Interface.CallHook(\u0022OnMlrsFire\u0022, this, owner) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved6, b: true);\n\t\t\tradiusModIndex = 0;\n\t\t\tnextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);\n\t\t\trocketOwnerRef.Set(owner);\n\t\t\tInvokeRepeating(FireNextRocket, 0f, 0.5f);\n\t\t\tInterface.CallHook(\u0022OnMlrsFired\u0022, this, owner);\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnItemRecycleAmount(Item slot, int num3, Recycler recycler)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\n\tpublic void RecycleThink()\n\t{\n\t\tbool flag = false;\n\t\tfloat num = recycleEfficiency;\n\t\tint num2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (num2 \u003C 6)\n\t\t\t{\n\t\t\t\tItem slot = base.inventory.GetSlot(num2);\n\t\t\t\tif (!CanBeRecycled(slot))\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnItemRecycle\u0022, slot, this) != null)\n\t\t\t\t{\n\t\t\t\t\tif (!HasRecyclable())\n\t\t\t\t\t{\n\t\t\t\t\t\tStopRecycling();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (slot.hasCondition)\n\t\t\t\t{\n\t\t\t\t\tnum = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\n\t\t\t\t}\n\t\t\t\tint num3 = 1;\n\t\t\t\tif (slot.amount \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tnum3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnItemRecycleAmount\u0022, slot, num3, this);\n\t\t\t\tif (obj is int)\n\t\t\t\t{\n\t\t\t\t\tnum3 = (int)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tint num4 = slot.info.Blueprint.scrapFromRecycle * num3;\n\t\t\t\t\tif (slot.MaxStackable() == 1 \u0026\u0026 slot.hasCondition)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);\n\t\t\t\t\t}\n\t\t\t\t\tif (num4 \u003E= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = ItemManager.CreateByName(\u0022scrap\u0022, num4, 0uL);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\n\t\t\t\t\t\tMoveItemToOutput(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBasePlayer\u003E obj2 = Facepunch.Pool.GetList\u003CBasePlayer\u003E();\n\t\t\t\t\tVis.Entities(base.transform.position, 3f, obj2, 131072);\n\t\t\t\t\tforeach (BasePlayer item3 in obj2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.IsAlive() \u0026\u0026 !item3.IsSleeping() \u0026\u0026 item3.inventory.loot.entitySource == this)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);\n\t\t\t\t\t\t\titem3.stats.Save();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);\n\t\t\t\tslot.UseItem(num3);\n\t\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.ingredients)\n\t\t\t\t{\n\t\t\t\t\tif (ingredient.itemDef.shortname == \u0022scrap\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;\n\t\t\t\t\tint num6 = 0;\n\t\t\t\t\tif (num5 \u003C= 1f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= num5 * num)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum6\u002B\u002B;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;\n\t\t\t\t\t}\n\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);\n\t\t\t\t\tfor (int j = 0; j \u003C num7; j\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num8 = ((num6 \u003E ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);\n\t\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\n\t\t\t\t\t\tif (!MoveItemToOutput(item2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum6 -= num8;\n\t\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || !HasRecyclable())\n\t\t\t{\n\t\t\t\tStopRecycling();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer msgPlayer, BuildingGrade.Enum @enum, ulong num)",
    "MethodSignature": "DoUpgradeToGrade(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void DoUpgradeToGrade(RPCMessage msg)\n\t{\n\t\tif (msg.player.CanInteract())\n\t\t{\n\t\t\tBuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();\n\t\t\tulong num = msg.read.UInt64();\n\t\t\tConstructionGrade constructionGrade = blockDefinition.GetGrade(@enum, num);\n\t\t\tif (!(constructionGrade == null) \u0026\u0026 CanChangeToGrade(@enum, num, msg.player) \u0026\u0026 Interface.CallHook(\u0022OnStructureUpgrade\u0022, this, msg.player, @enum, num) == null \u0026\u0026 CanAffordUpgrade(@enum, num, msg.player) \u0026\u0026 !(base.SecondsSinceAttacked \u003C 30f) \u0026\u0026 (num == 0L || msg.player.blueprints.steamInventory.HasItem((int)num)))\n\t\t\t{\n\t\t\t\tPayForUpgrade(constructionGrade, msg.player);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, @enum);\n\t\t\t\tOnSkinChanged(skinID, num);\n\t\t\t\tChangeGrade(@enum, playEffect: true);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BuildingBlock",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnSendCommand(System.Collections.Generic.List\u003CNetwork.Connection\u003E cn, string strCommand, object[] args)",
    "MethodSignature": "SendClientCommand(List\u003CConnection\u003E cn, string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void SendClientCommand(List\u003CConnection\u003E cn, string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnSendCommand\u0022, cn, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tnetWrite.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tnetWrite.Send(new SendInfo(cn));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBradleyApcHunt(BradleyAPC bradleyAPC)",
    "MethodSignature": "UpdateMovement_Hunt()",
    "MethodSourseCode": "\n\tpublic void UpdateMovement_Hunt()\n\t{\n\t\tif (Interface.CallHook(\u0022OnBradleyApcHunt\u0022, this) != null || patrolPath == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTargetInfo targetInfo = targetList[0];\n\t\tif (!targetInfo.IsValid())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (HasPath() \u0026\u0026 targetInfo.IsVisible())\n\t\t{\n\t\t\tif (currentPath.Count \u003E 1)\n\t\t\t{\n\t\t\t\tVector3 item = currentPath[currentPathIndex];\n\t\t\t\tClearPath();\n\t\t\t\tcurrentPath.Add(item);\n\t\t\t\tfinalDestination = item;\n\t\t\t\tcurrentPathIndex = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!(UnityEngine.Time.time \u003E nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tIAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);\n\t\t\tList\u003CIAIPathNode\u003E nodes = Facepunch.Pool.GetList\u003CIAIPathNode\u003E();\n\t\t\tif (GetEngagementPath(ref nodes))\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tstart = nodes[nodes.Count - 1];\n\t\t\t}\n\t\t\tIAIPathNode iAIPathNode = null;\n\t\t\tList\u003CIAIPathNode\u003E nearNodes = Facepunch.Pool.GetList\u003CIAIPathNode\u003E();\n\t\t\tpatrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);\n\t\t\tStack\u003CIAIPathNode\u003E stack = null;\n\t\t\tfloat num = float.PositiveInfinity;\n\t\t\tfloat y = mainTurretEyePos.localPosition.y;\n\t\t\tforeach (IAIPathNode item2 in nearNodes)\n\t\t\t{\n\t\t\t\tStack\u003CIAIPathNode\u003E path = new Stack\u003CIAIPathNode\u003E();\n\t\t\t\tif (targetInfo.entity.IsVisible(item2.Position \u002B new Vector3(0f, y, 0f)) \u0026\u0026 AStarPath.FindPath(start, item2, out path, out var pathCost) \u0026\u0026 pathCost \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path;\n\t\t\t\t\tnum = pathCost;\n\t\t\t\t\tiAIPathNode = item2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack == null \u0026\u0026 nearNodes.Count \u003E 0)\n\t\t\t{\n\t\t\t\tStack\u003CIAIPathNode\u003E path2 = new Stack\u003CIAIPathNode\u003E();\n\t\t\t\tIAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];\n\t\t\t\tif (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) \u0026\u0026 pathCost2 \u003C num)\n\t\t\t\t{\n\t\t\t\t\tstack = path2;\n\t\t\t\t\tiAIPathNode = iAIPathNode2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stack != null)\n\t\t\t{\n\t\t\t\tcurrentPath.Clear();\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C nodes.Count - 1; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentPath.Add(nodes[i].Position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tforeach (IAIPathNode item3 in stack)\n\t\t\t\t{\n\t\t\t\t\tcurrentPath.Add(item3.Position);\n\t\t\t\t}\n\t\t\t\tcurrentPathIndex = -1;\n\t\t\t\tpathLooping = false;\n\t\t\t\tfinalDestination = iAIPathNode.Position;\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref nearNodes);\n\t\t\tFacepunch.Pool.FreeList(ref nodes);\n\t\t\tnextEngagementPathTime = UnityEngine.Time.time \u002B 5f;\n\t\t}\n\t}\n",
    "ClassName": "BradleyAPC",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRconConnection(System.Net.IPAddress iPEndPointAddress)",
    "MethodSignature": "ProcessConnections()",
    "MethodSourseCode": "\n\t\tprivate void ProcessConnections()\n\t\t{\n\t\t\tif (!server.Pending())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSocket socket = server.AcceptSocket();\n\t\t\tif (socket != null)\n\t\t\t{\n\t\t\t\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\n\t\t\t\tif (Interface.CallHook(\u0022OnRconConnection\u0022, iPEndPoint.Address) != null)\n\t\t\t\t{\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse if (IsBanned(iPEndPoint.Address))\n\t\t\t\t{\n\t\t\t\t\tDebug.Log(\u0022[RCON] Ignoring connection - banned. \u0022 \u002B iPEndPoint.Address.ToString());\n\t\t\t\t\tsocket.Close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tclients.Add(new RConClient(socket));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
    "ClassName": "RCon",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanCastFishingRod(BasePlayer ownerPlayer, BaseFishingRod baseFishingRod, Item currentLure, UnityEngine.Vector3 pos)",
    "MethodSignature": "Server_RequestCast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void Server_RequestCast(RPCMessage msg)\n\t{\n\t\tVector3 pos = msg.read.Vector3();\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tItem currentLure = GetCurrentLure();\n\t\tif (currentLure == null)\n\t\t{\n\t\t\tFailedCast(FailReason.NoLure);\n\t\t\treturn;\n\t\t}\n\t\tif (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))\n\t\t{\n\t\t\tFailedCast(reason);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCastFishingRod\u0022, ownerPlayer, this, currentLure, pos);\n\t\tif (!(obj is bool) || (bool)obj)\n\t\t{\n\t\t\tFishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position \u002B Vector3.up * 2.8f \u002B ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent\u003CFishingBobber\u003E();\n\t\t\tcomponent.transform.forward = GetOwnerPlayer().eyes.BodyForward();\n\t\t\tcomponent.Spawn();\n\t\t\tcomponent.InitialiseBobber(ownerPlayer, surfaceBody, pos);\n\t\t\tlureUsed = currentLure.info;\n\t\t\tcurrentLure.UseItem();\n\t\t\tif (fishLookup == null)\n\t\t\t{\n\t\t\t\tfishLookup = PrefabAttribute.server.Find\u003CFishLookup\u003E(prefabID);\n\t\t\t}\n\t\t\tcurrentFishTarget = fishLookup.GetFish(component.transform.position, surfaceBody, lureUsed, out fishableModifier, lastFish);\n\t\t\tlastFish = fishableModifier;\n\t\t\tcurrentBobber.Set(component);\n\t\t\tClientRPC(null, \u0022Client_ReceiveCastPoint\u0022, component.net.ID);\n\t\t\townerPlayer.SignalBroadcast(Signal.Attack);\n\t\t\tcatchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));\n\t\t\tcatchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;\n\t\t\tfloat val = (lureUsed.TryGetComponent\u003CItemModCompostable\u003E(out var component2) ? component2.BaitValue : 0f);\n\t\t\tval = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);\n\t\t\tcatchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);\n\t\t\tplayerStartPosition = ownerPlayer.transform.position;\n\t\t\tSetFlag(Flags.Busy, b: true);\n\t\t\tCurrentState = CatchState.Waiting;\n\t\t\tInvokeRepeating(CatchProcess, 0f, 0f);\n\t\t\tinQueue = false;\n\t\t\tInterface.CallHook(\u0022OnFishingRodCast\u0022, this, ownerPlayer, currentLure);\n\t\t}\n\t}\n",
    "ClassName": "BaseFishingRod",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnRfBroadcasterRemoved(IRFObject obj, int frequency)",
    "MethodSignature": "RemoveBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void RemoveBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterRemove\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Remove(obj);\n\t\t\t}\n\t\t\tMarkFrequencyDirty(frequency);\n\t\t\tInterface.CallHook(\u0022OnRfBroadcasterRemoved\u0022, obj, frequency);\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanTakeCutting(BasePlayer player, GrowableEntity growableEntity)",
    "MethodSignature": "TakeClones(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void TakeClones(BasePlayer player)\n\t{\n\t\tif (player == null || !CanClone() || Interface.CallHook(\u0022CanTakeCutting\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Properties.BaseCloneCount \u002B Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;\n\t\tif (num \u003E 0)\n\t\t{\n\t\t\tItem item = ItemManager.Create(Properties.CloneItem, num, 0uL);\n\t\t\tGrowableGeneEncoding.EncodeGenesToItem(this, item);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);\n\t\t\tplayer.GiveItem(item, GiveItemReason.ResourceHarvested);\n\t\t\tif (Properties.pickEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tDie();\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnShopCompleteTrade(ShopFront shopFront)",
    "MethodSignature": "CompleteTrade()",
    "MethodSourseCode": "\n\tpublic void CompleteTrade()\n\t{\n\t\tif (vendorPlayer != null \u0026\u0026 customerPlayer != null \u0026\u0026 HasFlag(Flags.Reserved1) \u0026\u0026 HasFlag(Flags.Reserved2))\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnShopCompleteTrade\u0022, this) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tswappingItems = true;\n\t\t\t\tfor (int num = vendorInventory.capacity - 1; num \u003E= 0; num--)\n\t\t\t\t{\n\t\t\t\t\tItem slot = vendorInventory.GetSlot(num);\n\t\t\t\t\tItem slot2 = customerInventory.GetSlot(num);\n\t\t\t\t\tif ((bool)customerPlayer \u0026\u0026 slot != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcustomerPlayer.GiveItem(slot);\n\t\t\t\t\t}\n\t\t\t\t\tif ((bool)vendorPlayer \u0026\u0026 slot2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvendorPlayer.GiveItem(slot2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tswappingItems = false;\n\t\t\t}\n\t\t\tEffect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);\n\t\t}\n\t\tResetTrade();\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnWorldProjectileCreate(HitInfo info, Item item)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnWorldProjectileCreate\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\tcomponent.WakeUp();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "CanNetworkTo(BaseNetworkable baseNetworkable, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (net.group == null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn player.net.subscriber.IsSubscribed(net.group);\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCounterTargetChange(PowerCounter powerCounter, BasePlayer msgPlayer, int num)",
    "MethodSignature": "SERVER_SetTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void SERVER_SetTarget(RPCMessage msg)\n\t{\n\t\tint num = msg.read.Int32();\n\t\tif (Interface.CallHook(\u0022OnCounterTargetChange\u0022, this, msg.player, num) == null \u0026\u0026 CanPlayerAdmin(msg.player))\n\t\t{\n\t\t\ttargetCounterNumber = num;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "PowerCounter",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "IOnPlayerBanned(Network.Connection connection, AuthResponse Status)",
    "MethodSignature": "OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)",
    "MethodSourseCode": "\n\tinternal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)\n\t{\n\t\tif (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) =\u003E x.userid == SteamId);\n\t\tif (connection == null)\n\t\t{\n\t\t\tDebug.LogWarning($\u0022Steam gave us a {Status} ticket response for unconnected id {SteamId}\u0022);\n\t\t\treturn;\n\t\t}\n\t\tswitch (Status)\n\t\t{\n\t\tcase AuthResponse.OK:\n\t\t\tDebug.LogWarning($\u0022Steam gave us a \u0027ok\u0027 ticket response for already connected id {SteamId}\u0022);\n\t\t\treturn;\n\t\tcase AuthResponse.TimedOut:\n\t\t\treturn;\n\t\tcase AuthResponse.VACBanned:\n\t\tcase AuthResponse.PublisherBanned:\n\t\t\tif (!bannedPlayerNotices.Contains(SteamId))\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022IOnPlayerBanned\u0022, connection, Status);\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username.EscapeRichText() \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\tbannedPlayerNotices.Add(SteamId);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tDebug.Log($\u0022Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \\\u0022{Status.ToString()}\\\u0022)\u0022);\n\t\tconnection.authStatus = Status.ToString();\n\t\tNetwork.Net.sv.Kick(connection, \u0022Steam: \u0022 \u002B Status);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnItemSplit(Item item, int split_Amount)",
    "MethodSignature": "SplitItem(int split_Amount)",
    "MethodSourseCode": "\n\tpublic Item SplitItem(int split_Amount)\n\t{\n\t\tAssert.IsTrue(split_Amount \u003E 0, \u0022split_Amount \u003C= 0\u0022);\n\t\tif (split_Amount \u003C= 0)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (split_Amount \u003E= amount)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnItemSplit\u0022, this, split_Amount);\n\t\tif (obj is Item)\n\t\t{\n\t\t\treturn (Item)obj;\n\t\t}\n\t\tamount -= split_Amount;\n\t\tItem item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);\n\t\titem.amount = split_Amount;\n\t\titem.skin = skin;\n\t\tif (IsBlueprint())\n\t\t{\n\t\t\titem.blueprintTarget = blueprintTarget;\n\t\t}\n\t\tif (info.amountType == ItemDefinition.AmountType.Genetics \u0026\u0026 instanceData != null \u0026\u0026 instanceData.dataInt != 0)\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataInt = instanceData.dataInt;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t}\n\t\tif (instanceData != null \u0026\u0026 instanceData.dataInt \u003E 0 \u0026\u0026 info != null \u0026\u0026 info.Blueprint != null \u0026\u0026 info.Blueprint.workbenchLevelRequired == 3)\n\t\t{\n\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\titem.instanceData.dataInt = instanceData.dataInt;\n\t\t\titem.instanceData.ShouldPool = false;\n\t\t\titem.SetFlag(Flag.IsOn, IsOn());\n\t\t}\n\t\tMarkDirty();\n\t\treturn item;\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnSwitchToggled(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnEntitySnapshot(BaseNetworkable ent, Network.Connection netConnection)",
    "MethodSignature": "SendEntitySnapshot(BaseNetworkable ent)",
    "MethodSourseCode": "\n\tpublic void SendEntitySnapshot(BaseNetworkable ent)\n\t{\n\t\tif (Interface.CallHook(\u0022OnEntitySnapshot\u0022, ent, net.connection) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022SendEntitySnapshot\u0022))\n\t\t{\n\t\t\tif (!(ent == null) \u0026\u0026 ent.net != null \u0026\u0026 ent.ShouldNetworkTo(this))\n\t\t\t{\n\t\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\t\tnet.connection.validate.entityUpdates\u002B\u002B;\n\t\t\t\tSaveInfo saveInfo = default(SaveInfo);\n\t\t\t\tsaveInfo.forConnection = net.connection;\n\t\t\t\tsaveInfo.forDisk = false;\n\t\t\t\tSaveInfo saveInfo2 = saveInfo;\n\t\t\t\tnetWrite.PacketID(Message.Type.Entities);\n\t\t\t\tnetWrite.UInt32(net.connection.validate.entityUpdates);\n\t\t\t\tent.ToStreamForNetwork(netWrite, saveInfo2);\n\t\t\t\tnetWrite.Send(new SendInfo(net.connection));\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnCupboardClearList(BuildingPrivlidge buildingPrivlidge, BasePlayer rpcPlayer)",
    "MethodSignature": "ClearList(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ClearList(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 CanAdministrate(rpc.player) \u0026\u0026 Interface.CallHook(\u0022OnCupboardClearList\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tauthorizedPlayers.Clear();\n\t\t\tUpdateMaxAuthCapacity();\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "BuildingPrivlidge",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSeeStash(BasePlayer player, StashContainer stashContainer)",
    "MethodSignature": "RPC_WantsUnhide(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_WantsUnhide(RPCMessage rpc)\n\t{\n\t\tif (IsHidden())\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif (PlayerInRange(player) \u0026\u0026 Interface.CallHook(\u0022CanSeeStash\u0022, player, this) == null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);\n\t\t\t\tSetHidden(isHidden: false);\n\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "IOnUserApprove(Network.Connection connection)",
    "MethodSignature": "OnNewConnection(Connection connection)",
    "MethodSourseCode": "\n\tpublic void OnNewConnection(Connection connection)\n\t{\n\t\tconnection.connected = false;\n\t\tif (connection.token == null || connection.token.Length \u003C 32)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid Token\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.userid == 0L)\n\t\t{\n\t\t\tReject(connection, \u0022Invalid SteamID\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (connection.protocol != 2388)\n\t\t{\n\t\t\tif (!DeveloperList.Contains(connection.userid))\n\t\t\t{\n\t\t\t\tReject(connection, \u0022Incompatible Version\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDebugEx.Log(\u0022Not kicking \u0022 \u002B connection.userid \u002B \u0022 for incompatible protocol (is a developer)\u0022);\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))\n\t\t{\n\t\t\tServerUsers.User user = ServerUsers.Get(connection.userid);\n\t\t\tstring text = user?.notes ?? \u0022no reason given\u0022;\n\t\t\tstring text2 = ((user != null \u0026\u0026 user.expiry \u003E 0) ? (\u0022 for \u0022 \u002B (user.expiry - Epoch.Current).FormatSecondsLong()) : \u0022\u0022);\n\t\t\tReject(connection, \u0022You are banned from this server\u0022 \u002B text2 \u002B \u0022 (\u0022 \u002B text \u002B \u0022)\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 1\u0022);\n\t\t\tconnection.authLevel = 1u;\n\t\t}\n\t\tif (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 has auth level 2\u0022);\n\t\t\tconnection.authLevel = 2u;\n\t\t}\n\t\tif (DeveloperList.Contains(connection.userid))\n\t\t{\n\t\t\tDebugEx.Log(connection.ToString() \u002B \u0022 is a developer\u0022);\n\t\t\tconnection.authLevel = 3u;\n\t\t}\n\t\tif (Interface.CallHook(\u0022IOnUserApprove\u0022, connection) == null)\n\t\t{\n\t\t\tm_AuthConnection.Add(connection);\n\t\t\tStartCoroutine(AuthorisationRoutine(connection));\n\t\t}\n\t}\n",
    "ClassName": "ConnectionAuth",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "OnBookmarkDelete(ComputerStation computerStation, BasePlayer player, string text)",
    "MethodSignature": "DeleteBookmark(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void DeleteBookmark(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!IsPlayerAdmin(player) || isStatic)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (IsValidIdentifier(text) \u0026\u0026 controlBookmarks.Contains(text) \u0026\u0026 Interface.CallHook(\u0022OnBookmarkDelete\u0022, this, player, text) == null)\n\t\t{\n\t\t\tcontrolBookmarks.Remove(text);\n\t\t\tSendControlBookmarks(player);\n\t\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\t\tif (baseEntity != null \u0026\u0026 baseEntity.TryGetComponent\u003CIRemoteControllable\u003E(out var component) \u0026\u0026 component.GetIdentifier() == text)\n\t\t\t{\n\t\t\t\tStopControl(player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnMeleeAttack(BasePlayer player, HitInfo hitInfo)",
    "MethodSignature": "PlayerAttack(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tpublic void PlayerAttack(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tusing (TimeWarning.New(\u0022PlayerAttack\u0022, 50))\n\t\t{\n\t\t\tusing PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);\n\t\t\tif (playerAttack == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tHitInfo hitInfo = Facepunch.Pool.Get\u003CHitInfo\u003E();\n\t\t\thitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);\n\t\t\thitInfo.Initiator = player;\n\t\t\thitInfo.Weapon = this;\n\t\t\thitInfo.WeaponPrefab = this;\n\t\t\thitInfo.Predicted = msg.connection;\n\t\t\thitInfo.damageProperties = damageProperties;\n\t\t\tif (Interface.CallHook(\u0022OnMeleeAttack\u0022, player, hitInfo) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (hitInfo.IsNaNOrInfinity())\n\t\t\t{\n\t\t\t\tstring shortPrefabName = base.ShortPrefabName;\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Contains NaN (\u0022 \u002B shortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_nan\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity hitEntity = hitInfo.HitEntity;\n\t\t\tBasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;\n\t\t\tbool flag = basePlayer != null;\n\t\t\tbool flag2 = flag \u0026\u0026 basePlayer.IsSleeping();\n\t\t\tbool flag3 = flag \u0026\u0026 basePlayer.IsWounded();\n\t\t\tbool flag4 = flag \u0026\u0026 basePlayer.isMounted;\n\t\t\tbool flag5 = flag \u0026\u0026 basePlayer.HasParent();\n\t\t\tbool flag6 = hitEntity != null;\n\t\t\tbool flag7 = flag6 \u0026\u0026 hitEntity.IsNpc;\n\t\t\tbool flag8;\n\t\t\tint layerMask;\n\t\t\tVector3 center;\n\t\t\tVector3 position;\n\t\t\tVector3 vector;\n\t\t\tVector3 vector2;\n\t\t\tVector3 vector3;\n\t\t\tint num15;\n\t\t\tif (ConVar.AntiHack.melee_protection \u003E 0)\n\t\t\t{\n\t\t\t\tflag8 = true;\n\t\t\t\tfloat num = 1f \u002B ConVar.AntiHack.melee_forgiveness;\n\t\t\t\tfloat melee_clientframes = ConVar.AntiHack.melee_clientframes;\n\t\t\t\tfloat melee_serverframes = ConVar.AntiHack.melee_serverframes;\n\t\t\t\tfloat num2 = melee_clientframes / 60f;\n\t\t\t\tfloat num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);\n\t\t\t\tfloat num4 = (player.desyncTimeClamped \u002B num2 \u002B num3) * num;\n\t\t\t\tlayerMask = (ConVar.AntiHack.melee_terraincheck ? 10551296 : 2162688);\n\t\t\t\tif (flag \u0026\u0026 hitInfo.boneArea == (HitArea)(-1))\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName2 = base.ShortPrefabName;\n\t\t\t\t\tstring shortPrefabName3 = basePlayer.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Bone is invalid  (\u0022 \u002B shortPrefabName2 \u002B \u0022 on \u0022 \u002B shortPrefabName3 \u002B \u0022 bone \u0022 \u002B hitInfo.HitBone \u002B \u0022)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_bone\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 2)\n\t\t\t\t{\n\t\t\t\t\tif (flag6)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num5 = hitEntity.MaxVelocity() \u002B hitEntity.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num6 = hitEntity.BoundsPadding() \u002B num4 * num5;\n\t\t\t\t\t\tfloat num7 = hitEntity.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num7 \u003E num6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName4 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName5 = hitEntity.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Entity too far away (\u0022 \u002B shortPrefabName4 \u002B \u0022 on \u0022 \u002B shortPrefabName5 \u002B \u0022 with \u0022 \u002B num7 \u002B \u0022m \u003E \u0022 \u002B num6 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_target\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4 \u0026\u0026 flag8 \u0026\u0026 flag \u0026\u0026 !flag7 \u0026\u0026 !flag2 \u0026\u0026 !flag3 \u0026\u0026 !flag4 \u0026\u0026 !flag5)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude = basePlayer.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num8 = basePlayer.BoundsPadding() \u002B num4 * magnitude \u002B ConVar.AntiHack.tickhistoryforgiveness;\n\t\t\t\t\t\tfloat num9 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num9 \u003E num8)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName6 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring shortPrefabName7 = basePlayer.ShortPrefabName;\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Player too far away (\u0022 \u002B shortPrefabName6 \u002B \u0022 on \u0022 \u002B shortPrefabName7 \u002B \u0022 with \u0022 \u002B num9 \u002B \u0022m \u003E \u0022 \u002B num8 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022player_distance\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 1)\n\t\t\t\t{\n\t\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat magnitude2 = player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num10 = player.BoundsPadding() \u002B num4 * magnitude2 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num11 = player.tickHistory.Distance(player, hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num11 \u003E num10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName8 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName8 \u002B \u0022 on \u0022 \u002B text \u002B \u0022 with \u0022 \u002B num11 \u002B \u0022m \u003E \u0022 \u002B num10 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat num12 = player.MaxVelocity() \u002B player.GetParentVelocity().magnitude;\n\t\t\t\t\t\tfloat num13 = player.BoundsPadding() \u002B num4 * num12 \u002B num * maxDistance;\n\t\t\t\t\t\tfloat num14 = player.Distance(hitInfo.HitPositionWorld);\n\t\t\t\t\t\tif (num14 \u003E num13)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring shortPrefabName9 = base.ShortPrefabName;\n\t\t\t\t\t\t\tstring text2 = (flag6 ? hitEntity.ShortPrefabName : \u0022world\u0022);\n\t\t\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, \u0022Initiator too far away (\u0022 \u002B shortPrefabName9 \u002B \u0022 on \u0022 \u002B text2 \u002B \u0022 with \u0022 \u002B num14 \u002B \u0022m \u003E \u0022 \u002B num13 \u002B \u0022m in \u0022 \u002B num4 \u002B \u0022s)\u0022);\n\t\t\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_initiator\u0022);\n\t\t\t\t\t\t\tflag8 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ConVar.AntiHack.melee_protection \u003E= 3)\n\t\t\t\t{\n\t\t\t\t\tif (flag6)\n\t\t\t\t\t{\n\t\t\t\t\t\tVector3 pointStart = hitInfo.PointStart;\n\t\t\t\t\t\tVector3 hitPositionWorld = hitInfo.HitPositionWorld;\n\t\t\t\t\t\tcenter = player.eyes.center;\n\t\t\t\t\t\tposition = player.eyes.position;\n\t\t\t\t\t\tvector = pointStart;\n\t\t\t\t\t\tvector2 = hitInfo.PositionOnRay(hitPositionWorld) \u002B hitInfo.HitNormalWorld.normalized * 0.001f;\n\t\t\t\t\t\tvector3 = hitPositionWorld;\n\t\t\t\t\t\tif (GamePhysics.LineOfSight(center, position, layerMask) \u0026\u0026 GamePhysics.LineOfSight(position, vector, layerMask) \u0026\u0026 GamePhysics.LineOfSight(vector, vector2, layerMask))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum15 = (GamePhysics.LineOfSight(vector2, vector3, layerMask, hitEntity) ? 1 : 0);\n\t\t\t\t\t\t\tif (num15 != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_direct_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\t\t\tgoto IL_0709;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum15 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplayer.stats.Add(\u0022hit_\u0022 \u002B hitEntity.Categorize() \u002B \u0022_indirect_los\u0022, 1, Stats.Server);\n\t\t\t\t\t\tgoto IL_0709;\n\t\t\t\t\t}\n\t\t\t\t\tgoto IL_07c4;\n\t\t\t\t}\n\t\t\t\tgoto IL_0902;\n\t\t\t}\n\t\t\tgoto IL_0914;\n\t\t\tIL_0709:\n\t\t\tif (num15 == 0)\n\t\t\t{\n\t\t\t\tstring shortPrefabName10 = base.ShortPrefabName;\n\t\t\t\tstring shortPrefabName11 = hitEntity.ShortPrefabName;\n\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName10, \u0022 on \u0022, shortPrefabName11, \u0022) \u0022, center, \u0022 \u0022, position, \u0022 \u0022, vector, \u0022 \u0022, vector2, \u0022 \u0022, vector3));\n\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_los\u0022);\n\t\t\t\tflag8 = false;\n\t\t\t}\n\t\t\tgoto IL_07c4;\n\t\t\tIL_0902:\n\t\t\tif (!flag8)\n\t\t\t{\n\t\t\t\tAntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgoto IL_0914;\n\t\t\tIL_07c4:\n\t\t\tif (flag8 \u0026\u0026 flag \u0026\u0026 !flag7)\n\t\t\t{\n\t\t\t\tVector3 hitPositionWorld2 = hitInfo.HitPositionWorld;\n\t\t\t\tVector3 position2 = basePlayer.eyes.position;\n\t\t\t\tVector3 vector4 = basePlayer.CenterPoint();\n\t\t\t\tfloat melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;\n\t\t\t\tbool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, layerMask, 0f, melee_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(position2, hitPositionWorld2, layerMask, melee_losforgiveness, 0f);\n\t\t\t\tif (!flag9)\n\t\t\t\t{\n\t\t\t\t\tflag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector4, layerMask, 0f, melee_losforgiveness) \u0026\u0026 GamePhysics.LineOfSight(vector4, hitPositionWorld2, layerMask, melee_losforgiveness, 0f);\n\t\t\t\t}\n\t\t\t\tif (!flag9)\n\t\t\t\t{\n\t\t\t\t\tstring shortPrefabName12 = base.ShortPrefabName;\n\t\t\t\t\tstring shortPrefabName13 = basePlayer.ShortPrefabName;\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(\u0022Line of sight (\u0022, shortPrefabName12, \u0022 on \u0022, shortPrefabName13, \u0022) \u0022, hitPositionWorld2, \u0022 \u0022, position2, \u0022 or \u0022, hitPositionWorld2, \u0022 \u0022, vector4));\n\t\t\t\t\tplayer.stats.combat.LogInvalid(hitInfo, \u0022melee_los\u0022);\n\t\t\t\t\tflag8 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto IL_0902;\n\t\t\tIL_0914:\n\t\t\tplayer.metabolism.UseHeart(heartStress * 0.2f);\n\t\t\tusing (TimeWarning.New(\u0022DoAttackShared\u0022, 50))\n\t\t\t{\n\t\t\t\tDoAttackShared(hitInfo);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnTreeMarkerHit(TreeEntity treeEntity, HitInfo info)",
    "MethodSignature": "DidHitMarker(HitInfo info)",
    "MethodSourseCode": "\n\tpublic bool DidHitMarker(HitInfo info)\n\t{\n\t\tif (xMarker == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnTreeMarkerHit\u0022, this, info);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (PrefabAttribute.server.Find\u003CTreeMarkerData\u003E(prefabID) != null)\n\t\t{\n\t\t\tif (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tVector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);\n\t\t\tVector3 attackNormal = info.attackNormal;\n\t\t\tfloat num = Vector3.Dot(lhs, attackNormal);\n\t\t\tfloat num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);\n\t\t\tif (num \u003E= 0.3f \u0026\u0026 num2 \u003C= 0.2f)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "TreeEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnInputUpdate(IOEntity iOEntity, int inputAmount, int inputSlot)",
    "MethodSignature": "UpdateFromInput(int inputAmount, int inputSlot)",
    "MethodSourseCode": "\n\tpublic virtual void UpdateFromInput(int inputAmount, int inputSlot)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInputUpdate\u0022, this, inputAmount, inputSlot) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\treturn;\n\t\t}\n\t\tUpdateHasPower(inputAmount, inputSlot);\n\t\tlastEnergy = currentEnergy;\n\t\tcurrentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);\n\t\tint passthroughAmount = GetPassthroughAmount();\n\t\tbool flag = lastPassthroughEnergy != passthroughAmount;\n\t\tlastPassthroughEnergy = passthroughAmount;\n\t\tif (currentEnergy != lastEnergy || flag)\n\t\t{\n\t\t\tIOStateChanged(inputAmount, inputSlot);\n\t\t\tensureOutputsUpdated = true;\n\t\t}\n\t\t_processQueue.Enqueue(this);\n\t}\n",
    "ClassName": "IOEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer ply, BaseEntity baseEntity)",
    "MethodSignature": "StopControl(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic void StopControl(BasePlayer ply)\n\t{\n\t\tBaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);\n\t\tif ((bool)baseEntity)\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnBookmarkControlEnd\u0022, this, ply, baseEntity) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbaseEntity.GetComponent\u003CIRemoteControllable\u003E().StopControl(new CameraViewerId(currentPlayerID, 0L));\n\t\t}\n\t\tif ((bool)ply)\n\t\t{\n\t\t\tply.net.SwitchSecondaryGroup(null);\n\t\t}\n\t\tcurrentlyControllingEnt.uid = default(NetworkableId);\n\t\tcurrentPlayerID = 0uL;\n\t\tSetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);\n\t\tSendNetworkUpdate();\n\t\tSendControlBookmarks(ply);\n\t\tCancelInvoke(ControlCheck);\n\t\tCancelInvoke(CheckCCTVAchievement);\n\t\tInterface.CallHook(\u0022OnBookmarkControlEnded\u0022, this, ply, baseEntity);\n\t}\n",
    "ClassName": "ComputerStation",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)",
    "MethodSignature": "CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)",
    "MethodSourseCode": "\n\tprotected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\n\t{\n\t\tif (Interface.CallHook(\u0022CanCreateWorldProjectile\u0022, info, itemDef) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tVector3 projectileVelocity = info.ProjectileVelocity;\n\t\tItem item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));\n\t\tif (Interface.CallHook(\u0022OnWorldProjectileCreate\u0022, info, item) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = null;\n\t\tif (!info.DidHit)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.breakProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.breakProbability)\n\t\t{\n\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\treturn;\n\t\t}\n\t\tif (projectilePrefab.conditionLoss \u003E 0f)\n\t\t{\n\t\t\titem.LoseCondition(projectilePrefab.conditionLoss * 100f);\n\t\t\tif (item.isBroken)\n\t\t\t{\n\t\t\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\t\t\tbaseEntity.Kill(DestroyMode.Gib);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (projectilePrefab.stickProbability \u003E 0f \u0026\u0026 UnityEngine.Random.value \u003C= projectilePrefab.stickProbability)\n\t\t{\n\t\t\tbaseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));\n\t\t\tbaseEntity.GetComponent\u003CRigidbody\u003E().isKinematic = true;\n\t\t\treturn;\n\t\t}\n\t\tbaseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));\n\t\tRigidbody component = baseEntity.GetComponent\u003CRigidbody\u003E();\n\t\tcomponent.AddForce(projectileVelocity.normalized * 200f);\n\t\tcomponent.WakeUp();\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityDistanceCheck(BaseEntity ent, BasePlayer player, uint id, string debugName, float maximumDistance)",
    "MethodSignature": "Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)",
    "MethodSourseCode": "\n\t\t\tpublic static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)\n\t\t\t{\n\t\t\t\tif (ent == null || player == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnEntityDistanceCheck\u0022, ent, player, id, debugName, maximumDistance);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\treturn ent.Distance(player.eyes.position) \u003C= maximumDistance;\n\t\t\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnEntityPickedUp(BaseCombatEntity baseCombatEntity, Item createdItem, BasePlayer player)",
    "MethodSignature": "OnPickedUp(Item createdItem, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void OnPickedUp(Item createdItem, BasePlayer player)\n\t{\n\t\tInterface.CallHook(\u0022OnEntityPickedUp\u0022, this, createdItem, player);\n\t}\n",
    "ClassName": "BaseCombatEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnMissionSucceeded(BaseMission baseMission, BaseMission.MissionInstance instance, BasePlayer assignee)",
    "MethodSignature": "MissionSuccess(MissionInstance instance, BasePlayer assignee)",
    "MethodSourseCode": "\n\tpublic virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)\n\t{\n\t\tinstance.status = MissionStatus.Accomplished;\n\t\tMissionEnded(instance, assignee);\n\t\tMissionComplete(instance, assignee);\n\t\tInterface.CallHook(\u0022OnMissionSucceeded\u0022, this, instance, assignee);\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnEntityKill(BaseNetworkable baseNetworkable)",
    "MethodSignature": "Kill(DestroyMode mode)",
    "MethodSourseCode": "\n\tpublic void Kill(DestroyMode mode = DestroyMode.None)\n\t{\n\t\tif (IsDestroyed)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Calling kill - but already IsDestroyed!? \u0022 \u002B this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnEntityKill\u0022, this) == null)\n\t\t{\n\t\t\tOnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);\n\t\t\tDoEntityDestroy();\n\t\t\tTerminateOnClient(mode);\n\t\t\tTerminateOnServer();\n\t\t\tEntityDestroy();\n\t\t}\n\t}\n",
    "ClassName": "BaseNetworkable",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnPlayerSpectate(BasePlayer basePlayer, string spectateFilter)",
    "MethodSignature": "StartSpectating()",
    "MethodSourseCode": "\n\tpublic void StartSpectating()\n\t{\n\t\tif (!IsSpectating() \u0026\u0026 Interface.CallHook(\u0022OnPlayerSpectate\u0022, this, spectateFilter) == null)\n\t\t{\n\t\t\tSetPlayerFlag(PlayerFlags.Spectating, b: true);\n\t\t\tUnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);\n\t\t\tCancelInvoke(InventoryUpdate);\n\t\t\tChatMessage(\u0022Becoming Spectator\u0022);\n\t\t\tUpdateSpectateTarget(spectateFilter);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnFireBallDamage(FireBall fireBall, BaseCombatEntity baseCombatEntity, HitInfo hitInfo)",
    "MethodSignature": "DoRadialDamage()",
    "MethodSourseCode": "\n\tpublic void DoRadialDamage()\n\t{\n\t\tList\u003CCollider\u003E obj = Pool.GetList\u003CCollider\u003E();\n\t\tVector3 position = base.transform.position \u002B new Vector3(0f, radius * 0.75f, 0f);\n\t\tVis.Colliders(position, radius, obj, AttackLayers);\n\t\tHitInfo hitInfo = new HitInfo();\n\t\thitInfo.DoHitEffects = true;\n\t\thitInfo.DidHit = true;\n\t\thitInfo.HitBone = 0u;\n\t\thitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);\n\t\thitInfo.PointStart = base.transform.position;\n\t\tforeach (Collider item in obj)\n\t\t{\n\t\t\tif (item.isTrigger \u0026\u0026 (item.gameObject.layer == 29 || item.gameObject.layer == 18))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tBaseCombatEntity baseCombatEntity = GameObjectEx.ToBaseEntity(item.gameObject) as BaseCombatEntity;\n\t\t\tif (!(baseCombatEntity == null) \u0026\u0026 baseCombatEntity.isServer \u0026\u0026 baseCombatEntity.IsAlive() \u0026\u0026 (!ignoreNPC || !baseCombatEntity.IsNpc) \u0026\u0026 baseCombatEntity.IsVisible(position))\n\t\t\t{\n\t\t\t\tif (baseCombatEntity is BasePlayer)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/impacts/additive/fire.prefab\u0022, baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up);\n\t\t\t\t}\n\t\t\t\thitInfo.PointEnd = baseCombatEntity.transform.position;\n\t\t\t\thitInfo.HitPositionWorld = baseCombatEntity.transform.position;\n\t\t\t\thitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);\n\t\t\t\tInterface.CallHook(\u0022OnFireBallDamage\u0022, this, baseCombatEntity, hitInfo);\n\t\t\t\tbaseCombatEntity.OnAttacked(hitInfo);\n\t\t\t}\n\t\t}\n\t\tPool.FreeList(ref obj);\n\t}\n",
    "ClassName": "FireBall",
    "HookLineInvoke": 28
  },
  {
    "HookSignature": "CanAssignMission(BasePlayer assignee, BaseMission mission, IMissionProvider provider)",
    "MethodSignature": "AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)",
    "MethodSourseCode": "\n\tpublic static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)\n\t{\n\t\tif (!missionsenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!mission.IsEligableForMission(assignee, provider))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAssignMission\u0022, assignee, mission, provider);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tMissionInstance missionInstance = Pool.Get\u003CMissionInstance\u003E();\n\t\tmissionInstance.missionID = mission.id;\n\t\tmissionInstance.startTime = Time.time;\n\t\tmissionInstance.providerID = provider.ProviderID();\n\t\tmissionInstance.status = MissionStatus.Active;\n\t\tmissionInstance.createdEntities = Pool.GetList\u003CMissionEntity\u003E();\n\t\tmissionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];\n\t\tfor (int i = 0; i \u003C mission.objectives.Length; i\u002B\u002B)\n\t\t{\n\t\t\tmissionInstance.objectiveStatuses[i] = new MissionInstance.ObjectiveStatus();\n\t\t}\n\t\tassignee.AddMission(missionInstance);\n\t\tmission.MissionStart(missionInstance, assignee);\n\t\tassignee.SetActiveMission(assignee.missions.Count - 1);\n\t\tassignee.MissionDirty();\n\t\tInterface.CallHook(\u0022OnMissionAssigned\u0022, mission, provider, assignee);\n\t\treturn true;\n\t}\n",
    "ClassName": "BaseMission",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_OpenAdmin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_OpenAdmin(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tSendSellOrders(player);\n\t\t\tPlayerOpenLoot(player);\n\t\t\tClientRPCPlayer(null, player, \u0022CLIENT_OpenAdminMenu\u0022);\n\t\t\tInterface.CallHook(\u0022OnOpenVendingAdmin\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)",
    "MethodSignature": "RPC_Broadcast(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Broadcast(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tbool b = msg.read.Bit();\n\t\tif (CanPlayerAdmin(player))\n\t\t{\n\t\t\tSetFlag(Flags.Reserved4, b);\n\t\t\tInterface.CallHook(\u0022OnToggleVendingBroadcast\u0022, this, player);\n\t\t\tUpdateMapMarker();\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnShopCancelClick(ShopFront shopFront, BasePlayer msgPlayer)",
    "MethodSignature": "CancelClicked(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void CancelClicked(RPCMessage msg)\n\t{\n\t\tif (IsTradingPlayer(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnShopCancelClick\u0022, this, msg.player) == null)\n\t\t{\n\t\t\t_ = (bool)vendorPlayer;\n\t\t\t_ = (bool)customerPlayer;\n\t\t\tResetTrade();\n\t\t}\n\t}\n",
    "ClassName": "ShopFront",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnGrowableStateChange(GrowableEntity growableEntity, PlantProperties.State state)",
    "MethodSignature": "ChangeState(PlantProperties.State state, bool resetAge, bool loading)",
    "MethodSourseCode": "\n\tpublic void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)\n\t{\n\t\tif (Interface.CallHook(\u0022OnGrowableStateChange\u0022, this, state) != null || (base.isServer \u0026\u0026 State == state))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tState = state;\n\t\tif (!base.isServer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!loading)\n\t\t{\n\t\t\tif (currentStage.resources \u003E 0f)\n\t\t\t{\n\t\t\t\tyieldPool = currentStage.yield;\n\t\t\t}\n\t\t\tif (state == PlantProperties.State.Crossbreed)\n\t\t\t{\n\t\t\t\tif (Properties.CrossBreedEffect.isValid)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t\t\t}\n\t\t\t\tGrowableGenetics.CrossBreed(this);\n\t\t\t}\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\tif (resetAge)\n\t\t{\n\t\t\tstageAge = 0f;\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanBuild(Planner planner, Construction construction, Construction.Target target)",
    "MethodSignature": "DoBuild(CreateBuilding msg)",
    "MethodSourseCode": "\n\tpublic void DoBuild(CreateBuilding msg)\n\t{\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (ConVar.AntiHack.objectplacement \u0026\u0026 ownerPlayer.TriggeredAntiHack())\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022AntiHack!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tConstruction construction = PrefabAttribute.server.Find\u003CConstruction\u003E(msg.blockID);\n\t\tif (construction == null)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find Construction \u0022 \u002B msg.blockID);\n\t\t\treturn;\n\t\t}\n\t\tif (!CanAffordToPlace(construction))\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t afford to place!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!ownerPlayer.CanBuild() \u0026\u0026 !construction.canBypassBuildingPermission)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Building is blocked!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tDeployable deployable = GetDeployable();\n\t\tif (construction.deployable != deployable)\n\t\t{\n\t\t\townerPlayer.ChatMessage(\u0022Deployable mismatch!\u0022);\n\t\t\tAntiHack.NoteAdminHack(ownerPlayer);\n\t\t\treturn;\n\t\t}\n\t\tBaseGameMode.CanBuildResult? canBuildResult = BaseGameMode.GetActiveGameMode(serverside: true)?.CanBuildEntity(ownerPlayer, construction);\n\t\tif (canBuildResult.HasValue)\n\t\t{\n\t\t\tif (canBuildResult.Value.Phrase != null)\n\t\t\t{\n\t\t\t\townerPlayer.ShowToast((!canBuildResult.Value.Result) ? GameTip.Styles.Red_Normal : GameTip.Styles.Blue_Long, canBuildResult.Value.Phrase, canBuildResult.Value.Arguments);\n\t\t\t}\n\t\t\tif (!canBuildResult.Value.Result)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tConstruction.Target target = default(Construction.Target);\n\t\tif (msg.entity.IsValid)\n\t\t{\n\t\t\ttarget.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;\n\t\t\tif (target.entity == null)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find entity \u0022 \u002B msg.entity);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmsg.position = target.entity.transform.TransformPoint(msg.position);\n\t\t\tmsg.normal = target.entity.transform.TransformDirection(msg.normal);\n\t\t\tmsg.rotation = target.entity.transform.rotation * msg.rotation;\n\t\t\tif (msg.socket != 0)\n\t\t\t{\n\t\t\t\tstring text = StringPool.Get(msg.socket);\n\t\t\t\tif (text != \u0022\u0022)\n\t\t\t\t{\n\t\t\t\t\ttarget.socket = FindSocket(text, target.entity.prefabID);\n\t\t\t\t}\n\t\t\t\tif (target.socket == null)\n\t\t\t\t{\n\t\t\t\t\townerPlayer.ChatMessage(\u0022Couldn\u0027t find socket \u0022 \u002B msg.socket);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (target.entity is Door)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Can\u0027t deploy on door\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\ttarget.ray = msg.ray;\n\t\ttarget.onTerrain = msg.onterrain;\n\t\ttarget.position = msg.position;\n\t\ttarget.normal = msg.normal;\n\t\ttarget.rotation = msg.rotation;\n\t\ttarget.player = ownerPlayer;\n\t\ttarget.valid = true;\n\t\tif (Interface.CallHook(\u0022CanBuild\u0022, this, construction, target) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (target.entity != null \u0026\u0026 deployable != null \u0026\u0026 deployable.setSocketParent)\n\t\t{\n\t\t\tVector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);\n\t\t\tfloat num = target.entity.Distance(position);\n\t\t\tif (num \u003E 1f)\n\t\t\t{\n\t\t\t\townerPlayer.ChatMessage(\u0022Parent too far away: \u0022 \u002B num);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tDoBuild(target, construction);\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 86
  },
  {
    "HookSignature": "CanNetworkTo(BaseEntity baseEntity, BasePlayer player)",
    "MethodSignature": "ShouldNetworkTo(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool ShouldNetworkTo(BasePlayer player)\n\t{\n\t\tif (player == this)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBaseEntity baseEntity = GetParentEntity();\n\t\tif (base.limitNetworking)\n\t\t{\n\t\t\tif (baseEntity == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (baseEntity != player)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (baseEntity != null)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022CanNetworkTo\u0022, this, player);\n\t\t\tif (obj is bool)\n\t\t\t{\n\t\t\t\treturn (bool)obj;\n\t\t\t}\n\t\t\treturn baseEntity.ShouldNetworkTo(player);\n\t\t}\n\t\treturn base.ShouldNetworkTo(player);\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnTeamUpdated(ulong currentTeam, ProtoBuf.PlayerTeam playerTeam2, BasePlayer basePlayer)",
    "MethodSignature": "TeamUpdate(bool fullTeamUpdate)",
    "MethodSourseCode": "\n\tpublic void TeamUpdate(bool fullTeamUpdate)\n\t{\n\t\tif (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);\n\t\tif (playerTeam == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = 0;\n\t\tint num2 = 0;\n\t\tusing PlayerTeam playerTeam2 = Facepunch.Pool.Get\u003CPlayerTeam\u003E();\n\t\tplayerTeam2.teamLeader = playerTeam.teamLeader;\n\t\tplayerTeam2.teamID = playerTeam.teamID;\n\t\tplayerTeam2.teamName = playerTeam.teamName;\n\t\tplayerTeam2.members = Facepunch.Pool.GetList\u003CPlayerTeam.TeamMember\u003E();\n\t\tplayerTeam2.teamLifetime = playerTeam.teamLifetime;\n\t\tplayerTeam2.teamPings = Facepunch.Pool.GetList\u003CMapNote\u003E();\n\t\tforeach (ulong member in playerTeam.members)\n\t\t{\n\t\t\tBasePlayer basePlayer = RelationshipManager.FindByID(member);\n\t\t\tPlayerTeam.TeamMember teamMember = Facepunch.Pool.Get\u003CPlayerTeam.TeamMember\u003E();\n\t\t\tteamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent\u003CServerMgr\u003E.Instance.persistance.GetPlayerName(member) ?? \u0022DEAD\u0022));\n\t\t\tteamMember.healthFraction = ((basePlayer != null \u0026\u0026 basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);\n\t\t\tteamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);\n\t\t\tteamMember.online = basePlayer != null \u0026\u0026 !basePlayer.IsSleeping();\n\t\t\tteamMember.wounded = basePlayer != null \u0026\u0026 basePlayer.IsWounded();\n\t\t\tif ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) \u0026\u0026 basePlayer != null)\n\t\t\t{\n\t\t\t\tif ((bool)basePlayer.GetHeldEntity() \u0026\u0026 basePlayer.GetHeldEntity().IsInstrument())\n\t\t\t\t{\n\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t}\n\t\t\t\tif (basePlayer.isMounted)\n\t\t\t\t{\n\t\t\t\t\tif (basePlayer.GetMounted().IsInstrument())\n\t\t\t\t\t{\n\t\t\t\t\t\tnum\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t\tif (basePlayer.GetMounted().IsSummerDlcVehicle)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (num \u003E= 4 \u0026\u0026 !sentInstrumentTeamAchievement)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022TEAM_INSTRUMENTS\u0022);\n\t\t\t\t\tsentInstrumentTeamAchievement = true;\n\t\t\t\t}\n\t\t\t\tif (num2 \u003E= 4)\n\t\t\t\t{\n\t\t\t\t\tGiveAchievement(\u0022SUMMER_INFLATABLE\u0022);\n\t\t\t\t\tsentSummerTeamAchievement = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tteamMember.userID = member;\n\t\t\tplayerTeam2.members.Add(teamMember);\n\t\t\tif (basePlayer != null)\n\t\t\t{\n\t\t\t\tif (basePlayer.State.pings != null \u0026\u0026 basePlayer.State.pings.Count \u003E 0 \u0026\u0026 basePlayer != this)\n\t\t\t\t{\n\t\t\t\t\tplayerTeam2.teamPings.AddRange(basePlayer.State.pings);\n\t\t\t\t}\n\t\t\t\tif (fullTeamUpdate \u0026\u0026 basePlayer != this)\n\t\t\t\t{\n\t\t\t\t\tbasePlayer.TeamUpdate(fullTeamUpdate: false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplayerTeam2.leaderMapNotes = Facepunch.Pool.GetList\u003CMapNote\u003E();\n\t\tPlayerState playerState = SingletonComponent\u003CServerMgr\u003E.Instance.playerStateManager.Get(playerTeam.teamLeader);\n\t\tif (playerState?.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in playerState.pointsOfInterest)\n\t\t\t{\n\t\t\t\tplayerTeam2.leaderMapNotes.Add(item);\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnTeamUpdated\u0022, currentTeam, playerTeam2, this) == null)\n\t\t{\n\t\t\tClientRPCPlayerAndSpectators(null, this, \u0022CLIENT_ReceiveTeamInfo\u0022, playerTeam2);\n\t\t\tif (playerTeam2.leaderMapNotes != null)\n\t\t\t{\n\t\t\t\tplayerTeam2.leaderMapNotes.Clear();\n\t\t\t}\n\t\t\tif (playerTeam2.teamPings != null)\n\t\t\t{\n\t\t\t\tplayerTeam2.teamPings.Clear();\n\t\t\t}\n\t\t\tBasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);\n\t\t\tif (fullTeamUpdate \u0026\u0026 basePlayer2 != null \u0026\u0026 basePlayer2 != this)\n\t\t\t{\n\t\t\t\tbasePlayer2.TeamUpdate(fullTeamUpdate: false);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 81
  },
  {
    "HookSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "OnAttacked(HitInfo info)",
    "MethodSourseCode": "\n\tpublic override void OnAttacked(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022IOnBasePlayerAttacked\u0022, this, info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat oldHealth = base.health;\n\t\tif (InSafeZone() \u0026\u0026 !IsHostile() \u0026\u0026 info.Initiator != null \u0026\u0026 info.Initiator != this)\n\t\t{\n\t\t\tinfo.damageTypes.ScaleAll(0f);\n\t\t}\n\t\tif (base.isServer)\n\t\t{\n\t\t\tHitArea boneArea = info.boneArea;\n\t\t\tif (boneArea != (HitArea)(-1))\n\t\t\t{\n\t\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\t\t\tobj.AddRange(inventory.containerWear.itemList);\n\t\t\t\tfor (int i = 0; i \u003C obj.Count; i\u002B\u002B)\n\t\t\t\t{\n\t\t\t\t\tItem item = obj[i];\n\t\t\t\t\tif (item != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemModWearable component = item.info.GetComponent\u003CItemModWearable\u003E();\n\t\t\t\t\t\tif (!(component == null) \u0026\u0026 component.ProtectsArea(boneArea))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem.OnAttacked(info);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t\tinventory.ServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t\tbase.OnAttacked(info);\n\t\tif (base.isServer \u0026\u0026 base.isServer \u0026\u0026 info.hasDamage)\n\t\t{\n\t\t\tif (!info.damageTypes.Has(DamageType.Bleeding) \u0026\u0026 info.damageTypes.IsBleedCausing() \u0026\u0026 !IsWounded() \u0026\u0026 !IsImmortalTo(info))\n\t\t\t{\n\t\t\t\tmetabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);\n\t\t\t}\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().MounteeTookDamage(this, info);\n\t\t\t}\n\t\t\tCheckDeathCondition(info);\n\t\t\tif (net != null \u0026\u0026 net.connection != null)\n\t\t\t{\n\t\t\t\tClientRPCPlayer(null, this, \u0022TakeDamageHit\u0022);\n\t\t\t}\n\t\t\tstring text = StringPool.Get(info.HitBone);\n\t\t\tbool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) \u003E 0.4f;\n\t\t\tBasePlayer initiatorPlayer = info.InitiatorPlayer;\n\t\t\tif ((bool)initiatorPlayer \u0026\u0026 !info.damageTypes.IsMeleeType())\n\t\t\t{\n\t\t\t\tinitiatorPlayer.LifeStoryShotHit(info.Weapon);\n\t\t\t}\n\t\t\tif (info.isHeadshot)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_RearHead, string.Empty);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSignalBroadcast(Signal.Flinch_Head, string.Empty);\n\t\t\t\t}\n\t\t\t\tif (!initiatorPlayer || !initiatorPlayer.limitNetworking)\n\t\t\t\t{\n\t\t\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/headshot.prefab\u0022, this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);\n\t\t\t\t}\n\t\t\t\tif ((bool)initiatorPlayer)\n\t\t\t\t{\n\t\t\t\t\tinitiatorPlayer.stats.Add(\u0022headshot\u0022, 1, (Stats)5);\n\t\t\t\t\tif (initiatorPlayer.IsBeingSpectated)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (BaseEntity child in initiatorPlayer.children)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (child is BasePlayer basePlayer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbasePlayer.ClientRPCPlayer(null, basePlayer, \u0022SpectatedPlayerHeadshot\u0022);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (flag)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_RearTorso, string.Empty);\n\t\t\t}\n\t\t\telse if (text == \u0022spine\u0022 || text == \u0022spine2\u0022)\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Stomach, string.Empty);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSignalBroadcast(Signal.Flinch_Chest, string.Empty);\n\t\t\t}\n\t\t}\n\t\tif (stats != null)\n\t\t{\n\t\t\tif (IsWounded())\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022wounded\u0022, oldHealth);\n\t\t\t}\n\t\t\telse if (IsDead())\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022killed\u0022, oldHealth);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstats.combat.LogAttack(info, \u0022\u0022, oldHealth);\n\t\t\t}\n\t\t}\n\t\tif (ConVar.Global.cinematicGingerbreadCorpses)\n\t\t{\n\t\t\tinfo.HitMaterial = ConVar.Global.GingerbreadMaterialID();\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer basePlayer, ulong uLong)",
    "MethodSignature": "kickmember(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void kickmember(ConsoleSystem.Arg arg)\n\t{\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tPlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);\n\t\tif (playerTeam != null \u0026\u0026 !(playerTeam.GetLeader() != basePlayer))\n\t\t{\n\t\t\tulong uLong = arg.GetULong(0, 0uL);\n\t\t\tif (basePlayer.userID != uLong \u0026\u0026 Interface.CallHook(\u0022OnTeamKick\u0022, playerTeam, basePlayer, uLong) == null)\n\t\t\t{\n\t\t\t\tplayerTeam.RemovePlayer(uLong);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "CanCombineDroppedItem(DroppedItem droppedItem, DroppedItem di)",
    "MethodSignature": "OnDroppedOn(DroppedItem di)",
    "MethodSourseCode": "\n\tpublic void OnDroppedOn(DroppedItem di)\n\t{\n\t\tif (item == null || di.item == null || Interface.CallHook(\u0022CanCombineDroppedItem\u0022, this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() \u0026\u0026 di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition \u0026\u0026 di.item.condition != di.item.maxCondition) || (item.hasCondition \u0026\u0026 item.condition != item.maxCondition))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (di.item.info != null)\n\t\t{\n\t\t\tif (di.item.info.amountType == ItemDefinition.AmountType.Genetics)\n\t\t\t{\n\t\t\t\tint num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));\n\t\t\t\tint num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));\n\t\t\t\tif (num != num2)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((di.item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(di.item) != null) || (item.info != null \u0026\u0026 item.info.GetComponent\u003CItemModSign\u003E() != null \u0026\u0026 ItemModAssociatedEntity\u003CSignContent\u003E.GetAssociatedEntity(item) != null))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tint num3 = di.item.amount \u002B item.amount;\n\t\tif (num3 \u003C= item.MaxStackable() \u0026\u0026 num3 != 0)\n\t\t{\n\t\t\tif (di.DropReason == DropReasonEnum.Player)\n\t\t\t{\n\t\t\t\tDropReason = DropReasonEnum.Player;\n\t\t\t}\n\t\t\tdi.DestroyItem();\n\t\t\tdi.Kill();\n\t\t\titem.amount = num3;\n\t\t\titem.MarkDirty();\n\t\t\tif (GetDespawnDuration() \u003C float.PositiveInfinity)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnDroppedItemCombined\u0022, this);\n\t\t\t\tInvoke(IdleDestroy, GetDespawnDuration());\n\t\t\t}\n\t\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/notice/stack.world.fx.prefab\u0022, this, 0u, Vector3.zero, Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "DroppedItem",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanUnlock(BasePlayer rpcPlayer, CodeLock codeLock)",
    "MethodSignature": "TryUnlock(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void TryUnlock(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 IsLocked() \u0026\u0026 Interface.CallHook(\u0022CanUnlock\u0022, rpc.player, this) == null \u0026\u0026 !IsCodeEntryBlocked() \u0026\u0026 whitelistPlayers.Contains(rpc.player.userID))\n\t\t{\n\t\t\tDoEffect(effectUnlocked.resourcePath);\n\t\t\tSetFlag(Flags.Locked, b: false);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRidableAnimalClaimed(BaseRidableAnimal baseRidableAnimal, BasePlayer player)",
    "MethodSignature": "RPC_Claim(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_Claim(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!(player == null) \u0026\u0026 IsForSale())\n\t\t{\n\t\t\tint tokenItemID = msg.read.Int32();\n\t\t\tItem item = GetPurchaseToken(player, tokenItemID);\n\t\t\tif (item != null \u0026\u0026 Interface.CallHook(\u0022OnRidableAnimalClaim\u0022, this, player, item) == null)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved2, b: false);\n\t\t\t\tOnClaimedWithToken(item);\n\t\t\t\titem.UseItem();\n\t\t\t\tFacepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\n\t\t\t\tAttemptMount(player, doMountChecks: false);\n\t\t\t\tInterface.CallHook(\u0022OnRidableAnimalClaimed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "OnActiveItemChanged(BasePlayer basePlayer, Item activeItem, Item activeItem2)",
    "MethodSignature": "UpdateActiveItem(ItemId itemID)",
    "MethodSourseCode": "\n\tpublic void UpdateActiveItem(ItemId itemID)\n\t{\n\t\tAssert.IsTrue(base.isServer, \u0022Realm should be server!\u0022);\n\t\tif (svActiveItemID == itemID)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (equippingBlocked)\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem item = inventory.containerBelt.FindItemByUID(itemID);\n\t\tif (IsItemHoldRestricted(item))\n\t\t{\n\t\t\titemID = default(ItemId);\n\t\t}\n\t\tItem activeItem = GetActiveItem();\n\t\tif (Interface.CallHook(\u0022OnActiveItemChange\u0022, this, activeItem, itemID) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tsvActiveItemID = default(ItemId);\n\t\tif (activeItem != null)\n\t\t{\n\t\t\tHeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity != null)\n\t\t\t{\n\t\t\t\theldEntity.SetHeld(bHeld: false);\n\t\t\t}\n\t\t}\n\t\tsvActiveItemID = itemID;\n\t\tSendNetworkUpdate();\n\t\tItem activeItem2 = GetActiveItem();\n\t\tif (activeItem2 != null)\n\t\t{\n\t\t\tHeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;\n\t\t\tif (heldEntity2 != null)\n\t\t\t{\n\t\t\t\theldEntity2.SetHeld(bHeld: true);\n\t\t\t}\n\t\t\tNotifyGesturesNewItemEquipped();\n\t\t}\n\t\tinventory.UpdatedVisibleHolsteredItems();\n\t\tInterface.CallHook(\u0022OnActiveItemChanged\u0022, this, activeItem, activeItem2);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnElevatorMove(Elevator elevator, int targetFloor)",
    "MethodSignature": "RequestMoveLiftTo(int targetFloor, float timeToTravel, Elevator fromElevator)",
    "MethodSourseCode": "\n\tpublic bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)\n\t{\n\t\ttimeToTravel = 0f;\n\t\tif (Interface.CallHook(\u0022OnElevatorMove\u0022, this, targetFloor) != null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsStatic \u0026\u0026 ioEntity != null \u0026\u0026 !ioEntity.IsPowered())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsValidFloor(targetFloor))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!liftEntity.CanMove())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tint num = LiftPositionToFloor();\n\t\tif (num == targetFloor)\n\t\t{\n\t\t\tOpenLiftDoors();\n\t\t\tOpenDoorsAtFloor(num);\n\t\t\tfromElevator.OpenLiftDoors();\n\t\t\treturn false;\n\t\t}\n\t\tVector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);\n\t\tif (!GamePhysics.LineOfSight(liftEntity.transform.position, worldSpaceFloorPosition, 2097152))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tOnMoveBegin();\n\t\tVector3 vector = base.transform.InverseTransformPoint(worldSpaceFloorPosition);\n\t\ttimeToTravel = TimeToTravelDistance(Mathf.Abs(liftEntity.transform.localPosition.y - vector.y));\n\t\tLeanTween.moveLocalY(liftEntity.gameObject, vector.y, timeToTravel).delay = LiftMoveDelay;\n\t\ttimeToTravel \u002B= LiftMoveDelay;\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tif (targetFloor \u003C Floor)\n\t\t{\n\t\t\tliftEntity.ToggleHurtTrigger(state: true);\n\t\t}\n\t\tInvoke(ClearBusy, timeToTravel \u002B 1f);\n\t\tif (ioEntity != null)\n\t\t{\n\t\t\tioEntity.SetFlag(Flags.Busy, b: true);\n\t\t\tioEntity.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Elevator",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanBeRecycled(Item item, Recycler recycler)",
    "MethodSignature": "CanBeRecycled(Item item)",
    "MethodSourseCode": "\n\tprivate bool CanBeRecycled(Item item)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeRecycled\u0022, item, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (item != null)\n\t\t{\n\t\t\treturn item.info.Blueprint != null;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemSkinChange(int num, Item slot, RepairBench repairBench, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void ChangeSkin(RPCMessage msg)\n\t{\n\t\tif (UnityEngine.Time.realtimeSinceStartup \u003C nextSkinChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer player = msg.player;\n\t\tint num = msg.read.Int32();\n\t\tItem slot = base.inventory.GetSlot(0);\n\t\tif (slot == null || Interface.CallHook(\u0022OnItemSkinChange\u0022, num, slot, this, msg.player) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (msg.player.UnlockAllSkins)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (num != 0 \u0026\u0026 !flag \u0026\u0026 !player.blueprints.CheckSkinOwnership(num, player.userID))\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin player does not have item :\u0022 \u002B num \u002B \u0022:\u0022);\n\t\t\treturn;\n\t\t}\n\t\tulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);\n\t\tif (Skin == slot.skin \u0026\u0026 slot.info.isRedirectOf == null)\n\t\t{\n\t\t\tdebugprint(\u0022RepairBench.ChangeSkin cannot apply same skin twice : \u0022 \u002B Skin \u002B \u0022: \u0022 \u002B slot.skin);\n\t\t\treturn;\n\t\t}\n\t\tnextSkinChangeTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.75f;\n\t\tItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\tif (slot.info.isRedirectOf != null)\n\t\t{\n\t\t\tSkin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);\n\t\t\tskin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E (ulong)x.id == Skin);\n\t\t}\n\t\tItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));\n\t\tif (((bool)itemSkin \u0026\u0026 (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin \u0026\u0026 slot.info.isRedirectOf != null))\n\t\t{\n\t\t\tItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);\n\t\t\tbool flag2 = false;\n\t\t\tif (itemSkin != null \u0026\u0026 itemSkin.Redirect == null \u0026\u0026 slot.info.isRedirectOf != null)\n\t\t\t{\n\t\t\t\ttemplate = slot.info.isRedirectOf;\n\t\t\t\tflag2 = num != 0;\n\t\t\t}\n\t\t\tfloat condition = slot.condition;\n\t\t\tfloat maxCondition = slot.maxCondition;\n\t\t\tint amount = slot.amount;\n\t\t\tint contents = 0;\n\t\t\tItemDefinition ammoType = null;\n\t\t\tif (slot.GetHeldEntity() != null \u0026\u0026 slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)\n\t\t\t{\n\t\t\t\tcontents = baseProjectile.primaryMagazine.contents;\n\t\t\t\tammoType = baseProjectile.primaryMagazine.ammoType;\n\t\t\t}\n\t\t\tList\u003CItem\u003E obj = Facepunch.Pool.GetList\u003CItem\u003E();\n\t\t\tif (slot.contents != null \u0026\u0026 slot.contents.itemList != null \u0026\u0026 slot.contents.itemList.Count \u003E 0)\n\t\t\t{\n\t\t\t\tforeach (Item item2 in slot.contents.itemList)\n\t\t\t\t{\n\t\t\t\t\tobj.Add(item2);\n\t\t\t\t}\n\t\t\t\tforeach (Item item3 in obj)\n\t\t\t\t{\n\t\t\t\t\titem3.RemoveFromContainer();\n\t\t\t\t}\n\t\t\t}\n\t\t\tslot.Remove();\n\t\t\tItemManager.DoRemoves();\n\t\t\tItem item = ItemManager.Create(template, 1, 0uL);\n\t\t\titem.MoveToContainer(base.inventory, 0, allowStack: false);\n\t\t\titem.maxCondition = maxCondition;\n\t\t\titem.condition = condition;\n\t\t\titem.amount = amount;\n\t\t\tif (item.GetHeldEntity() != null \u0026\u0026 item.GetHeldEntity() is BaseProjectile baseProjectile2)\n\t\t\t{\n\t\t\t\tif (baseProjectile2.primaryMagazine != null)\n\t\t\t\t{\n\t\t\t\t\tbaseProjectile2.primaryMagazine.contents = contents;\n\t\t\t\t\tbaseProjectile2.primaryMagazine.ammoType = ammoType;\n\t\t\t\t}\n\t\t\t\tbaseProjectile2.ForceModsChanged();\n\t\t\t}\n\t\t\tif (obj.Count \u003E 0 \u0026\u0026 item.contents != null)\n\t\t\t{\n\t\t\t\tforeach (Item item4 in obj)\n\t\t\t\t{\n\t\t\t\t\titem4.MoveToContainer(item.contents);\n\t\t\t\t}\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\tif (flag2)\n\t\t\t{\n\t\t\t\tApplySkinToItem(item, Skin);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tApplySkinToItem(slot, Skin);\n\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);\n\t\t}\n\t\tif (skinchangeEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);\n\t\t}\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, LootableCorpse lootableCorpse)",
    "MethodSignature": "RPC_LootCorpse(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_LootCorpse(RPCMessage rpc)\n\t{\n\t\tBasePlayer player = rpc.player;\n\t\tif (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook(\u0022CanLootEntity\u0022, player, this) != null || !player.inventory.loot.StartLootingEntity(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetFlag(Flags.Open, b: true);\n\t\tfor (int i = 0; i \u003C containers.Length; i\u002B\u002B)\n\t\t{\n\t\t\tItemContainer itemContainer = containers[i];\n\t\t\tif (CanLootContainer(itemContainer, i))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(itemContainer);\n\t\t\t}\n\t\t}\n\t\tplayer.inventory.loot.SendImmediate();\n\t\tClientRPCPlayer(null, player, \u0022RPC_ClientLootCorpse\u0022);\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "LootableCorpse",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn player.userID == base.OwnerID;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "PhotoFrame",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfBroadcasterAdd(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (!broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Add(obj);\n\t\t\t\tMarkFrequencyDirty(frequency);\n\t\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnInventoryAmmoFind(PlayerInventory playerInventory, System.Collections.Generic.List\u003CItem\u003E list, Rust.AmmoTypes ammoType)",
    "MethodSignature": "FindAmmo(List\u003CItem\u003E list, AmmoTypes ammoType)",
    "MethodSourseCode": "\n\tpublic void FindAmmo(List\u003CItem\u003E list, AmmoTypes ammoType)\n\t{\n\t\tif (Interface.CallHook(\u0022OnInventoryAmmoFind\u0022, this, list, ammoType) == null)\n\t\t{\n\t\t\tif (containerMain != null)\n\t\t\t{\n\t\t\t\tcontainerMain.FindAmmo(list, ammoType);\n\t\t\t}\n\t\t\tif (containerBelt != null)\n\t\t\t{\n\t\t\t\tcontainerBelt.FindAmmo(list, ammoType);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection netConnection, string key, string val)",
    "MethodSignature": "SetInfo(string key, string val)",
    "MethodSourseCode": "\n\tpublic virtual void SetInfo(string key, string val)\n\t{\n\t\tif (IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, net.connection, key, val);\n\t\t\tnet.connection.info.Set(key, val);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "CanSpectateTarget(BasePlayer basePlayer, string strName)",
    "MethodSignature": "UpdateSpectateTarget(string strName)",
    "MethodSourseCode": "\n\tpublic void UpdateSpectateTarget(string strName)\n\t{\n\t\tif (Interface.CallHook(\u0022CanSpectateTarget\u0022, this, strName) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tspectateFilter = strName;\n\t\tIEnumerable\u003CBaseEntity\u003E enumerable = null;\n\t\tif (spectateFilter.StartsWith(\u0022@\u0022))\n\t\t{\n\t\t\tstring filter = spectateFilter.Substring(1);\n\t\t\tenumerable = (from x in BaseNetworkable.serverEntities\n\t\t\t\twhere x.name.Contains(filter, CompareOptions.IgnoreCase)\n\t\t\t\twhere x != this\n\t\t\t\tselect x).Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tIEnumerable\u003CBasePlayer\u003E source = activePlayerList.Where((BasePlayer x) =\u003E !x.IsSpectating() \u0026\u0026 !x.IsDead() \u0026\u0026 !x.IsSleeping());\n\t\t\tif (strName.Length \u003E 0)\n\t\t\t{\n\t\t\t\tsource = from x in source\n\t\t\t\t\twhere x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)\n\t\t\t\t\twhere x != this\n\t\t\t\t\tselect x;\n\t\t\t}\n\t\t\tsource = source.OrderBy((BasePlayer x) =\u003E x.displayName);\n\t\t\tenumerable = source.Cast\u003CBaseEntity\u003E();\n\t\t}\n\t\tBaseEntity[] array = enumerable.ToArray();\n\t\tif (array.Length == 0)\n\t\t{\n\t\t\tChatMessage(\u0022No valid spectate targets!\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBaseEntity baseEntity = array[SpectateOffset % array.Length];\n\t\tif (baseEntity != null)\n\t\t{\n\t\t\tSpectatePlayer(baseEntity);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnGrowableGather(GrowableEntity growableEntity, BasePlayer player, bool eat)",
    "MethodSignature": "PickFruit(BasePlayer player, bool eat)",
    "MethodSourseCode": "\n\tpublic void PickFruit(BasePlayer player, bool eat = false)\n\t{\n\t\tif (!CanPick() || Interface.CallHook(\u0022OnGrowableGather\u0022, this, player, eat) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tharvests\u002B\u002B;\n\t\tGiveFruit(player, CurrentPickAmount, eat);\n\t\tRandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find\u003CRandomItemDispenser\u003E(prefabID);\n\t\tif (randomItemDispenser != null)\n\t\t{\n\t\t\trandomItemDispenser.DistributeItems(player, base.transform.position);\n\t\t}\n\t\tResetSeason();\n\t\tif (Properties.pickEffect.isValid)\n\t\t{\n\t\t\tEffect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);\n\t\t}\n\t\tif (harvests \u003E= Properties.maxHarvests)\n\t\t{\n\t\t\tif (Properties.disappearAfterHarvest)\n\t\t\t{\n\t\t\t\tDie();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tChangeState(PlantProperties.State.Dying, resetAge: true);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tChangeState(PlantProperties.State.Mature, resetAge: true);\n\t\t}\n\t}\n",
    "ClassName": "GrowableEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWildlifeTrap(WildlifeTrap wildlifeTrap, TrappableWildlife trapped)",
    "MethodSignature": "TrapWildlife(TrappableWildlife trapped)",
    "MethodSourseCode": "\n\tpublic void TrapWildlife(TrappableWildlife trapped)\n\t{\n\t\tif (Interface.CallHook(\u0022OnWildlifeTrap\u0022, this, trapped) == null)\n\t\t{\n\t\t\tItem item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch \u002B 1), 0uL);\n\t\t\tif (!item.MoveToContainer(base.inventory))\n\t\t\t{\n\t\t\t\titem.Remove();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Reserved1, b: true);\n\t\t\t}\n\t\t\tSetTrapActive(trapOn: false);\n\t\t\tHurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);\n\t\t}\n\t}\n",
    "ClassName": "WildlifeTrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnItemRefill(Item item, BasePlayer player)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command == \u0022refill\u0022 \u0026\u0026 !player.IsSwimming() \u0026\u0026 HasCraftLevel(player) \u0026\u0026 !(item.conditionNormalized \u003E= 1f) \u0026\u0026 Interface.CallHook(\u0022OnItemRefill\u0022, item, player) == null)\n\t\t{\n\t\t\titem.DoRepair(conditionLost);\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModRepair",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSignUpdated(Signage signage, BasePlayer msgPlayer, int num)",
    "MethodSignature": "UpdateSign(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.CallsPerSecond(5uL)]\n\t[RPC_Server.MaxDistance(5f)]\n\tpublic void UpdateSign(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !CanUpdateSign(msg.player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = msg.read.Int32();\n\t\tif (num \u003C 0 || num \u003E= paintableSources.Length)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbyte[] array = msg.read.BytesWithSize();\n\t\tif (msg.read.Unread \u003E 0 \u0026\u0026 msg.read.Bit() \u0026\u0026 !msg.player.IsAdmin)\n\t\t{\n\t\t\tUnityEngine.Debug.LogWarning($\u0022{msg.player} tried to upload a sign from a file but they aren\u0027t admin, ignoring\u0022);\n\t\t\treturn;\n\t\t}\n\t\tEnsureInitialized();\n\t\tif (array == null)\n\t\t{\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = 0u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!ImageProcessing.IsValidPNG(array, 1024, 1024))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (textureIDs[num] != 0)\n\t\t\t{\n\t\t\t\tFileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);\n\t\t\t}\n\t\t\ttextureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);\n\t\t}\n\t\tLogEdit(msg.player);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnSignUpdated\u0022, this, msg.player, num);\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 44
  },
  {
    "HookSignature": "OnPlayerMetabolize(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)",
    "MethodSignature": "ServerUpdate(BaseCombatEntity ownerEntity, float delta)",
    "MethodSourseCode": "\n\tpublic override void ServerUpdate(BaseCombatEntity ownerEntity, float delta)\n\t{\n\t\tbase.ServerUpdate(ownerEntity, delta);\n\t\tInterface.CallHook(\u0022OnPlayerMetabolize\u0022, this, ownerEntity, delta);\n\t\tSendChangesToClient();\n\t}\n",
    "ClassName": "PlayerMetabolism",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "IOnPlayerChat(ulong userId, string username, string text, ConVar.Chat.ChatChannel targetChannel, BasePlayer player)",
    "MethodSignature": "sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player)",
    "MethodSourseCode": "\n\tinternal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)\n\t{\n\t\tif (!player)\n\t\t{\n\t\t\tplayer = null;\n\t\t}\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (player != null \u0026\u0026 player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;\n\t\tif (userGroup == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (text.Length \u003E 128)\n\t\t{\n\t\t\ttext = text.Substring(0, 128);\n\t\t}\n\t\tif (text.Length \u003C= 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (text.StartsWith(\u0022/\u0022) || text.StartsWith(\u0022\\\\\u0022))\n\t\t{\n\t\t\tInterface.CallHook(\u0022IOnPlayerCommand\u0022, player, message);\n\t\t\treturn false;\n\t\t}\n\t\ttext = text.EscapeRichText();\n\t\tobject obj = Interface.CallHook(\u0022IOnPlayerChat\u0022, userId, username, text, targetChannel, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (serverlog)\n\t\t{\n\t\t\tServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat(\u0022[\u0022, targetChannel, \u0022] \u0022, username, \u0022: \u0022), ConsoleColor.DarkGreen, text);\n\t\t\tstring text2 = player?.ToString() ?? $\u0022{username}[{userId}]\u0022;\n\t\t\tswitch (targetChannel)\n\t\t\t{\n\t\t\tcase ChatChannel.Team:\n\t\t\t\tDebugEx.Log(\u0022[TEAM CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\tcase ChatChannel.Cards:\n\t\t\t\tDebugEx.Log(\u0022[CARDS CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDebugEx.Log(\u0022[CHAT] \u0022 \u002B text2 \u002B \u0022 : \u0022 \u002B text);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;\n\t\tbool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));\n\t\tstring text3 = \u0022#5af\u0022;\n\t\tif (flag)\n\t\t{\n\t\t\ttext3 = \u0022#af5\u0022;\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\ttext3 = \u0022#fa5\u0022;\n\t\t}\n\t\tstring text4 = username.EscapeRichText();\n\t\tChatEntry ce = default(ChatEntry);\n\t\tce.Channel = targetChannel;\n\t\tce.Message = text;\n\t\tce.UserId = ((player != null) ? player.UserIDString : userId.ToString());\n\t\tce.Username = username;\n\t\tce.Color = text3;\n\t\tce.Time = Epoch.Current;\n\t\tRecord(ce);\n\t\tswitch (targetChannel)\n\t\t{\n\t\tcase ChatChannel.Cards:\n\t\t{\n\t\t\tif (player == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!player.isMounted)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;\n\t\t\tif (baseCardGameEntity == null || !baseCardGameEntity.GameController.IsAtTable(player))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E obj2 = Facepunch.Pool.GetList\u003CNetwork.Connection\u003E();\n\t\t\tbaseCardGameEntity.GameController.GetConnectionsInGame(obj2);\n\t\t\tif (obj2.Count \u003E 0)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(obj2, \u0022chat.add2\u0022, 3, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Global:\n\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add2\u0022, 0, userId, text, text4, text3, 1f);\n\t\t\treturn true;\n\t\tcase ChatChannel.Local:\n\t\t{\n\t\t\tif (!(player != null))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfloat num2 = localChatRange * localChatRange;\n\t\t\tforeach (BasePlayer activePlayer in BasePlayer.activePlayerList)\n\t\t\t{\n\t\t\t\tfloat sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;\n\t\t\t\tif (!(sqrMagnitude \u003E num2))\n\t\t\t\t{\n\t\t\t\t\tConsoleNetwork.SendClientCommand(activePlayer.net.connection, \u0022chat.add2\u0022, 4, userId, text, text4, text3, Mathf.Clamp01(sqrMagnitude / num2 \u002B 0.2f));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tcase ChatChannel.Team:\n\t\t{\n\t\t\tRelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);\n\t\t\tif (playerTeam == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tList\u003CNetwork.Connection\u003E onlineMemberConnections = playerTeam.GetOnlineMemberConnections();\n\t\t\tif (onlineMemberConnections != null)\n\t\t\t{\n\t\t\t\tConsoleNetwork.SendClientCommand(onlineMemberConnections, \u0022chat.add2\u0022, 1, userId, text, text4, text3, 1f);\n\t\t\t}\n\t\t\tplayerTeam.BroadcastTeamChat(userId, text4, text, text3);\n\t\t\treturn true;\n\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Chat",
    "HookLineInvoke": 35
  },
  {
    "HookSignature": "OnBroadcastCommand(string strCommand, object[] args)",
    "MethodSignature": "BroadcastToAllClients(string strCommand, object[] args)",
    "MethodSourseCode": "\n\tpublic static void BroadcastToAllClients(string strCommand, params object[] args)\n\t{\n\t\tif (Network.Net.sv.IsConnected() \u0026\u0026 Interface.CallHook(\u0022OnBroadcastCommand\u0022, strCommand, args) == null)\n\t\t{\n\t\t\tNetWrite netWrite = Network.Net.sv.StartWrite();\n\t\t\tnetWrite.PacketID(Message.Type.ConsoleCommand);\n\t\t\tnetWrite.String(ConsoleSystem.BuildCommand(strCommand, args));\n\t\t\tnetWrite.Send(new SendInfo(Network.Net.sv.connections));\n\t\t}\n\t}\n",
    "ClassName": "ConsoleNetwork",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnNpcGiveSoldItem(NPCVendingMachine nPCVendingMachine, Item soldItem, BasePlayer buyer)",
    "MethodSignature": "GiveSoldItem(Item soldItem, BasePlayer buyer)",
    "MethodSourseCode": "\n\tpublic override void GiveSoldItem(Item soldItem, BasePlayer buyer)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcGiveSoldItem\u0022, this, soldItem, buyer) == null)\n\t\t{\n\t\t\tbase.GiveSoldItem(soldItem, buyer);\n\t\t}\n\t}\n",
    "ClassName": "NPCVendingMachine",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnExplosiveDud(DudTimedExplosive dudTimedExplosive)",
    "MethodSignature": "Explode()",
    "MethodSourseCode": "\n\tpublic override void Explode()\n\t{\n\t\tif (creatorEntity != null \u0026\u0026 creatorEntity.IsNpc)\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t\telse if (UnityEngine.Random.Range(0f, 1f) \u003C dudChance \u0026\u0026 Interface.CallHook(\u0022OnExplosiveDud\u0022, this) == null)\n\t\t{\n\t\t\tBecomeDud();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase.Explode();\n\t\t}\n\t}\n",
    "ClassName": "DudTimedExplosive",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanBeWounded(BasePlayer basePlayer, HitInfo info)",
    "MethodSignature": "EligibleForWounding(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual bool EligibleForWounding(HitInfo info)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanBeWounded\u0022, this, info);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (!ConVar.Server.woundingenabled)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsWounded())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (isMounted)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (info == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsWounded() \u0026\u0026 UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime \u003C ConVar.Server.rewounddelay)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif ((bool)activeGameMode \u0026\u0026 !activeGameMode.allowWounding)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (triggers != null)\n\t\t{\n\t\t\tfor (int i = 0; i \u003C triggers.Count; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tif (triggers[i] is IHurtTrigger)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.WeaponPrefab is BaseMelee)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (info.WeaponPrefab is BaseProjectile)\n\t\t{\n\t\t\treturn !info.isHeadshot;\n\t\t}\n\t\treturn info.damageTypes.GetMajorityDamageType() switch\n\t\t{\n\t\t\tDamageType.Suicide =\u003E false, \n\t\t\tDamageType.Fall =\u003E true, \n\t\t\tDamageType.Bite =\u003E true, \n\t\t\tDamageType.Bleeding =\u003E true, \n\t\t\tDamageType.Hunger =\u003E true, \n\t\t\tDamageType.Thirst =\u003E true, \n\t\t\tDamageType.Poison =\u003E true, \n\t\t\t_ =\u003E false, \n\t\t};\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnTeamCreated(BasePlayer basePlayer, RelationshipManager.PlayerTeam playerTeam)",
    "MethodSignature": "trycreateteam(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[ServerUserVar]\n\tpublic static void trycreateteam(ConsoleSystem.Arg arg)\n\t{\n\t\tif (maxTeamSize == 0)\n\t\t{\n\t\t\targ.ReplyWith(\u0022Teams are disabled on this server\u0022);\n\t\t\treturn;\n\t\t}\n\t\tBasePlayer basePlayer = ArgEx.Player(arg);\n\t\tif (basePlayer.currentTeam == 0L \u0026\u0026 Interface.CallHook(\u0022OnTeamCreate\u0022, basePlayer) == null)\n\t\t{\n\t\t\tPlayerTeam playerTeam = ServerInstance.CreateTeam();\n\t\t\tPlayerTeam playerTeam2 = playerTeam;\n\t\t\tplayerTeam2.teamLeader = basePlayer.userID;\n\t\t\tplayerTeam2.AddPlayer(basePlayer);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\u0022created\u0022, playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);\n\t\t\tInterface.CallHook(\u0022OnTeamCreated\u0022, basePlayer, playerTeam);\n\t\t}\n\t}\n",
    "ClassName": "RelationshipManager",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnDoorKnocked(Door door, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_KnockDoor(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_KnockDoor(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract(usableWhileCrawling: true) || !knockEffect.isValid || UnityEngine.Time.realtimeSinceStartup \u003C nextKnockTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextKnockTime = UnityEngine.Time.realtimeSinceStartup \u002B 0.5f;\n\t\tBaseEntity slot = GetSlot(Slot.LowerCenterDecoration);\n\t\tif (slot != null)\n\t\t{\n\t\t\tDoorKnocker component = slot.GetComponent\u003CDoorKnocker\u003E();\n\t\t\tif ((bool)component)\n\t\t\t{\n\t\t\t\tcomponent.Knock(rpc.player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEffect.server.Run(knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\tInterface.CallHook(\u0022OnDoorKnocked\u0022, this, rpc.player);\n\t}\n",
    "ClassName": "Door",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount, bool free)",
    "MethodSignature": "CanCraft(ItemBlueprint bp, int amount, bool free)",
    "MethodSourseCode": "\n\tpublic bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)\n\t{\n\t\tfloat num = (float)amount / (float)bp.targetItem.craftingStackable;\n\t\tforeach (ItemCraftTask item in queue)\n\t\t{\n\t\t\tif (!item.cancelled)\n\t\t\t{\n\t\t\t\tnum \u002B= (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;\n\t\t\t}\n\t\t}\n\t\tif (num \u003E 8f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (amount \u003C 1 || amount \u003E bp.targetItem.craftingStackable)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanCraft\u0022, this, bp, amount, free);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount ingredient in bp.ingredients)\n\t\t{\n\t\t\tif (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "ItemCrafter",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnMlrsRocketFired(MLRS mLRS, ServerProjectile projectile)",
    "MethodSignature": "FireNextRocket()",
    "MethodSourseCode": "\n\tpublic void FireNextRocket()\n\t{\n\t\tRocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);\n\t\tif (nextRocketIndex \u003C 0 || nextRocketIndex \u003E= RocketAmmoCount || IsBroken())\n\t\t{\n\t\t\tEndFiring();\n\t\t\treturn;\n\t\t}\n\t\tStorageContainer rocketContainer = GetRocketContainer();\n\t\tVector3 firingPos = firingPoint.position \u002B firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;\n\t\tfloat num = 1f;\n\t\tif (radiusModIndex \u003C radiusMods.Length)\n\t\t{\n\t\t\tnum = radiusMods[radiusModIndex];\n\t\t}\n\t\tradiusModIndex\u002B\u002B;\n\t\tVector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;\n\t\tVector3 targetPos = TrueHitPos \u002B new Vector3(vector.x, 0f, vector.y);\n\t\tfloat g;\n\t\tVector3 aimToTarget = GetAimToTarget(targetPos, out g);\n\t\tif (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))\n\t\t{\n\t\t\tprojectile.gravityModifier = g / (0f - UnityEngine.Physics.gravity.y);\n\t\t\tInterface.CallHook(\u0022OnMlrsRocketFired\u0022, this, projectile);\n\t\t\tnextRocketIndex--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEndFiring();\n\t\t}\n\t}\n",
    "ClassName": "MLRS",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnTurretStartup(AutoTurret autoTurret)",
    "MethodSignature": "InitiateStartup()",
    "MethodSourseCode": "\n\tpublic void InitiateStartup()\n\t{\n\t\tif (!IsOnline() \u0026\u0026 !booting \u0026\u0026 Interface.CallHook(\u0022OnTurretStartup\u0022, this) == null)\n\t\t{\n\t\t\tEffect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\tInvoke(SetOnline, 2f);\n\t\t\tbooting = true;\n\t\t}\n\t}\n",
    "ClassName": "AutoTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityLeave(TriggerComfort triggerComfort, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic override void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tBasePlayer basePlayer = ent as BasePlayer;\n\t\tif ((bool)basePlayer \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\t_players.Remove(basePlayer);\n\t\t}\n\t}\n",
    "ClassName": "TriggerComfort",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnFireworkExhausted(BaseFirework baseFirework)",
    "MethodSignature": "OnExhausted()",
    "MethodSourseCode": "\n\tpublic virtual void OnExhausted()\n\t{\n\t\tSetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);\n\t\tSetFlag(Flags.On, b: false, recursive: false, networkupdate: false);\n\t\tEnableGlobalBroadcast(wants: false);\n\t\tSendNetworkUpdate_Flags();\n\t\tInterface.CallHook(\u0022OnFireworkExhausted\u0022, this);\n\t\tInvoke(Cleanup, corpseDuration);\n\t\t_activeFireworks.Remove(this);\n\t}\n",
    "ClassName": "BaseFirework",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnExcavatorResourceSet(ExcavatorArm excavatorArm, string text, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_SetResourceTarget(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_SetResourceTarget(RPCMessage msg)\n\t{\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022OnExcavatorResourceSet\u0022, this, text, msg.player) == null)\n\t\t{\n\t\t\tswitch (text)\n\t\t\t{\n\t\t\tcase \u0022HQM\u0022:\n\t\t\t\tresourceMiningIndex = 0;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Sulfur\u0022:\n\t\t\t\tresourceMiningIndex = 1;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Stone\u0022:\n\t\t\t\tresourceMiningIndex = 2;\n\t\t\t\tbreak;\n\t\t\tcase \u0022Metal\u0022:\n\t\t\t\tresourceMiningIndex = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!IsOn())\n\t\t\t{\n\t\t\t\tBeginMining();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ExcavatorArm",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnDemoRecordingStop(string netConnectionRecordFilename, BasePlayer basePlayer)",
    "MethodSignature": "StopDemoRecording()",
    "MethodSourseCode": "\n\tpublic void StopDemoRecording()\n\t{\n\t\tif (net != null \u0026\u0026 net.connection != null \u0026\u0026 net.connection.IsRecording \u0026\u0026 Interface.CallHook(\u0022OnDemoRecordingStop\u0022, net.connection.recordFilename, this) == null)\n\t\t{\n\t\t\tDebug.Log(ToString() \u002B \u0022 recording stopped: \u0022 \u002B net.connection.RecordFilename);\n\t\t\tnet.connection.StopRecording();\n\t\t\tCancelInvoke(MonitorDemoRecording);\n\t\t\tInterface.CallHook(\u0022OnDemoRecordingStopped\u0022, net.connection.recordFilename, this);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSwitchToggle(FuelGenerator fuelGenerator, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_EngineSwitch(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_EngineSwitch(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnSwitchToggle\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tbool generatorState = msg.read.Bit();\n\t\t\tSetGeneratorState(generatorState);\n\t\t\tInterface.CallHook(\u0022OnSwitchToggled\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "FuelGenerator",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnWeaponModChange(BaseProjectile baseProjectile, BasePlayer getOwnerPlayer)",
    "MethodSignature": "DelayedModsChanged()",
    "MethodSourseCode": "\n\tpublic void DelayedModsChanged()\n\t{\n\t\tif (Interface.CallHook(\u0022OnWeaponModChange\u0022, this, GetOwnerPlayer()) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) =\u003E x.magazineCapacity, (ProjectileWeaponMod.Modifier y) =\u003E y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);\n\t\tif (num == primaryMagazine.capacity)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (primaryMagazine.contents \u003E 0 \u0026\u0026 primaryMagazine.contents \u003E num)\n\t\t{\n\t\t\t_ = primaryMagazine.ammoType;\n\t\t\tint contents = primaryMagazine.contents;\n\t\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\t\tItemContainer itemContainer = null;\n\t\t\tif (ownerPlayer != null)\n\t\t\t{\n\t\t\t\titemContainer = ownerPlayer.inventory.containerMain;\n\t\t\t}\n\t\t\telse if (GetCachedItem() != null)\n\t\t\t{\n\t\t\t\titemContainer = GetCachedItem().parent;\n\t\t\t}\n\t\t\tprimaryMagazine.contents = 0;\n\t\t\tif (itemContainer != null)\n\t\t\t{\n\t\t\t\tItem item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);\n\t\t\t\tif (!item.MoveToContainer(itemContainer))\n\t\t\t\t{\n\t\t\t\t\tVector3 vPos = base.transform.position;\n\t\t\t\t\tif (itemContainer.entityOwner != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvPos = itemContainer.entityOwner.transform.position \u002B Vector3.up * 0.25f;\n\t\t\t\t\t}\n\t\t\t\t\titem.Drop(vPos, Vector3.up * 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprimaryMagazine.capacity = num;\n\t\tSendNetworkUpdate();\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWireClear(BasePlayer ply, IOEntity iOEntity, int clearIndex, IOEntity iOEntity2, bool isInput)",
    "MethodSignature": "AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)",
    "MethodSourseCode": "\n\tpublic static void AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)\n\t{\n\t\tIOEntity iOEntity = ((clearEnt == null) ? null : clearEnt.GetComponent\u003CIOEntity\u003E());\n\t\tif (iOEntity == null || (ply != null \u0026\u0026 !CanModifyEntity(ply, iOEntity)) || clearIndex \u003E= (isInput ? iOEntity.inputs.Length : iOEntity.outputs.Length))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity.IOSlot iOSlot = (isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);\n\t\tif (iOSlot.connectedTo.Get() == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity iOEntity2 = iOSlot.connectedTo.Get();\n\t\tif (Interface.CallHook(\u0022OnWireClear\u0022, ply, iOEntity, clearIndex, iOEntity2, isInput) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tIOEntity.IOSlot obj = (isInput ? iOEntity2.outputs[iOSlot.connectedToSlot] : iOEntity2.inputs[iOSlot.connectedToSlot]);\n\t\tif (isInput)\n\t\t{\n\t\t\tiOEntity.UpdateFromInput(0, clearIndex);\n\t\t}\n\t\telse if ((bool)iOEntity2)\n\t\t{\n\t\t\tiOEntity2.UpdateFromInput(0, iOSlot.connectedToSlot);\n\t\t}\n\t\tiOSlot.Clear();\n\t\tobj.Clear();\n\t\tiOEntity.MarkDirtyForceUpdateOutputs();\n\t\tiOEntity.SendNetworkUpdate();\n\t\tiOEntity.RefreshIndustrialPreventBuilding();\n\t\tif (iOEntity2 != null)\n\t\t{\n\t\t\tiOEntity2.RefreshIndustrialPreventBuilding();\n\t\t}\n\t\tif (isInput \u0026\u0026 iOEntity2 != null)\n\t\t{\n\t\t\tiOEntity2.SendChangedToRoot(forceUpdate: true);\n\t\t}\n\t\telse if (!isInput)\n\t\t{\n\t\t\tIOEntity.IOSlot[] inputs = iOEntity.inputs;\n\t\t\tforeach (IOEntity.IOSlot iOSlot2 in inputs)\n\t\t\t{\n\t\t\t\tif (iOSlot2.mainPowerSlot \u0026\u0026 (bool)iOSlot2.connectedTo.Get())\n\t\t\t\t{\n\t\t\t\t\tiOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tiOEntity2.SendNetworkUpdate();\n\t\tif (iOEntity != null \u0026\u0026 iOEntity.ioType == IOEntity.IOType.Industrial)\n\t\t{\n\t\t\tiOEntity.NotifyIndustrialNetworkChanged();\n\t\t}\n\t\tif (iOEntity2 != null \u0026\u0026 iOEntity2.ioType == IOEntity.IOType.Industrial)\n\t\t{\n\t\t\tiOEntity2.NotifyIndustrialNetworkChanged();\n\t\t}\n\t}\n",
    "ClassName": "WireTool",
    "HookLineInvoke": 14
  },
  {
    "HookSignature": "CanHelicopterTarget(PatrolHelicopterAI patrolHelicopterAI, BasePlayer ply)",
    "MethodSignature": "PlayerVisible(BasePlayer ply)",
    "MethodSourseCode": "\n\tpublic bool PlayerVisible(BasePlayer ply)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanHelicopterTarget\u0022, this, ply);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tVector3 position = ply.eyes.position;\n\t\tif (TOD_Sky.Instance.IsNight \u0026\u0026 Vector3.Distance(position, interestZoneOrigin) \u003E 40f)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tVector3 vector = base.transform.position - Vector3.up * 6f;\n\t\tfloat num = Vector3.Distance(position, vector);\n\t\tVector3 normalized = (position - vector).normalized;\n\t\tif (GamePhysics.Trace(new Ray(vector \u002B normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) \u0026\u0026 GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "PatrolHelicopterAI",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnRfFrequencyChange(Detonator detonator, int num, BasePlayer msgPlayer)",
    "MethodSignature": "ServerSetFrequency(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void ServerSetFrequency(RPCMessage msg)\n\t{\n\t\tif (msg.player == null || !msg.player.CanBuild() || GetOwnerPlayer() != msg.player || UnityEngine.Time.time \u003C nextChangeTime)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tnextChangeTime = UnityEngine.Time.time \u002B 2f;\n\t\tint num = msg.read.Int32();\n\t\tif (RFManager.IsReserved(num))\n\t\t{\n\t\t\tRFManager.ReserveErrorPrint(msg.player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022OnRfFrequencyChange\u0022, this, num, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem ownerItem = GetOwnerItem();\n\t\t\tRFManager.ChangeFrequency(frequency, num, this, isListener: false, IsOn());\n\t\t\tfrequency = num;\n\t\t\tSendNetworkUpdate();\n\t\t\tItem item = GetItem();\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\tif (item.instanceData == null)\n\t\t\t\t{\n\t\t\t\t\titem.instanceData = new ProtoBuf.Item.InstanceData();\n\t\t\t\t\titem.instanceData.ShouldPool = false;\n\t\t\t\t}\n\t\t\t\titem.instanceData.dataInt = frequency;\n\t\t\t\titem.MarkDirty();\n\t\t\t}\n\t\t\townerItem?.LoseCondition(ownerItem.maxCondition * 0.01f);\n\t\t\tInterface.CallHook(\u0022OnRfFrequencyChanged\u0022, this, num, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "Detonator",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "CanLootPlayer(BasePlayer basePlayer, BasePlayer player)",
    "MethodSignature": "CanBeLooted(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override bool CanBeLooted(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanLootPlayer\u0022, this, player);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player == this)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsWounded())\n\t\t{\n\t\t\treturn IsSleeping();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnQuarryConsumeFuel(MiningQuarry miningQuarry, Item item)",
    "MethodSignature": "FuelCheck()",
    "MethodSourseCode": "\n\tpublic bool FuelCheck()\n\t{\n\t\tif (pendingWork \u003E 0f)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tItem item = fuelStoragePrefab.instance.GetComponent\u003CStorageContainer\u003E().inventory.FindItemsByItemName(\u0022diesel_barrel\u0022);\n\t\tobject obj = Interface.CallHook(\u0022OnQuarryConsumeFuel\u0022, this, item);\n\t\tif (obj is Item)\n\t\t{\n\t\t\titem = (Item)obj;\n\t\t}\n\t\tif (item != null \u0026\u0026 item.amount \u003E= 1)\n\t\t{\n\t\t\tpendingWork \u002B= workPerFuel;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);\n\t\t\titem.UseItem();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "MiningQuarry",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnHelicopterDropDoorOpen(CH47HelicopterAIController cH47HelicopterAIController)",
    "MethodSignature": "SetDropDoorOpen(bool open)",
    "MethodSourseCode": "\n\tpublic void SetDropDoorOpen(bool open)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterDropDoorOpen\u0022, this) == null)\n\t\t{\n\t\t\tSetFlag(Flags.Reserved8, open);\n\t\t}\n\t}\n",
    "ClassName": "CH47HelicopterAIController",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnDieselEngineToggled(DieselEngine dieselEngine)",
    "MethodSignature": "EngineOff()",
    "MethodSourseCode": "\n\tpublic void EngineOff()\n\t{\n\t\tSetFlag(Flags.On, b: false);\n\t\tBroadcastEntityMessage(\u0022DieselEngineOff\u0022);\n\t\tInterface.CallHook(\u0022OnDieselEngineToggled\u0022, this);\n\t}\n",
    "ClassName": "DieselEngine",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSignature": "RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity)",
    "MethodSourseCode": "\n\tpublic void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)\n\t{\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif ((bool)activeGameMode \u0026\u0026 !activeGameMode.CanPlayerRespawn(this))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSetPlayerFlag(PlayerFlags.Wounded, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Incapacitated, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Unused2, b: false);\n\t\tSetPlayerFlag(PlayerFlags.Unused1, b: false);\n\t\tSetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);\n\t\tSetPlayerFlag(PlayerFlags.DisplaySash, b: false);\n\t\trespawnId = Guid.NewGuid().ToString(\u0022N\u0022);\n\t\tServerPerformance.spawns\u002B\u002B;\n\t\tSetParent(null, worldPositionStays: true);\n\t\tbase.transform.SetPositionAndRotation(position, rotation);\n\t\ttickInterpolator.Reset(position);\n\t\ttickHistory.Reset(position);\n\t\teyeHistory.Clear();\n\t\testimatedVelocity = Vector3.zero;\n\t\testimatedSpeed = 0f;\n\t\testimatedSpeed2D = 0f;\n\t\tlastTickTime = 0f;\n\t\tStopWounded();\n\t\tResetWoundingVars();\n\t\tStopSpectating();\n\t\tUpdateNetworkGroup();\n\t\tEnablePlayerCollider();\n\t\tRemovePlayerRigidbody();\n\t\tStartSleeping();\n\t\tLifeStoryStart();\n\t\tmetabolism.Reset();\n\t\tif (modifiers != null)\n\t\t{\n\t\t\tmodifiers.RemoveAll();\n\t\t}\n\t\tInitializeHealth(StartHealth(), StartMaxHealth());\n\t\tbool flag = false;\n\t\tif (ConVar.Server.respawnWithLoadout)\n\t\t{\n\t\t\tstring infoString = GetInfoString(\u0022client.respawnloadout\u0022, string.Empty);\n\t\t\tif (!string.IsNullOrEmpty(infoString) \u0026\u0026 Inventory.LoadLoadout(infoString, out var so))\n\t\t\t{\n\t\t\t\tso.LoadItemsOnTo(this);\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif (!flag)\n\t\t{\n\t\t\tinventory.GiveDefaultItems();\n\t\t}\n\t\tSendNetworkUpdateImmediate();\n\t\tClientRPCPlayer(null, this, \u0022StartLoading\u0022);\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);\n\t\tif ((bool)activeGameMode)\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);\n\t\t}\n\t\tif (net != null)\n\t\t{\n\t\t\tEACServer.OnStartLoading(net.connection);\n\t\t}\n\t\tInterface.CallHook(\u0022OnPlayerRespawned\u0022, this);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 64
  },
  {
    "HookSignature": "CanUpdateSign(BasePlayer player, Signage signage)",
    "MethodSignature": "CanUpdateSign(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual bool CanUpdateSign(BasePlayer player)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUpdateSign\u0022, player, this);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (player.IsAdmin || player.IsDeveloper)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (!player.CanBuild())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (IsLocked())\n\t\t{\n\t\t\treturn player.userID == base.OwnerID;\n\t\t}\n\t\tif (!HeldEntityCheck(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Signage",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnAirdrop(CargoPlane cargoPlane, UnityEngine.Vector3 newDropPosition)",
    "MethodSignature": "UpdateDropPosition(Vector3 newDropPosition)",
    "MethodSourseCode": "\n\tpublic void UpdateDropPosition(Vector3 newDropPosition)\n\t{\n\t\tfloat x = TerrainMeta.Size.x;\n\t\tfloat y = TerrainMeta.HighestPoint.y \u002B 250f;\n\t\tstartPos = Vector3Ex.Range(-1f, 1f);\n\t\tstartPos.y = 0f;\n\t\tstartPos.Normalize();\n\t\tstartPos *= x * 2f;\n\t\tstartPos.y = y;\n\t\tendPos = startPos * -1f;\n\t\tendPos.y = startPos.y;\n\t\tstartPos \u002B= newDropPosition;\n\t\tendPos \u002B= newDropPosition;\n\t\tsecondsToTake = Vector3.Distance(startPos, endPos) / 50f;\n\t\tsecondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\n\t\tbase.transform.position = startPos;\n\t\tbase.transform.rotation = Quaternion.LookRotation(endPos - startPos);\n\t\tdropPosition = newDropPosition;\n\t\tInterface.CallHook(\u0022OnAirdrop\u0022, this, newDropPosition);\n\t}\n",
    "ClassName": "CargoPlane",
    "HookLineInvoke": 19
  },
  {
    "HookSignature": "OnMeleeThrown(BasePlayer player, Item item)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (player == null || player.IsHeadUnderwater())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!canThrowAsProjectile)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Not throwable (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022not_throwable\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItem item = GetItem();\n\t\t\tif (item == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022item_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemModProjectile component = item.info.GetComponent\u003CItemModProjectile\u003E();\n\t\t\tif (component == null)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\n\t\t\tif (projectileShoot.projectiles.Count != 1)\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Projectile count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022count_mismatch\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tplayer.CleanupExpiredProjectiles();\n\t\t\tGuid projectileGroupId = Guid.NewGuid();\n\t\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t\t{\n\t\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t\t{\n\t\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022duplicate_id\u0022);\n\t\t\t\t}\n\t\t\t\telse if (ValidateEyePos(player, projectile.startPos))\n\t\t\t\t{\n\t\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, item);\n\t\t\t\t\tEffect effect = new Effect();\n\t\t\t\t\teffect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);\n\t\t\t\t\teffect.scale = 1f;\n\t\t\t\t\teffect.pooledString = component.projectileObject.resourcePath;\n\t\t\t\t\teffect.number = projectile.seed;\n\t\t\t\t\tEffectNetwork.Send(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprojectileShoot?.Dispose();\n\t\t\titem.SetParent(null);\n\t\t\tInterface.CallHook(\u0022OnMeleeThrown\u0022, player, item);\n\t\t\tif (!canAiHearIt)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfloat num = 0f;\n\t\t\tif (component.projectileObject != null)\n\t\t\t{\n\t\t\t\tGameObject gameObject = component.projectileObject.Get();\n\t\t\t\tif (gameObject != null)\n\t\t\t\t{\n\t\t\t\t\tProjectile component2 = gameObject.GetComponent\u003CProjectile\u003E();\n\t\t\t\t\tif (component2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (DamageTypeEntry damageType in component2.damageTypes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum \u002B= damageType.amount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (player != null)\n\t\t\t{\n\t\t\t\tSensation sensation = default(Sensation);\n\t\t\t\tsensation.Type = SensationType.ThrownWeapon;\n\t\t\t\tsensation.Position = player.transform.position;\n\t\t\t\tsensation.Radius = 50f;\n\t\t\t\tsensation.DamagePotential = num;\n\t\t\t\tsensation.InitiatorPlayer = player;\n\t\t\t\tsensation.Initiator = player;\n\t\t\t\tSense.Stimulate(sensation);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 66
  },
  {
    "HookSignature": "OnRfBroadcasterAdded(IRFObject obj, int frequency)",
    "MethodSignature": "AddBroadcaster(int frequency, IRFObject obj)",
    "MethodSourseCode": "\n\tpublic static void AddBroadcaster(int frequency, IRFObject obj)\n\t{\n\t\tfrequency = ClampFrequency(frequency);\n\t\tif (Interface.CallHook(\u0022OnRfBroadcasterAdd\u0022, obj, frequency) == null)\n\t\t{\n\t\t\tList\u003CIRFObject\u003E broadcasterList = GetBroadcasterList(frequency);\n\t\t\tif (!broadcasterList.Contains(obj))\n\t\t\t{\n\t\t\t\tbroadcasterList.Add(obj);\n\t\t\t\tMarkFrequencyDirty(frequency);\n\t\t\t\tInterface.CallHook(\u0022OnRfBroadcasterAdded\u0022, obj, frequency);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RFManager",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnMapMarkersClear(BasePlayer basePlayer, System.Collections.Generic.List\u003CProtoBuf.MapNote\u003E StatePointsOfInterest)",
    "MethodSignature": "Server_ClearMapMarkers(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.CallsPerSecond(1uL)]\n\tpublic void Server_ClearMapMarkers(RPCMessage msg)\n\t{\n\t\tif (Interface.CallHook(\u0022OnMapMarkersClear\u0022, this, State.pointsOfInterest) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tServerCurrentDeathNote?.Dispose();\n\t\tServerCurrentDeathNote = null;\n\t\tif (State.pointsOfInterest != null)\n\t\t{\n\t\t\tforeach (MapNote item in State.pointsOfInterest)\n\t\t\t{\n\t\t\t\titem?.Dispose();\n\t\t\t}\n\t\t\tState.pointsOfInterest.Clear();\n\t\t}\n\t\tDirtyPlayerState();\n\t\tTeamUpdate();\n\t\tInterface.CallHook(\u0022OnMapMarkersCleared\u0022, this);\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanRecycle(Recycler recycler, Item slot)",
    "MethodSignature": "HasRecyclable()",
    "MethodSourseCode": "\n\tpublic bool HasRecyclable()\n\t{\n\t\tfor (int i = 0; i \u003C 6; i\u002B\u002B)\n\t\t{\n\t\t\tItem slot = base.inventory.GetSlot(i);\n\t\t\tif (slot != null)\n\t\t\t{\n\t\t\t\tobject obj = Interface.CallHook(\u0022CanRecycle\u0022, this, slot);\n\t\t\t\tif (obj is bool)\n\t\t\t\t{\n\t\t\t\t\treturn (bool)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnItemRecycle(Item slot, Recycler recycler)",
    "MethodSignature": "RecycleThink()",
    "MethodSourseCode": "\n\tpublic void RecycleThink()\n\t{\n\t\tbool flag = false;\n\t\tfloat num = recycleEfficiency;\n\t\tint num2 = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (num2 \u003C 6)\n\t\t\t{\n\t\t\t\tItem slot = base.inventory.GetSlot(num2);\n\t\t\t\tif (!CanBeRecycled(slot))\n\t\t\t\t{\n\t\t\t\t\tnum2\u002B\u002B;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Interface.CallHook(\u0022OnItemRecycle\u0022, slot, this) != null)\n\t\t\t\t{\n\t\t\t\t\tif (!HasRecyclable())\n\t\t\t\t\t{\n\t\t\t\t\t\tStopRecycling();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (slot.hasCondition)\n\t\t\t\t{\n\t\t\t\t\tnum = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));\n\t\t\t\t}\n\t\t\t\tint num3 = 1;\n\t\t\t\tif (slot.amount \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tnum3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));\n\t\t\t\t}\n\t\t\t\tobject obj = Interface.CallHook(\u0022OnItemRecycleAmount\u0022, slot, num3, this);\n\t\t\t\tif (obj is int)\n\t\t\t\t{\n\t\t\t\t\tnum3 = (int)obj;\n\t\t\t\t}\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tint num4 = slot.info.Blueprint.scrapFromRecycle * num3;\n\t\t\t\t\tif (slot.MaxStackable() == 1 \u0026\u0026 slot.hasCondition)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);\n\t\t\t\t\t}\n\t\t\t\t\tif (num4 \u003E= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem item = ItemManager.CreateByName(\u0022scrap\u0022, num4, 0uL);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);\n\t\t\t\t\t\tMoveItemToOutput(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))\n\t\t\t\t{\n\t\t\t\t\tList\u003CBasePlayer\u003E obj2 = Facepunch.Pool.GetList\u003CBasePlayer\u003E();\n\t\t\t\t\tVis.Entities(base.transform.position, 3f, obj2, 131072);\n\t\t\t\t\tforeach (BasePlayer item3 in obj2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item3.IsAlive() \u0026\u0026 !item3.IsSleeping() \u0026\u0026 item3.inventory.loot.entitySource == this)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);\n\t\t\t\t\t\t\titem3.stats.Save();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t\t\t}\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);\n\t\t\t\tslot.UseItem(num3);\n\t\t\t\tforeach (ItemAmount ingredient in slot.info.Blueprint.ingredients)\n\t\t\t\t{\n\t\t\t\t\tif (ingredient.itemDef.shortname == \u0022scrap\u0022)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfloat num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;\n\t\t\t\t\tint num6 = 0;\n\t\t\t\t\tif (num5 \u003C= 1f)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i \u003C num3; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C= num5 * num)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnum6\u002B\u002B;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnum6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;\n\t\t\t\t\t}\n\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);\n\t\t\t\t\tfor (int j = 0; j \u003C num7; j\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num8 = ((num6 \u003E ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);\n\t\t\t\t\t\tItem item2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);\n\t\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);\n\t\t\t\t\t\tif (!MoveItemToOutput(item2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnum6 -= num8;\n\t\t\t\t\t\tif (num6 \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag || !HasRecyclable())\n\t\t\t{\n\t\t\t\tStopRecycling();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n",
    "ClassName": "Recycler",
    "HookLineInvoke": 16
  },
  {
    "HookSignature": "IOnServerShutdown()",
    "MethodSignature": "Shutdown()",
    "MethodSourseCode": "\n\tinternal void Shutdown()\n\t{\n\t\tInterface.CallHook(\u0022IOnServerShutdown\u0022);\n\t\tBasePlayer[] array = BasePlayer.activePlayerList.ToArray();\n\t\tfor (int i = 0; i \u003C array.Length; i\u002B\u002B)\n\t\t{\n\t\t\tarray[i].Kick(\u0022Server Shutting Down\u0022);\n\t\t}\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.save\u0022);\n\t\tConsoleSystem.Run(ConsoleSystem.Option.Server, \u0022server.writecfg\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer msgPlayer)",
    "MethodSignature": "RPC_OpenShop(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_OpenShop(RPCMessage msg)\n\t{\n\t\tif (OccupiedCheck(msg.player) \u0026\u0026 Interface.CallHook(\u0022OnVendingShopOpen\u0022, this, msg.player) == null)\n\t\t{\n\t\t\tSendSellOrders(msg.player);\n\t\t\tPlayerOpenLoot(msg.player, customerPanel);\n\t\t\tInterface.CallHook(\u0022OnVendingShopOpened\u0022, this, msg.player);\n\t\t}\n\t}\n",
    "ClassName": "VendingMachine",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerHealthChange(BasePlayer basePlayer, float oldvalue, float newvalue)",
    "MethodSignature": "OnHealthChanged(float oldvalue, float newvalue)",
    "MethodSourseCode": "\n\tpublic override void OnHealthChanged(float oldvalue, float newvalue)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerHealthChange\u0022, this, oldvalue, newvalue) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbase.OnHealthChanged(oldvalue, newvalue);\n\t\tif (base.isServer)\n\t\t{\n\t\t\tif (oldvalue \u003E newvalue)\n\t\t\t{\n\t\t\t\tLifeStoryHurt(oldvalue - newvalue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLifeStoryHeal(newvalue - oldvalue);\n\t\t\t}\n\t\t\tmetabolism.isDirty = true;\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerWantsDismount(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "RPC_WantsDismount(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\tpublic void RPC_WantsDismount(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!HasValidDismountPosition(player))\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerDismountFailed\u0022, player, this);\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnPlayerWantsDismount\u0022, player, this) == null)\n\t\t{\n\t\t\tAttemptDismount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "IOnServerInitialized()",
    "MethodSignature": "OpenConnection()",
    "MethodSourseCode": "\n\tpublic void OpenConnection()\n\t{\n\t\tif (ConVar.Server.queryport \u003C= 0 || ConVar.Server.queryport == ConVar.Server.port)\n\t\t{\n\t\t\tConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) \u002B 1;\n\t\t}\n\t\tNetwork.Net.sv.ip = ConVar.Server.ip;\n\t\tNetwork.Net.sv.port = ConVar.Server.port;\n\t\tStartSteamServer();\n\t\tif (!Network.Net.sv.Start())\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Couldn\u0027t Start Server.\u0022);\n\t\t\tCloseConnection();\n\t\t\treturn;\n\t\t}\n\t\tNetwork.Net.sv.callbackHandler = this;\n\t\tNetwork.Net.sv.cryptography = new NetworkCryptographyServer();\n\t\tEACServer.DoStartup();\n\t\tInvokeRepeating(\u0022DoTick\u0022, 1f, 1f / (float)ConVar.Server.tickrate);\n\t\tInvokeRepeating(\u0022DoHeartbeat\u0022, 1f, 1f);\n\t\trunFrameUpdate = true;\n\t\tConsoleSystem.OnReplicatedVarChanged \u002B= OnReplicatedVarChanged;\n\t\tInterface.CallHook(\u0022IOnServerInitialized\u0022);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "CanChangeCode(BasePlayer rpcPlayer, CodeLock codeLock, string text, bool flag)",
    "MethodSignature": "RPC_ChangeCode(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_ChangeCode(RPCMessage rpc)\n\t{\n\t\tif (!rpc.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = rpc.read.String();\n\t\tbool flag = rpc.read.Bit();\n\t\tif (!IsLocked() \u0026\u0026 text.Length == 4 \u0026\u0026 text.IsNumeric() \u0026\u0026 !(!hasCode \u0026\u0026 flag) \u0026\u0026 Interface.CallHook(\u0022CanChangeCode\u0022, rpc.player, this, text, flag) == null)\n\t\t{\n\t\t\tif (!hasCode \u0026\u0026 !flag)\n\t\t\t{\n\t\t\t\tSetFlag(Flags.Locked, b: true);\n\t\t\t}\n\t\t\tFacepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tcode = text;\n\t\t\t\thasCode = code.Length \u003E 0;\n\t\t\t\twhitelistPlayers.Clear();\n\t\t\t\twhitelistPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tguestCode = text;\n\t\t\t\thasGuestCode = guestCode.Length \u003E 0;\n\t\t\t\tguestPlayers.Clear();\n\t\t\t\tguestPlayers.Add(rpc.player.userID);\n\t\t\t}\n\t\t\tDoEffect(effectCodeChanged.resourcePath);\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "CodeLock",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "InitLogging()",
    "MethodSignature": "StartupShared()",
    "MethodSourseCode": "\n\tprivate void StartupShared()\n\t{\n\t\tInterface.CallHook(\u0022InitLogging\u0022);\n\t\tItemManager.Initialize();\n\t}\n",
    "ClassName": "Bootstrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPortalUsed(BasePlayer player, BasePortal basePortal)",
    "MethodSignature": "UsePortal(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic virtual void UsePortal(BasePlayer player)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPortalUse\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tLinkPortal();\n\t\tif (targetPortal != null)\n\t\t{\n\t\t\tplayer.PauseFlyHackDetection();\n\t\t\tplayer.PauseSpeedHackDetection();\n\t\t\tVector3 position = player.transform.position;\n\t\t\tVector3 vector = targetPortal.GetLocalEntryExitPosition();\n\t\t\tVector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());\n\t\t\tVector3 vector3 = vector2;\n\t\t\tif (isMirrored)\n\t\t\t{\n\t\t\t\tVector3 position2 = base.transform.InverseTransformPoint(player.transform.position);\n\t\t\t\tvector = targetPortal.relativeAnchor.transform.TransformPoint(position2);\n\t\t\t\tvector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;\n\t\t\t}\n\t\t\tif (disappearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(disappearEffect.resourcePath, position, Vector3.up);\n\t\t\t}\n\t\t\tif (appearEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(appearEffect.resourcePath, vector, Vector3.up);\n\t\t\t}\n\t\t\tplayer.SetParent(null, worldPositionStays: true);\n\t\t\tplayer.Teleport(vector);\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForceViewAnglesTo\u0022, vector3);\n\t\t\tif (transitionSoundEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);\n\t\t\t}\n\t\t\tplayer.UpdateNetworkGroup();\n\t\t\tplayer.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);\n\t\t\tSendNetworkUpdateImmediate();\n\t\t\tplayer.ClientRPCPlayer(null, player, \u0022StartLoading_Quick\u0022, arg1: true);\n\t\t\tInterface.CallHook(\u0022OnPortalUsed\u0022, player, this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDebug.Log(\u0022No portal...\u0022);\n\t\t}\n\t}\n",
    "ClassName": "BasePortal",
    "HookLineInvoke": 46
  },
  {
    "HookSignature": "OnExplosiveFuseSet(TimedExplosive timedExplosive, float fuseLength)",
    "MethodSignature": "SetFuse(float fuseLength)",
    "MethodSourseCode": "\n\tpublic virtual void SetFuse(float fuseLength)\n\t{\n\t\tif (base.isServer)\n\t\t{\n\t\t\tobject obj = Interface.CallHook(\u0022OnExplosiveFuseSet\u0022, this, fuseLength);\n\t\t\tif (obj is float)\n\t\t\t{\n\t\t\t\tfuseLength = (float)obj;\n\t\t\t}\n\t\t\tInvoke(Explode, fuseLength);\n\t\t\tSetFlag(Flags.Reserved2, b: true);\n\t\t}\n\t}\n",
    "ClassName": "TimedExplosive",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnLiftUse(Lift lift, BasePlayer rpcPlayer)",
    "MethodSignature": "RPC_UseLift(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tprivate void RPC_UseLift(RPCMessage rpc)\n\t{\n\t\tif (rpc.player.CanInteract() \u0026\u0026 Interface.CallHook(\u0022OnLiftUse\u0022, this, rpc.player) == null)\n\t\t{\n\t\t\tMoveUp();\n\t\t}\n\t}\n",
    "ClassName": "Lift",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnHelicopterTarget(HelicopterTurret helicopterTurret, BaseCombatEntity newTarget)",
    "MethodSignature": "SetTarget(BaseCombatEntity newTarget)",
    "MethodSourseCode": "\n\tpublic void SetTarget(BaseCombatEntity newTarget)\n\t{\n\t\tif (Interface.CallHook(\u0022OnHelicopterTarget\u0022, this, newTarget) == null)\n\t\t{\n\t\t\t_target = newTarget;\n\t\t\tUpdateTargetVisibility();\n\t\t}\n\t}\n",
    "ClassName": "HelicopterTurret",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "CanAffordToPlace(BasePlayer ownerPlayer, Planner planner, Construction component)",
    "MethodSignature": "CanAffordToPlace(Construction component)",
    "MethodSourseCode": "\n\tpublic bool CanAffordToPlace(Construction component)\n\t{\n\t\tif (isTypeDeployable)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tBasePlayer ownerPlayer = GetOwnerPlayer();\n\t\tif (!ownerPlayer)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022CanAffordToPlace\u0022, ownerPlayer, this, component);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tforeach (ItemAmount item in component.defaultGrade.costToBuild)\n\t\t{\n\t\t\tif ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) \u003C item.amount)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "Planner",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerKicked(Network.Connection connection, string actionReasonDetailsString)",
    "MethodSignature": "OnClientActionRequired(OnClientActionRequiredCallbackInfo data)",
    "MethodSourseCode": "\n\tprivate static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)\n\t{\n\t\tusing (TimeWarning.New(\u0022OnClientActionRequired\u0022, 10))\n\t\t{\n\t\t\tIntPtr clientHandle = data.ClientHandle;\n\t\t\tConnection connection = GetConnection(clientHandle);\n\t\t\tif (connection == null)\n\t\t\t{\n\t\t\t\tDebug.LogError(\u0022[EAC] Status update for invalid client: \u0022 \u002B clientHandle);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAntiCheatCommonClientAction clientAction = data.ClientAction;\n\t\t\tif (clientAction != AntiCheatCommonClientAction.RemovePlayer)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tUtf8String actionReasonDetailsString = data.ActionReasonDetailsString;\n\t\t\tDebug.Log($\u0022[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})\u0022);\n\t\t\tconnection.authStatus = \u0022eac\u0022;\n\t\t\tNetwork.Net.sv.Kick(connection, \u0022EAC: \u0022 \u002B actionReasonDetailsString);\n\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerKicked\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\n\t\t\t{\n\t\t\t\tconnection.authStatus = \u0022eacbanned\u0022;\n\t\t\t\tConsoleNetwork.BroadcastToAllClients(\u0022chat.add\u0022, 2, 0, \u0022\u003Ccolor=#fff\u003ESERVER\u003C/color\u003E Kicking \u0022 \u002B connection.username \u002B \u0022 (banned by anticheat)\u0022);\n\t\t\t\tOxide.Core.Interface.CallHook(\u0022OnPlayerBanned\u0022, connection, actionReasonDetailsString.ToString());\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\n\t\t\t\t{\n\t\t\t\t\tEntity.DeleteBy(connection.userid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tUnregisterClientOptions unregisterClientOptions = default(UnregisterClientOptions);\n\t\t\tunregisterClientOptions.ClientHandle = clientHandle;\n\t\t\tUnregisterClientOptions options = unregisterClientOptions;\n\t\t\tInterface.UnregisterClient(ref options);\n\t\t\tclient2connection.TryRemove((uint)(int)clientHandle, out var _);\n\t\t\tconnection2client.TryRemove(connection, out var _);\n\t\t\tconnection2status.TryRemove(connection, out var _);\n\t\t}\n\t}\n",
    "ClassName": "EACServer",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerLand(BasePlayer basePlayer, float num)",
    "MethodSignature": "ApplyFallDamageFromVelocity(float velocity)",
    "MethodSourseCode": "\n\tpublic void ApplyFallDamageFromVelocity(float velocity)\n\t{\n\t\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\n\t\tif (num != 0f \u0026\u0026 Interface.CallHook(\u0022OnPlayerLand\u0022, this, num) == null)\n\t\t{\n\t\t\tmetabolism.bleeding.Add(num * 0.5f);\n\t\t\tfloat num2 = num * 500f;\n\t\t\tFacepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);\n\t\t\tHurt(num2, DamageType.Fall);\n\t\t\tif (num2 \u003E 20f \u0026\u0026 fallDamageEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnPlayerLanded\u0022, this, num);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerAttack(BasePlayer getOwnerPlayer, HitInfo info)",
    "MethodSignature": "DoAttackShared(HitInfo info)",
    "MethodSourseCode": "\n\tpublic virtual void DoAttackShared(HitInfo info)\n\t{\n\t\tif (Interface.CallHook(\u0022OnPlayerAttack\u0022, GetOwnerPlayer(), info) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tGetAttackStats(info);\n\t\tif (info.HitEntity != null)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022OnAttacked\u0022, 50))\n\t\t\t{\n\t\t\t\tinfo.HitEntity.OnAttacked(info);\n\t\t\t}\n\t\t}\n\t\tif (info.DoHitEffects)\n\t\t{\n\t\t\tif (base.isServer)\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20))\n\t\t\t\t{\n\t\t\t\t\tEffect.server.ImpactEffect(info);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tusing (TimeWarning.New(\u0022ImpactEffect\u0022, 20))\n\t\t\t\t{\n\t\t\t\t\tEffect.client.ImpactEffect(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (base.isServer \u0026\u0026 !base.IsDestroyed)\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022UpdateItemCondition\u0022, 50))\n\t\t\t{\n\t\t\t\tUpdateItemCondition(info);\n\t\t\t}\n\t\t\tStartAttackCooldown(repeatDelay);\n\t\t}\n\t}\n",
    "ClassName": "BaseMelee",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnPlayerSetInfo(Network.Connection packetConnection, string itemName, string itemValue)",
    "MethodSignature": "ClientReady(Message packet)",
    "MethodSourseCode": "\n\tprivate void ClientReady(Message packet)\n\t{\n\t\tif (packet.connection.state != Network.Connection.State.Welcoming)\n\t\t{\n\t\t\tNetwork.Net.sv.Kick(packet.connection, \u0022Invalid connection state\u0022);\n\t\t\treturn;\n\t\t}\n\t\tusing (ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read))\n\t\t{\n\t\t\tforeach (ClientReady.ClientInfo item in clientReady.clientInfo)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerSetInfo\u0022, packet.connection, item.name, item.value);\n\t\t\t\tpacket.connection.info.Set(item.name, item.value);\n\t\t\t}\n\t\t\tconnectionQueue.JoinedGame(packet.connection);\n\t\t\tFacepunch.Rust.Analytics.Azure.OnPlayerConnected(packet.connection);\n\t\t\tusing (TimeWarning.New(\u0022ClientReady\u0022))\n\t\t\t{\n\t\t\t\tBasePlayer basePlayer;\n\t\t\t\tusing (TimeWarning.New(\u0022SpawnPlayerSleeping\u0022))\n\t\t\t\t{\n\t\t\t\t\tbasePlayer = SpawnPlayerSleeping(packet.connection);\n\t\t\t\t}\n\t\t\t\tif (basePlayer == null)\n\t\t\t\t{\n\t\t\t\t\tusing (TimeWarning.New(\u0022SpawnNewPlayer\u0022))\n\t\t\t\t\t{\n\t\t\t\t\t\tbasePlayer = SpawnNewPlayer(packet.connection);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (basePlayer != null)\n\t\t\t\t{\n\t\t\t\t\tUtil.SendSignedInNotification(basePlayer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSendReplicatedVars(packet.connection);\n\t}\n",
    "ClassName": "ServerMgr",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "CanUnlock(BasePlayer player, ModularCarCodeLock modularCarCodeLock, string codeEntered)",
    "MethodSignature": "TryOpenWithCode(BasePlayer player, string codeEntered)",
    "MethodSourseCode": "\n\tpublic bool TryOpenWithCode(BasePlayer player, string codeEntered)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanUnlock\u0022, player, this, codeEntered);\n\t\tif (obj is bool)\n\t\t{\n\t\t\treturn (bool)obj;\n\t\t}\n\t\tif (CodeEntryBlocked(player))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tif (!(codeEntered == Code))\n\t\t{\n\t\t\tif (Time.realtimeSinceStartup \u003E lastWrongTime \u002B 60f)\n\t\t\t{\n\t\t\t\twrongCodes = 0;\n\t\t\t}\n\t\t\tplayer.Hurt((float)(wrongCodes \u002B 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);\n\t\t\twrongCodes\u002B\u002B;\n\t\t\tif (wrongCodes \u003E 5)\n\t\t\t{\n\t\t\t\tplayer.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning);\n\t\t\t}\n\t\t\tif ((float)wrongCodes \u003E= CodeLock.maxFailedAttempts)\n\t\t\t{\n\t\t\t\towner.SetFlag(BaseEntity.Flags.Reserved10, b: true);\n\t\t\t\towner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);\n\t\t\t}\n\t\t\tlastWrongTime = Time.realtimeSinceStartup;\n\t\t\treturn false;\n\t\t}\n\t\tif (!WhitelistPlayers.Contains(player.userID))\n\t\t{\n\t\t\tWhitelistPlayers.Add(player.userID);\n\t\t\twrongCodes = 0;\n\t\t}\n\t\towner.SendNetworkUpdate();\n\t\treturn true;\n\t}\n",
    "ClassName": "ModularCarCodeLock",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnEntityLeave(TriggerBase triggerBase, BaseEntity ent)",
    "MethodSignature": "OnEntityLeave(BaseEntity ent)",
    "MethodSourseCode": "\n\tpublic virtual void OnEntityLeave(BaseEntity ent)\n\t{\n\t\tif (entityContents != null \u0026\u0026 Interface.CallHook(\u0022OnEntityLeave\u0022, this, ent) == null)\n\t\t{\n\t\t\tentityContents.Remove(ent);\n\t\t}\n\t}\n",
    "ClassName": "TriggerBase",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnSamSiteTarget(SamSite samSite, SamSite.ISamSiteTarget item)",
    "MethodSignature": "TargetScan()",
    "MethodSourseCode": "\n\tpublic void TargetScan()\n\t{\n\t\tif (!IsPowered())\n\t\t{\n\t\t\tlastTargetVisibleTime = 0f;\n\t\t\treturn;\n\t\t}\n\t\tif (UnityEngine.Time.time \u003E lastTargetVisibleTime \u002B 3f)\n\t\t{\n\t\t\tClearTarget();\n\t\t}\n\t\tif (!staticRespawn)\n\t\t{\n\t\t\tint num = ((ammoItem != null \u0026\u0026 ammoItem.parent == base.inventory) ? ammoItem.amount : 0);\n\t\t\tbool flag = lastAmmoCount \u003C lowAmmoThreshold;\n\t\t\tbool flag2 = num \u003C lowAmmoThreshold;\n\t\t\tif (num != lastAmmoCount \u0026\u0026 flag != flag2)\n\t\t\t{\n\t\t\t\tMarkIODirty();\n\t\t\t}\n\t\t\tlastAmmoCount = num;\n\t\t}\n\t\tif (HasValidTarget() || IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tList\u003CISamSiteTarget\u003E obj = Facepunch.Pool.GetList\u003CISamSiteTarget\u003E();\n\t\tif (Interface.CallHook(\u0022OnSamSiteTargetScan\u0022, this, obj) == null)\n\t\t{\n\t\t\tif (!IsInDefenderMode())\n\t\t\t{\n\t\t\t\tAddTargetSet(obj, 32768, targetTypeVehicle.scanRadius);\n\t\t\t}\n\t\t\tAddTargetSet(obj, 1048576, targetTypeMissile.scanRadius);\n\t\t}\n\t\tISamSiteTarget samSiteTarget = null;\n\t\tforeach (ISamSiteTarget item in obj)\n\t\t{\n\t\t\tif (!item.isClient \u0026\u0026 !(item.CenterPoint().y \u003C eyePoint.transform.position.y) \u0026\u0026 item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) \u0026\u0026 item.IsValidSAMTarget(staticRespawn) \u0026\u0026 Interface.CallHook(\u0022OnSamSiteTarget\u0022, this, item) == null)\n\t\t\t{\n\t\t\t\tsamSiteTarget = item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ObjectEx.IsUnityNull(samSiteTarget) \u0026\u0026 currentTarget != samSiteTarget)\n\t\t{\n\t\t\tlockOnTime = UnityEngine.Time.time \u002B 0.5f;\n\t\t}\n\t\tSetTarget(samSiteTarget);\n\t\tif (!ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tlastTargetVisibleTime = UnityEngine.Time.time;\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj);\n\t\tif (ObjectEx.IsUnityNull(currentTarget))\n\t\t{\n\t\t\tCancelInvoke(WeaponTick);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);\n\t\t}\n\t\tvoid AddTargetSet(List\u003CISamSiteTarget\u003E allTargets, int layerMask, float scanRadius)\n\t\t{\n\t\t\tList\u003CISamSiteTarget\u003E obj2 = Facepunch.Pool.GetList\u003CISamSiteTarget\u003E();\n\t\t\tVis.Entities(eyePoint.transform.position, scanRadius, obj2, layerMask, QueryTriggerInteraction.Ignore);\n\t\t\tallTargets.AddRange(obj2);\n\t\t\tFacepunch.Pool.FreeList(ref obj2);\n\t\t}\n\t}\n",
    "ClassName": "SamSite",
    "HookLineInvoke": 39
  },
  {
    "HookSignature": "OnDefaultItemsReceive(PlayerInventory playerInventory)",
    "MethodSignature": "GiveDefaultItems()",
    "MethodSourseCode": "\n\tpublic void GiveDefaultItems()\n\t{\n\t\tif (Interface.CallHook(\u0022OnDefaultItemsReceive\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tStrip();\n\t\tBaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);\n\t\tif (activeGameMode != null \u0026\u0026 activeGameMode.HasLoadouts())\n\t\t{\n\t\t\tBaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);\n\t\t\treturn;\n\t\t}\n\t\tGiveDefaultItemWithSkin(\u0022client.rockskin\u0022, \u0022rock\u0022);\n\t\tGiveDefaultItemWithSkin(\u0022client.torchskin\u0022, \u0022torch\u0022);\n\t\tif (IsBirthday())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022cakefiveyear\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022partyhat\u0022, 1, 0uL), containerWear);\n\t\t}\n\t\tif (IsChristmas())\n\t\t{\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t\tGiveItem(ItemManager.CreateByName(\u0022snowball\u0022, 1, 0uL), containerBelt);\n\t\t}\n\t\tInterface.CallHook(\u0022OnDefaultItemsReceived\u0022, this);\n\t\tvoid GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)\n\t\t{\n\t\t\tulong num = 0uL;\n\t\t\tint infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);\n\t\t\tbool flag = false;\n\t\t\tbool flag2 = false;\n\t\t\tflag2 = base.baseEntity?.UnlockAllSkins ?? false;\n\t\t\tif (infoInt \u003E 0 \u0026\u0026 (base.baseEntity.blueprints.steamInventory.HasItem(infoInt) || flag2))\n\t\t\t{\n\t\t\t\tItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);\n\t\t\t\tif (itemDefinition != null \u0026\u0026 ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)\n\t\t\t\t{\n\t\t\t\t\tIPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);\n\t\t\t\t\tif (itemDefinition2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum = itemDefinition2.WorkshopDownload;\n\t\t\t\t\t}\n\t\t\t\t\tif (num == 0L \u0026\u0026 itemDefinition.skins != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tItemSkinDirectory.Skin[] skins = itemDefinition.skins;\n\t\t\t\t\t\tfor (int i = 0; i \u003C skins.Length; i\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tItemSkinDirectory.Skin skin = skins[i];\n\t\t\t\t\t\t\tif (skin.id == infoInt \u0026\u0026 skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin \u0026\u0026 itemSkin.Redirect != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tGiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWeaponFired(BaseProjectile baseProjectile, BasePlayer msgPlayer, ItemModProjectile component, ProtoBuf.ProjectileShoot projectileShoot)",
    "MethodSignature": "CLProject(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\t[RPC_Server.IsActiveItem]\n\tprivate void CLProject(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientAttack(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treturn;\n\t\t}\n\t\tif (reloadFinished \u0026\u0026 HasReloadCooldown())\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Reloading (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022reload_cooldown\u0022);\n\t\t\treturn;\n\t\t}\n\t\treloadStarted = false;\n\t\treloadFinished = false;\n\t\tif (primaryMagazine.contents \u003C= 0 \u0026\u0026 !UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Magazine empty (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022ammo_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;\n\t\tProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);\n\t\tif (primaryMagazineAmmo.itemid != projectileShoot.ammoType)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Ammo mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022ammo_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (!UsingInfiniteAmmoCheat)\n\t\t{\n\t\t\tprimaryMagazine.contents--;\n\t\t}\n\t\tItemModProjectile component = primaryMagazineAmmo.GetComponent\u003CItemModProjectile\u003E();\n\t\tif (component == null)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Item mod not found (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022mod_missing\u0022);\n\t\t\treturn;\n\t\t}\n\t\tif (projectileShoot.projectiles.Count \u003E component.numProjectiles)\n\t\t{\n\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Count mismatch (\u0022 \u002B base.ShortPrefabName \u002B \u0022)\u0022);\n\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022count_mismatch\u0022);\n\t\t\treturn;\n\t\t}\n\t\tInterface.CallHook(\u0022OnWeaponFired\u0022, this, msg.player, component, projectileShoot);\n\t\tif (player.InGesture)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tSignalBroadcast(Signal.Attack, string.Empty, msg.connection);\n\t\tplayer.CleanupExpiredProjectiles();\n\t\tGuid projectileGroupId = Guid.NewGuid();\n\t\tforeach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)\n\t\t{\n\t\t\tif (player.HasFiredProjectile(projectile.projectileID))\n\t\t\t{\n\t\t\t\tAntiHack.Log(player, AntiHackType.ProjectileHack, \u0022Duplicate ID (\u0022 \u002B projectile.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \u0022duplicate_id\u0022);\n\t\t\t}\n\t\t\telse if (ValidateEyePos(player, projectile.startPos))\n\t\t\t{\n\t\t\t\tplayer.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId);\n\t\t\t\tif (!player.limitNetworking)\n\t\t\t\t{\n\t\t\t\t\tCreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tplayer.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);\n\t\tplayer.stats.Add(component.category \u002B \u0022_fired\u0022, projectileShoot.projectiles.Count(), (Stats)5);\n\t\tplayer.LifeStoryShotFired(this);\n\t\tStartAttackCooldown(ScaleRepeatDelay(repeatDelay) \u002B animationDelay);\n\t\tplayer.MarkHostileFor();\n\t\tUpdateItemCondition();\n\t\tDidAttackServerside();\n\t\tfloat num = 0f;\n\t\tif (component.projectileObject != null)\n\t\t{\n\t\t\tGameObject gameObject = component.projectileObject.Get();\n\t\t\tif (gameObject != null)\n\t\t\t{\n\t\t\t\tProjectile component2 = gameObject.GetComponent\u003CProjectile\u003E();\n\t\t\t\tif (component2 != null)\n\t\t\t\t{\n\t\t\t\t\tforeach (DamageTypeEntry damageType in component2.damageTypes)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum \u002B= damageType.amount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfloat num2 = NoiseRadius;\n\t\tif (IsSilenced())\n\t\t{\n\t\t\tnum2 *= AI.npc_gun_noise_silencer_modifier;\n\t\t}\n\t\tSensation sensation = default(Sensation);\n\t\tsensation.Type = SensationType.Gunshot;\n\t\tsensation.Position = player.transform.position;\n\t\tsensation.Radius = num2;\n\t\tsensation.DamagePotential = num;\n\t\tsensation.InitiatorPlayer = player;\n\t\tsensation.Initiator = player;\n\t\tSense.Stimulate(sensation);\n\t\tEACServer.LogPlayerUseWeapon(player, this);\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 51
  },
  {
    "HookSignature": "OnNpcConversationEnded(NPCTalking nPCTalking, BasePlayer player)",
    "MethodSignature": "ForceEndConversation(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void ForceEndConversation(BasePlayer player)\n\t{\n\t\tClientRPCPlayer(null, player, \u0022Client_EndConversation\u0022);\n\t\tInterface.CallHook(\u0022OnNpcConversationEnded\u0022, this, player);\n\t}\n",
    "ClassName": "NPCTalking",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "CanRenameBed(BasePlayer msgPlayer, SleepingBag sleepingBag, string text)",
    "MethodSignature": "Rename(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void Rename(RPCMessage msg)\n\t{\n\t\tif (!msg.player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = msg.read.String();\n\t\tif (Interface.CallHook(\u0022CanRenameBed\u0022, msg.player, this, text) == null)\n\t\t{\n\t\t\ttext = WordFilter.Filter(text);\n\t\t\tif (string.IsNullOrEmpty(text))\n\t\t\t{\n\t\t\t\ttext = \u0022Unnamed Sleeping Bag\u0022;\n\t\t\t}\n\t\t\tif (text.Length \u003E 24)\n\t\t\t{\n\t\t\t\ttext = text.Substring(0, 22) \u002B \u0022..\u0022;\n\t\t\t}\n\t\t\tniceName = text;\n\t\t\tSendNetworkUpdate();\n\t\t}\n\t}\n",
    "ClassName": "SleepingBag",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap itemModUnwrap)",
    "MethodSignature": "ServerCommand(Item item, string command, BasePlayer player)",
    "MethodSourseCode": "\n\tpublic override void ServerCommand(Item item, string command, BasePlayer player)\n\t{\n\t\tif (command == \u0022unwrap\u0022 \u0026\u0026 item.amount \u003E 0 \u0026\u0026 Interface.CallHook(\u0022OnItemUnwrap\u0022, item, player, this) == null)\n\t\t{\n\t\t\titem.UseItem();\n\t\t\tint num = UnityEngine.Random.Range(minTries, maxTries \u002B 1);\n\t\t\tfor (int i = 0; i \u003C num; i\u002B\u002B)\n\t\t\t{\n\t\t\t\trevealList.SpawnIntoContainer(player.inventory.containerMain);\n\t\t\t}\n\t\t\tif (successEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(successEffect.resourcePath, player.eyes.position);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "ItemModUnwrap",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnVehicleModuleDeselected(ModularCarGarage modularCarGarage, BasePlayer player)",
    "MethodSignature": "RPC_DeselectedLootItem(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_DeselectedLootItem(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (player.inventory.loot.IsLooting() \u0026\u0026 !(player.inventory.loot.entitySource != this))\n\t\t{\n\t\t\tif (player.inventory.loot.RemoveContainerAt(3))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t}\n\t\t\tInterface.CallHook(\u0022OnVehicleModuleDeselected\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "ModularCarGarage",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnConnectionDequeue(Network.Connection connection)",
    "MethodSignature": "RemoveConnection(Connection connection)",
    "MethodSourseCode": "\n\tpublic void RemoveConnection(Connection connection)\n\t{\n\t\tif (Interface.CallHook(\u0022OnConnectionDequeue\u0022, connection) == null)\n\t\t{\n\t\t\tif (queue.Remove(connection))\n\t\t\t{\n\t\t\t\tnextMessageTime = 0f;\n\t\t\t}\n\t\t\tjoining.Remove(connection);\n\t\t}\n\t}\n",
    "ClassName": "ConnectionQueue",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)",
    "MethodSignature": "CreateFromPosition(Vector3 pos)",
    "MethodSourseCode": "\n\tpublic ResourceDeposit CreateFromPosition(Vector3 pos)\n\t{\n\t\tVector2i indexFrom = GetIndexFrom(pos);\n\t\tUnityEngine.Random.State state = UnityEngine.Random.state;\n\t\tUnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed \u002B World.Salt));\n\t\tResourceDeposit resourceDeposit = new ResourceDeposit\n\t\t{\n\t\t\torigin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)\n\t\t};\n\t\tif (UnityEngine.Random.Range(0f, 1f) \u003C 0.5f)\n\t\t{\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);\n\t\t}\n\t\telse if (0 == 0)\n\t\t{\n\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022stones\u0022), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\tfloat num = 0f;\n\t\t\tnum = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) \u003E 0.5f) ? 1f : 0f) * 0.25f));\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022metal.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t\tfloat num2 = 0f;\n\t\t\tnum2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) \u003E 0.5f) ? 1f : 0f) * (0.25f \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) \u002B 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num2)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022sulfur.ore\u0022), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t\tfloat num3 = 0f;\n\t\t\tif (World.Procedural)\n\t\t\t{\n\t\t\t\tif (TerrainMeta.BiomeMap.GetBiome(pos, 8) \u003E 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) \u003E 0.5f)\n\t\t\t\t{\n\t\t\t\t\tnum3 \u002B= 0.25f;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnum3 \u002B= 0.15f;\n\t\t\t}\n\t\t\tif (UnityEngine.Random.Range(0f, 1f) \u003E= 1f - num3)\n\t\t\t{\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\u0022hq.metal.ore\u0022), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);\n\t\t\t}\n\t\t}\n\t\t_deposits.Add(indexFrom, resourceDeposit);\n\t\tInterface.CallHook(\u0022OnResourceDepositCreated\u0022, resourceDeposit);\n\t\tUnityEngine.Random.state = state;\n\t\treturn resourceDeposit;\n\t}\n",
    "ClassName": "ResourceDepositManager",
    "HookLineInvoke": 47
  },
  {
    "HookSignature": "ICanPickupEntity(BasePlayer rpcPlayer, DoorCloser doorCloser)",
    "MethodSignature": "RPC_Take(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.MaxDistance(3f)]\n\tpublic void RPC_Take(RPCMessage rpc)\n\t{\n\t\tif (Interface.CallHook(\u0022ICanPickupEntity\u0022, rpc.player, this) != null || !rpc.player.CanInteract() || !rpc.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tDoor door = GetDoor();\n\t\tif (!(door == null) \u0026\u0026 door.GetPlayerLockPermission(rpc.player))\n\t\t{\n\t\t\tItem item = ItemManager.Create(itemType, 1, skinID);\n\t\t\tif (item != null)\n\t\t\t{\n\t\t\t\trpc.player.GiveItem(item);\n\t\t\t}\n\t\t\tKill();\n\t\t}\n\t}\n",
    "ClassName": "DoorCloser",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnExperimentEnded(Workbench workbench)",
    "MethodSignature": "ExperimentComplete()",
    "MethodSourseCode": "\n\tpublic void ExperimentComplete()\n\t{\n\t\tItem experimentResourceItem = GetExperimentResourceItem();\n\t\tint scrapForExperiment = GetScrapForExperiment();\n\t\tif (pendingBlueprint == null)\n\t\t{\n\t\t\tDebug.LogWarning(\u0022Pending blueprint was null!\u0022);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnExperimentEnd\u0022, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (experimentResourceItem != null \u0026\u0026 experimentResourceItem.amount \u003E= scrapForExperiment \u0026\u0026 pendingBlueprint != null)\n\t\t{\n\t\t\texperimentResourceItem.UseItem(scrapForExperiment);\n\t\t\tItem item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);\n\t\t\titem.blueprintTarget = pendingBlueprint.itemid;\n\t\t\tcreatingBlueprint = true;\n\t\t\tif (!item.MoveToContainer(base.inventory, 0))\n\t\t\t{\n\t\t\t\titem.Drop(GetDropPosition(), GetDropVelocity());\n\t\t\t}\n\t\t\tcreatingBlueprint = false;\n\t\t\tif (experimentSuccessEffect.isValid)\n\t\t\t{\n\t\t\t\tEffect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);\n\t\t\t}\n\t\t}\n\t\tSetFlag(Flags.On, b: false);\n\t\tpendingBlueprint = null;\n\t\tbase.inventory.SetLocked(isLocked: false);\n\t\tSendNetworkUpdate();\n\t\tInterface.CallHook(\u0022OnExperimentEnded\u0022, this);\n\t}\n",
    "ClassName": "Workbench",
    "HookLineInvoke": 33
  },
  {
    "HookSignature": "OnProjectileRicochet(BasePlayer basePlayer, ProtoBuf.PlayerProjectileRicochet playerProjectileRicochet)",
    "MethodSignature": "OnProjectileRicochet(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.FromOwner]\n\tpublic void OnProjectileRicochet(RPCMessage msg)\n\t{\n\t\tPlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);\n\t\tif (playerProjectileRicochet != null)\n\t\t{\n\t\t\tFiredProjectile value;\n\t\t\tif (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Contains NaN (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Missing ID (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (value.firedTime \u003C UnityEngine.Time.realtimeSinceStartup - 8f)\n\t\t\t{\n\t\t\t\tAntiHack.Log(this, AntiHackType.ProjectileHack, \u0022Lifetime is zero (\u0022 \u002B playerProjectileRicochet.projectileID \u002B \u0022)\u0022);\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t\telse if (Interface.CallHook(\u0022OnProjectileRicochet\u0022, this, playerProjectileRicochet) == null)\n\t\t\t{\n\t\t\t\tvalue.ricochets\u002B\u002B;\n\t\t\t\tfiredProjectiles[playerProjectileRicochet.projectileID] = value;\n\t\t\t\tplayerProjectileRicochet.ResetToPool();\n\t\t\t\tplayerProjectileRicochet = null;\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 27
  },
  {
    "HookSignature": "OnSignalBroadcast(BaseEntity baseEntity)",
    "MethodSignature": "SignalBroadcast(Signal signal, string arg, Connection sourceConnection)",
    "MethodSourseCode": "\n\tpublic void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)\n\t{\n\t\tif (net != null \u0026\u0026 net.group != null \u0026\u0026 !base.limitNetworking \u0026\u0026 Interface.CallHook(\u0022OnSignalBroadcast\u0022, this) == null)\n\t\t{\n\t\t\tClientRPCEx(new SendInfo(net.group.subscribers)\n\t\t\t{\n\t\t\t\tmethod = SendMethod.Unreliable,\n\t\t\t\tpriority = Priority.Immediate\n\t\t\t}, sourceConnection, \u0022SignalFromServerEx\u0022, (int)signal, arg);\n\t\t}\n\t}\n",
    "ClassName": "BaseEntity",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnStashExposed(StashContainer stashContainer, BasePlayer player)",
    "MethodSignature": "RPC_WantsUnhide(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tpublic void RPC_WantsUnhide(RPCMessage rpc)\n\t{\n\t\tif (IsHidden())\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif (PlayerInRange(player) \u0026\u0026 Interface.CallHook(\u0022CanSeeStash\u0022, player, this) == null)\n\t\t\t{\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);\n\t\t\t\tSetHidden(isHidden: false);\n\t\t\t\tInterface.CallHook(\u0022OnStashExposed\u0022, this, player);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "StashContainer",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnPlayerWantsMount(BaseVehicle baseVehicle, BaseMountable baseMountable)",
    "MethodSignature": "WantsMount(BasePlayer player)",
    "MethodSourseCode": "\n\tpublic void WantsMount(BasePlayer player)\n\t{\n\t\tif (!player.IsValid() || !player.CanInteract())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = default(BaseVehicle);\n\t\tif (!DirectlyMountable())\n\t\t{\n\t\t\tbaseVehicle = VehicleParent();\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.WantsMount(player);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerWantsMount\u0022, baseVehicle, this) == null)\n\t\t{\n\t\t\tAttemptMount(player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnEntityReskin(BaseEntity baseEntity2, ItemSkinDirectory.Skin skin, BasePlayer msgPlayer)",
    "MethodSignature": "ChangeItemSkin(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void ChangeItemSkin(RPCMessage msg)\n\t{\n\t\tif (IsBusy())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tNetworkableId uid = msg.read.EntityID();\n\t\tBaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);\n\t\tint targetSkin = msg.read.Int32();\n\t\tif (msg.player == null || !msg.player.CanBuild())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tbool flag = false;\n\t\tif (msg.player.UnlockAllSkins)\n\t\t{\n\t\t\tflag = true;\n\t\t}\n\t\tif (targetSkin != 0 \u0026\u0026 !flag \u0026\u0026 !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))\n\t\t{\n\t\t\tSprayFailResponse(SprayFailReason.SkinNotOwned);\n\t\t\treturn;\n\t\t}\n\t\tif (baseNetworkable != null \u0026\u0026 baseNetworkable is BaseEntity baseEntity2)\n\t\t{\n\t\t\tVector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);\n\t\t\tif (!msg.player.IsVisible(position, 3f))\n\t\t\t{\n\t\t\t\tSprayFailResponse(SprayFailReason.LineOfSight);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (baseNetworkable is Door door)\n\t\t\t{\n\t\t\t\tif (!door.GetPlayerLockPermission(msg.player))\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022Door must be openable\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (door.IsOpen())\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022Door must be closed\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!GetItemDefinitionForEntity(baseEntity2, out var def))\n\t\t\t{\n\t\t\t\tSprayFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tItemDefinition itemDefinition = null;\n\t\t\tulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);\n\t\t\tItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) =\u003E x.id == targetSkin);\n\t\t\tif (Interface.CallHook(\u0022OnEntityReskin\u0022, baseEntity2, skin, msg.player) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (skin.invItem != null \u0026\u0026 skin.invItem is ItemSkin itemSkin)\n\t\t\t{\n\t\t\t\tif (itemSkin.Redirect != null)\n\t\t\t\t{\n\t\t\t\t\titemDefinition = itemSkin.Redirect;\n\t\t\t\t}\n\t\t\t\telse if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) \u0026\u0026 def.isRedirectOf != null)\n\t\t\t\t{\n\t\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) \u0026\u0026 def.isRedirectOf != null))\n\t\t\t{\n\t\t\t\titemDefinition = def.isRedirectOf;\n\t\t\t}\n\t\t\tif (itemDefinition == null)\n\t\t\t{\n\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\tbaseEntity2.SendNetworkUpdate();\n\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!CanEntityBeRespawned(baseEntity2, out var reason2))\n\t\t\t\t{\n\t\t\t\t\tSprayFailResponse(reason2);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!GetEntityPrefabPath(itemDefinition, out var resourcePath))\n\t\t\t\t{\n\t\t\t\t\tDebug.LogWarning(\u0022Cannot find resource path of redirect entity to spawn! \u0022 \u002B itemDefinition.gameObject.name);\n\t\t\t\t\tSprayFailResponse(SprayFailReason.InvalidItem);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tVector3 position2 = baseEntity2.transform.position;\n\t\t\t\tQuaternion rotation = baseEntity2.transform.rotation;\n\t\t\t\tBaseEntity entity = baseEntity2.GetParentEntity();\n\t\t\t\tfloat health = baseEntity2.Health();\n\t\t\t\tEntityRef[] slots = baseEntity2.GetSlots();\n\t\t\t\tfloat lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);\n\t\t\t\tbool flag2 = baseEntity2 is Door;\n\t\t\t\tDictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary2 = new Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E();\n\t\t\t\tSaveEntityStorage(baseEntity2, dictionary2, 0);\n\t\t\t\tList\u003CChildPreserveInfo\u003E obj = Facepunch.Pool.GetList\u003CChildPreserveInfo\u003E();\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tforeach (BaseEntity child in baseEntity2.children)\n\t\t\t\t\t{\n\t\t\t\t\t\tobj.Add(new ChildPreserveInfo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTargetEntity = child,\n\t\t\t\t\t\t\tTargetBone = child.parentBone,\n\t\t\t\t\t\t\tLocalPosition = child.transform.localPosition,\n\t\t\t\t\t\t\tLocalRotation = child.transform.localRotation\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tforeach (ChildPreserveInfo item in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\titem.TargetEntity.SetParent(null, worldPositionStays: true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i \u003C baseEntity2.children.Count; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tSaveEntityStorage(baseEntity2.children[i], dictionary2, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbaseEntity2.Kill();\n\t\t\t\tbaseEntity2 = GameManager.server.CreateEntity(resourcePath, position2, rotation);\n\t\t\t\tbaseEntity2.SetParent(entity);\n\t\t\t\tif (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) \u0026\u0026 def2.isRedirectOf != null)\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = 0uL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseEntity2.skinID = num;\n\t\t\t\t}\n\t\t\t\tif (baseEntity2 is DecayEntity decayEntity)\n\t\t\t\t{\n\t\t\t\t\tdecayEntity.AttachToBuilding(null);\n\t\t\t\t}\n\t\t\t\tbaseEntity2.Spawn();\n\t\t\t\tif (baseEntity2 is BaseCombatEntity baseCombatEntity2)\n\t\t\t\t{\n\t\t\t\t\tbaseCombatEntity2.SetHealth(health);\n\t\t\t\t\tbaseCombatEntity2.lastAttackedTime = lastAttackedTime;\n\t\t\t\t}\n\t\t\t\tif (dictionary2.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tRestoreEntityStorage(baseEntity2, 0, dictionary2);\n\t\t\t\t\tif (!flag2)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = 0; j \u003C baseEntity2.children.Count; j\u002B\u002B)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tforeach (KeyValuePair\u003CContainerSet, List\u003CItem\u003E\u003E item2 in dictionary2)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item3 in item2.Value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDebug.Log($\u0022Deleting {item3} as it has no new container\u0022);\n\t\t\t\t\t\t\titem3.Remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tFacepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);\n\t\t\t\t}\n\t\t\t\tif (flag2)\n\t\t\t\t{\n\t\t\t\t\tforeach (ChildPreserveInfo item4 in obj)\n\t\t\t\t\t{\n\t\t\t\t\t\titem4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);\n\t\t\t\t\t\titem4.TargetEntity.transform.localPosition = item4.LocalPosition;\n\t\t\t\t\t\titem4.TargetEntity.transform.localRotation = item4.LocalRotation;\n\t\t\t\t\t\titem4.TargetEntity.SendNetworkUpdate();\n\t\t\t\t\t}\n\t\t\t\t\tbaseEntity2.SetSlots(slots);\n\t\t\t\t}\n\t\t\t\tInterface.CallHook(\u0022OnEntityReskinned\u0022, baseEntity2, skin, msg.player);\n\t\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\t}\n\t\t\tClientRPC(null, \u0022Client_ReskinResult\u0022, 1, baseEntity2.net.ID);\n\t\t}\n\t\tLoseCondition(ConditionLossPerReskin);\n\t\tClientRPC(null, \u0022Client_ChangeSprayColour\u0022, -1);\n\t\tSetFlag(Flags.Busy, b: true);\n\t\tInvoke(ClearBusy, SprayCooldown);\n\t\tstatic void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E copy)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity)\n\t\t\t{\n\t\t\t\tContainerSet containerSet = default(ContainerSet);\n\t\t\t\tcontainerSet.ContainerIndex = index;\n\t\t\t\tcontainerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key = containerSet;\n\t\t\t\tif (copy.ContainsKey(key))\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item5 in copy[key])\n\t\t\t\t\t{\n\t\t\t\t\t\titem5.MoveToContainer(itemContainerEntity.inventory);\n\t\t\t\t\t}\n\t\t\t\t\tcopy.Remove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic void SaveEntityStorage(BaseEntity baseEntity, Dictionary\u003CContainerSet, List\u003CItem\u003E\u003E dictionary, int index)\n\t\t{\n\t\t\tif (baseEntity is IItemContainerEntity itemContainerEntity2)\n\t\t\t{\n\t\t\t\tContainerSet containerSet2 = default(ContainerSet);\n\t\t\t\tcontainerSet2.ContainerIndex = index;\n\t\t\t\tcontainerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);\n\t\t\t\tContainerSet key2 = containerSet2;\n\t\t\t\tif (!dictionary.ContainsKey(key2))\n\t\t\t\t{\n\t\t\t\t\tdictionary.Add(key2, new List\u003CItem\u003E());\n\t\t\t\t\tforeach (Item item6 in itemContainerEntity2.inventory.itemList)\n\t\t\t\t\t{\n\t\t\t\t\t\tdictionary[key2].Add(item6);\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (Item item7 in dictionary[key2])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titem7.RemoveFromContainer();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.Log(\u0022Multiple containers with the same prefab id being added during vehicle reskin\u0022);\n\t\t\t}\n\t\t}\n\t\tvoid SprayFailResponse(SprayFailReason reason)\n\t\t{\n\t\t\tClientRPC(null, \u0022Client_ReskinResult\u0022, 0, (int)reason);\n\t\t}\n\t}\n",
    "ClassName": "SprayCan",
    "HookLineInvoke": 55
  },
  {
    "HookSignature": "CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId itemContainerId, int num, int num2)",
    "MethodSignature": "MoveItem(BaseEntity.RPCMessage msg)",
    "MethodSourseCode": "\n\t[BaseEntity.RPC_Server]\n\t[BaseEntity.RPC_Server.FromOwner]\n\tpublic void MoveItem(BaseEntity.RPCMessage msg)\n\t{\n\t\tItemId itemId = msg.read.ItemID();\n\t\tItemContainerId itemContainerId = msg.read.ItemContainerID();\n\t\tint num = msg.read.Int8();\n\t\tint num2 = (int)msg.read.UInt32();\n\t\tbool flag = msg.read.Bit();\n\t\tItem item = FindItemUID(itemId);\n\t\tif (item == null)\n\t\t{\n\t\t\tmsg.player.ChatMessage(string.Concat(\u0022Invalid item (\u0022, itemId, \u0022)\u0022));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (Interface.CallHook(\u0022CanMoveItem\u0022, item, this, itemContainerId, num, num2) != null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tBaseEntity entityOwner = item.GetEntityOwner();\n\t\t\tif (!CanMoveItemsFrom(entityOwner, item))\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Cannot move item!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (num2 \u003C= 0)\n\t\t\t{\n\t\t\t\tnum2 = item.amount;\n\t\t\t}\n\t\t\tnum2 = Mathf.Clamp(num2, 1, item.MaxStackable());\n\t\t\tif (msg.player.GetActiveItem() == item)\n\t\t\t{\n\t\t\t\tmsg.player.UpdateActiveItem(default(ItemId));\n\t\t\t}\n\t\t\tif (!itemContainerId.IsValid)\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = entityOwner;\n\t\t\t\tif (loot.containers.Count \u003E 0)\n\t\t\t\t{\n\t\t\t\t\tif (entityOwner == base.baseEntity)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseEntity = loot.entitySource;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseEntity = base.baseEntity;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (baseEntity is IIdealSlotEntity idealSlotEntity)\n\t\t\t\t{\n\t\t\t\t\titemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, flag);\n\t\t\t\t}\n\t\t\t\tItemContainer parent = item.parent;\n\t\t\t\tif (parent != null \u0026\u0026 parent.IsLocked())\n\t\t\t\t{\n\t\t\t\t\tmsg.player.ChatMessage(\u0022Container is locked!\u0022);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!itemContainerId.IsValid)\n\t\t\t\t{\n\t\t\t\t\tif (baseEntity == loot.entitySource)\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach (ItemContainer container in loot.containers)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!container.PlayerItemInputBlocked() \u0026\u0026 !container.IsLocked() \u0026\u0026 item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!GiveItem(item, null, flag))\n\t\t\t\t\t{\n\t\t\t\t\t\tmsg.player.ChatMessage(\u0022GiveItem failed!\u0022);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tItemContainer itemContainer = FindContainer(itemContainerId);\n\t\t\tif (itemContainer == null)\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(string.Concat(\u0022Invalid container (\u0022, itemContainerId, \u0022)\u0022));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.IsLocked())\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Container is locked!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (itemContainer.PlayerItemInputBlocked())\n\t\t\t{\n\t\t\t\tmsg.player.ChatMessage(\u0022Container does not accept player items!\u0022);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tusing (TimeWarning.New(\u0022Split\u0022))\n\t\t\t{\n\t\t\t\tif (item.amount \u003E num2)\n\t\t\t\t{\n\t\t\t\t\tint split_Amount = num2;\n\t\t\t\t\tif (itemContainer.maxStackSize \u003E 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsplit_Amount = Mathf.Min(num2, itemContainer.maxStackSize);\n\t\t\t\t\t}\n\t\t\t\t\tItem item2 = item.SplitItem(split_Amount);\n\t\t\t\t\tif (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))\n\t\t\t\t\t{\n\t\t\t\t\t\titem.amount \u002B= item2.amount;\n\t\t\t\t\t\titem2.Remove();\n\t\t\t\t\t}\n\t\t\t\t\tItemManager.DoRemoves();\n\t\t\t\t\tServerUpdate(0f);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))\n\t\t\t{\n\t\t\t\tItemManager.DoRemoves();\n\t\t\t\tServerUpdate(0f);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "PlayerInventory",
    "HookLineInvoke": 17
  },
  {
    "HookSignature": "OnSensorDetect(HBHFSensor hBHFSensor, BasePlayer component)",
    "MethodSignature": "UpdatePassthroughAmount()",
    "MethodSourseCode": "\n\tpublic void UpdatePassthroughAmount()\n\t{\n\t\tif (base.isClient)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint num = detectedPlayers;\n\t\tdetectedPlayers = 0;\n\t\tif (myTrigger.entityContents != null)\n\t\t{\n\t\t\tforeach (BaseEntity entityContent in myTrigger.entityContents)\n\t\t\t{\n\t\t\t\tif (entityContent == null || !entityContent.IsVisible(base.transform.position \u002B base.transform.forward * 0.1f, 10f))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tBasePlayer component = entityContent.GetComponent\u003CBasePlayer\u003E();\n\t\t\t\tif (Interface.CallHook(\u0022OnSensorDetect\u0022, this, component) == null)\n\t\t\t\t{\n\t\t\t\t\tbool flag = component.CanBuild();\n\t\t\t\t\tif ((!flag || ShouldIncludeAuthorized()) \u0026\u0026 (flag || ShouldIncludeOthers()) \u0026\u0026 component != null \u0026\u0026 component.IsAlive() \u0026\u0026 !component.IsSleeping() \u0026\u0026 component.isServer)\n\t\t\t\t\t{\n\t\t\t\t\t\tdetectedPlayers\u002B\u002B;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (num != detectedPlayers \u0026\u0026 IsPowered())\n\t\t{\n\t\t\tMarkDirty();\n\t\t\tif (detectedPlayers \u003E num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t\telse if (detectedPlayers \u003C num)\n\t\t\t{\n\t\t\t\tEffect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "HBHFSensor",
    "HookLineInvoke": 18
  },
  {
    "HookSignature": "CanLootEntity(BasePlayer player, BaseRidableAnimal baseRidableAnimal)",
    "MethodSignature": "RPC_OpenLoot(RPCMessage rpc)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsVisible(3f)]\n\tprivate void RPC_OpenLoot(RPCMessage rpc)\n\t{\n\t\tif (inventory != null)\n\t\t{\n\t\t\tBasePlayer player = rpc.player;\n\t\t\tif ((bool)player \u0026\u0026 player.CanInteract() \u0026\u0026 CanOpenStorage(player) \u0026\u0026 (!needsBuildingPrivilegeToUse || player.CanBuild()) \u0026\u0026 Interface.CallHook(\u0022CanLootEntity\u0022, player, this) == null \u0026\u0026 player.inventory.loot.StartLootingEntity(this))\n\t\t\t{\n\t\t\t\tplayer.inventory.loot.AddContainer(inventory);\n\t\t\t\tplayer.inventory.loot.SendImmediate();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022RPC_OpenLootPanel\u0022, lootPanelName);\n\t\t\t\tSendNetworkUpdate();\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "BaseRidableAnimal",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnItemRepair(BasePlayer player, Item itemToRepair)",
    "MethodSignature": "RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)",
    "MethodSourseCode": "\n\tpublic static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)\n\t{\n\t\tif (itemToRepair == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tItemDefinition info = itemToRepair.info;\n\t\tItemBlueprint component = info.GetComponent\u003CItemBlueprint\u003E();\n\t\tif (!component || !info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (mustKnowBlueprint)\n\t\t{\n\t\t\tItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);\n\t\t\tif (!player.blueprints.HasUnlocked(itemDefinition) \u0026\u0026 (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnItemRepair\u0022, player, itemToRepair) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfloat num = RepairCostFraction(itemToRepair);\n\t\tbool flag = false;\n\t\tList\u003CItemAmount\u003E obj = Facepunch.Pool.GetList\u003CItemAmount\u003E();\n\t\tGetRepairCostList(component, obj);\n\t\tforeach (ItemAmount item in obj)\n\t\t{\n\t\t\tif (item.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount = player.inventory.GetAmount(item.itemDef.itemid);\n\t\t\t\tif (Mathf.CeilToInt(item.amount * num) \u003E amount)\n\t\t\t\t{\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\t\t{\n\t\t\tFacepunch.Pool.FreeList(ref obj);\n\t\t\treturn;\n\t\t}\n\t\tforeach (ItemAmount item2 in obj)\n\t\t{\n\t\t\tif (item2.itemDef.category != ItemCategory.Component)\n\t\t\t{\n\t\t\t\tint amount2 = Mathf.CeilToInt(item2.amount * num);\n\t\t\t\tplayer.inventory.Take(null, item2.itemid, amount2);\n\t\t\t\tFacepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, \u0022repair\u0022, item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);\n\t\t\t}\n\t\t}\n\t\tFacepunch.Pool.FreeList(ref obj);\n\t\tfloat conditionNormalized = itemToRepair.conditionNormalized;\n\t\tfloat maxConditionNormalized = itemToRepair.maxConditionNormalized;\n\t\titemToRepair.DoRepair(maxConditionLostOnRepair);\n\t\tFacepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);\n\t\tif (Global.developer \u003E 0)\n\t\t{\n\t\t\tDebug.Log(\u0022Item repaired! condition : \u0022 \u002B itemToRepair.condition \u002B \u0022/\u0022 \u002B itemToRepair.maxCondition);\n\t\t}\n\t\tEffect.server.Run(\u0022assets/bundled/prefabs/fx/repairbench/itemrepair.prefab\u0022, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);\n\t}\n",
    "ClassName": "RepairBench",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerInput(BasePlayer basePlayer, InputState serverInput)",
    "MethodSignature": "OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)",
    "MethodSourseCode": "\n\tprivate void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)\n\t{\n\t\tif (msg.inputState != null)\n\t\t{\n\t\t\tserverInput.Flip(msg.inputState);\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerTick\u0022, this, msg, wasPlayerStalled) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (serverInput.current.buttons != serverInput.previous.buttons)\n\t\t{\n\t\t\tResetInputIdleTime();\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnPlayerInput\u0022, this, serverInput) != null || IsReceivingSnapshot)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSpectating())\n\t\t{\n\t\t\tusing (TimeWarning.New(\u0022Tick_Spectator\u0022))\n\t\t\t{\n\t\t\t\tTick_Spectator();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (IsDead())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (IsSleeping())\n\t\t{\n\t\t\tif (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))\n\t\t\t{\n\t\t\t\tEndSleeping();\n\t\t\t\tSendNetworkUpdateImmediate();\n\t\t\t}\n\t\t\tUpdateActiveItem(default(ItemId));\n\t\t\treturn;\n\t\t}\n\t\tUpdateActiveItem(msg.activeItem);\n\t\tUpdateModelStateFromTick(msg);\n\t\tif (!IsIncapacitated())\n\t\t{\n\t\t\tif (isMounted)\n\t\t\t{\n\t\t\t\tGetMounted().PlayerServerInput(serverInput, this);\n\t\t\t}\n\t\t\tUpdatePositionFromTick(msg, wasPlayerStalled);\n\t\t\tUpdateRotationFromTick(msg);\n\t\t}\n\t}\n",
    "ClassName": "BasePlayer",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanDismountEntity(BasePlayer player, BaseMountable baseMountable)",
    "MethodSignature": "DismountPlayer(BasePlayer player, bool lite)",
    "MethodSourseCode": "\n\tpublic void DismountPlayer(BasePlayer player, bool lite = false)\n\t{\n\t\tif (_mounted == null || _mounted != player || Interface.CallHook(\u0022CanDismountEntity\u0022, player, this) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tBaseVehicle baseVehicle = VehicleParent();\n\t\tVector3 res;\n\t\tif (lite)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t}\n\t\telse if (!GetDismountPosition(player, out res) || Distance(res) \u003E 10f)\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\tres = player.transform.position;\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.ClientRPCPlayer(null, _mounted, \u0022ForcePositionTo\u0022, res);\n\t\t\tBasePlayer mounted = _mounted;\n\t\t\t_mounted = null;\n\t\t\tDebug.LogWarning(\u0022Killing player due to invalid dismount point :\u0022 \u002B player.displayName \u002B \u0022 / \u0022 \u002B player.userID \u002B \u0022 on obj : \u0022 \u002B base.gameObject.name);\n\t\t\tmounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PrePlayerDismount(player, this);\n\t\t\t}\n\t\t\t_mounted.DismountObject();\n\t\t\t_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);\n\t\t\t_mounted.MovePosition(res);\n\t\t\t_mounted.SendNetworkUpdateImmediate();\n\t\t\t_mounted.SendModelState(force: true);\n\t\t\t_mounted = null;\n\t\t\tif (baseVehicle != null)\n\t\t\t{\n\t\t\t\tbaseVehicle.PlayerDismounted(player, this);\n\t\t\t}\n\t\t\tplayer.ForceUpdateTriggers();\n\t\t\tif ((bool)player.GetParentEntity())\n\t\t\t{\n\t\t\t\tBaseEntity baseEntity = player.GetParentEntity();\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionToParentOffset\u0022, baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplayer.ClientRPCPlayer(null, player, \u0022ForcePositionTo\u0022, res);\n\t\t\t}\n\t\t\tOnPlayerDismounted(player);\n\t\t\tInterface.CallHook(\u0022OnEntityDismounted\u0022, this, player);\n\t\t}\n\t}\n",
    "ClassName": "BaseMountable",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnWeaponReload(BaseProjectile baseProjectile, BasePlayer player)",
    "MethodSignature": "StartReload(RPCMessage msg)",
    "MethodSourseCode": "\n\t[RPC_Server]\n\t[RPC_Server.IsActiveItem]\n\tprivate void StartReload(RPCMessage msg)\n\t{\n\t\tBasePlayer player = msg.player;\n\t\tif (!VerifyClientRPC(player))\n\t\t{\n\t\t\tSendNetworkUpdate();\n\t\t\treloadStarted = false;\n\t\t\treloadFinished = false;\n\t\t}\n\t\telse if (Interface.CallHook(\u0022OnWeaponReload\u0022, this, player) == null)\n\t\t{\n\t\t\treloadFinished = false;\n\t\t\treloadStarted = true;\n\t\t\tfractionalInsertCounter = 0;\n\t\t\tif (CanRefundAmmo)\n\t\t\t{\n\t\t\t\tprimaryMagazine.SwitchAmmoTypesIfNeeded(player);\n\t\t\t}\n\t\t\tStartReloadCooldown(GetReloadDuration());\n\t\t}\n\t}\n",
    "ClassName": "BaseProjectile",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnItemStacked(IItemContainerEntity itemContainerEntity, Item item, ItemContainer newcontainer)",
    "MethodSignature": "MoveToContainer(ItemContainer newcontainer, int iTargetPos, bool allowStack, bool ignoreStackLimit, BasePlayer sourcePlayer, bool allowSwap)",
    "MethodSourseCode": "\n\tpublic bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)\n\t{\n\t\tusing (TimeWarning.New(\u0022MoveToContainer\u0022))\n\t\t{\n\t\t\tbool flag = iTargetPos == -1;\n\t\t\tItemContainer itemContainer = parent;\n\t\t\tIItemContainerEntity itemContainerEntity = default(IItemContainerEntity);\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\tif (allowStack \u0026\u0026 info.stackable \u003E 1)\n\t\t\t\t{\n\t\t\t\t\tforeach (Item item2 in from x in newcontainer.FindItemsByItemID(info.itemid)\n\t\t\t\t\t\torderby x.position\n\t\t\t\t\t\tselect x)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (item2.CanStack(this) \u0026\u0026 (ignoreStackLimit || item2.amount \u003C item2.MaxStackable()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = item2.position;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\titemContainerEntity = newcontainer.GetEntityOwner(returnHeldEntity: true) as IItemContainerEntity;\n\t\t\t\t\tif (itemContainerEntity != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = itemContainerEntity.GetIdealSlot(sourcePlayer, this);\n\t\t\t\t\t\tif (iTargetPos == int.MinValue)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (iTargetPos == -1)\n\t\t\t\t{\n\t\t\t\t\tif (newcontainer == parent)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) \u0026\u0026 info.isWearable;\n\t\t\t\t\tItemModWearable itemModWearable = info.ItemModWearable;\n\t\t\t\t\tfor (int i = 0; i \u003C newcontainer.capacity; i\u002B\u002B)\n\t\t\t\t\t{\n\t\t\t\t\t\tItem slot = newcontainer.GetSlot(i);\n\t\t\t\t\t\tif (slot == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CanMoveTo(newcontainer, i))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag2 \u0026\u0026 slot != null \u0026\u0026 !slot.info.ItemModWearable.CanExistWith(itemModWearable))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newcontainer.availableSlots != null \u0026\u0026 newcontainer.availableSlots.Count \u003E 0 \u0026\u0026 DoItemSlotsConflict(slot))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tiTargetPos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2 \u0026\u0026 iTargetPos == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tiTargetPos = newcontainer.capacity - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iTargetPos == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!CanMoveTo(newcontainer, iTargetPos))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 newcontainer.SlotTaken(this, iTargetPos))\n\t\t\t{\n\t\t\t\tItem slot2 = newcontainer.GetSlot(iTargetPos);\n\t\t\t\tif (slot2 == this)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (allowStack \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tint num = slot2.MaxStackable();\n\t\t\t\t\tif (slot2.CanStack(this))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ignoreStackLimit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnum = int.MaxValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (slot2.amount \u003E= num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint num2 = Mathf.Min(num - slot2.amount, amount);\n\t\t\t\t\t\tslot2.amount \u002B= num2;\n\t\t\t\t\t\tamount -= num2;\n\t\t\t\t\t\tslot2.MarkDirty();\n\t\t\t\t\t\tMarkDirty();\n\t\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, slot2, this, newcontainer, num2);\n\t\t\t\t\t\tif (amount \u003C= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRemoveFromWorld();\n\t\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\t\tRemove();\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (parent != null \u0026\u0026 allowSwap \u0026\u0026 slot2 != null)\n\t\t\t\t{\n\t\t\t\t\tItemContainer itemContainer2 = parent;\n\t\t\t\t\tint iTargetPos2 = position;\n\t\t\t\t\tItemContainer itemContainer3 = slot2.parent;\n\t\t\t\t\tint num3 = slot2.position;\n\t\t\t\t\tif (!slot2.CanMoveTo(itemContainer2, iTargetPos2))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tBaseEntity entityOwner = GetEntityOwner();\n\t\t\t\t\tBaseEntity entityOwner2 = slot2.GetEntityOwner();\n\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\tRemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);\n\t\t\t\t\tslot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);\n\t\t\t\t\tif (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveFromContainer();\n\t\t\t\t\t\tslot2.RemoveFromContainer();\n\t\t\t\t\t\tSetParent(itemContainer2);\n\t\t\t\t\t\tposition = iTargetPos2;\n\t\t\t\t\t\tslot2.SetParent(itemContainer3);\n\t\t\t\t\t\tslot2.position = num3;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (parent == newcontainer)\n\t\t\t{\n\t\t\t\tif (iTargetPos \u003E= 0 \u0026\u0026 iTargetPos != position \u0026\u0026 !parent.SlotTaken(this, iTargetPos))\n\t\t\t\t{\n\t\t\t\t\tposition = iTargetPos;\n\t\t\t\t\tMarkDirty();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (newcontainer.maxStackSize \u003E 0 \u0026\u0026 newcontainer.maxStackSize \u003C amount)\n\t\t\t{\n\t\t\t\tItem item = SplitItem(newcontainer.maxStackSize);\n\t\t\t\tif (item != null \u0026\u0026 !item.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) \u0026\u0026 (itemContainer == null || !item.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))\n\t\t\t\t{\n\t\t\t\t\tVector3 dropPosition = newcontainer.dropPosition;\n\t\t\t\t\tVector3 dropVelocity = newcontainer.dropVelocity;\n\t\t\t\t\tInterface.CallHook(\u0022OnItemStacked\u0022, itemContainerEntity, this, newcontainer);\n\t\t\t\t\titem.Drop(dropPosition, dropVelocity);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!newcontainer.CanAccept(this))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tBaseEntity entityOwner3 = GetEntityOwner();\n\t\t\tRemoveFromContainer();\n\t\t\tRemoveFromWorld();\n\t\t\tRemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);\n\t\t\tposition = iTargetPos;\n\t\t\tSetParent(newcontainer);\n\t\t\treturn true;\n\t\t}\n\t}\n",
    "ClassName": "Item",
    "HookLineInvoke": 166
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "OnApplicationQuit()",
    "MethodSourseCode": "\n\tprivate void OnApplicationQuit()\n\t{\n\t\tif (!oxideMod.IsShuttingDown)\n\t\t{\n\t\t\tInterface.Call(\u0022OnServerShutdown\u0022);\n\t\t\tInterface.Oxide.OnShutdown();\n\t\t}\n\t}\n",
    "ClassName": "UnityScript",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnRconMessage(System.Net.IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)",
    "MethodSignature": "IOnRconMessage(IPAddress ipAddress, string command)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnRconMessage\u0022)]\n\tprivate object IOnRconMessage(IPAddress ipAddress, string command)\n\t{\n\t\tif (ipAddress != null \u0026\u0026 !string.IsNullOrEmpty(command))\n\t\t{\n\t\t\tRemoteMessage message = RemoteMessage.GetMessage(command);\n\t\t\tif (string.IsNullOrEmpty(message?.Message))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnRconMessage\u0022, ipAddress, message) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstring[] array = Oxide.Core.CommandLine.Split(message.Message);\n\t\t\tif (array.Length \u003E= 1)\n\t\t\t{\n\t\t\t\tstring obj = array[0].ToLower();\n\t\t\t\tstring[] obj2 = array.Skip(1).ToArray();\n\t\t\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, ipAddress, obj, obj2) != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(System.Environment.NewLine, \u0022 \u0022), System.Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 21
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 15
  },
  {
    "HookSignature": "CanPickupEntity(BasePlayer basePlayer, DoorCloser entity)",
    "MethodSignature": "ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022ICanPickupEntity\u0022)]\n\tprivate object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)\n\t{\n\t\tobject obj = Interface.CallHook(\u0022CanPickupEntity\u0022, basePlayer, entity);\n\t\tif (!(obj is bool) || (bool)obj)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnServerCommand(string argCmdFullName, string[] RustCommandSystemExtractArgs)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022 || arg.cmd.FullName == \u0022chat.localsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnRconCommand(System.Net.IPAddress ipAddress, string obj, string[] obj2)",
    "MethodSignature": "IOnRconMessage(IPAddress ipAddress, string command)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnRconMessage\u0022)]\n\tprivate object IOnRconMessage(IPAddress ipAddress, string command)\n\t{\n\t\tif (ipAddress != null \u0026\u0026 !string.IsNullOrEmpty(command))\n\t\t{\n\t\t\tRemoteMessage message = RemoteMessage.GetMessage(command);\n\t\t\tif (string.IsNullOrEmpty(message?.Message))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (Interface.CallHook(\u0022OnRconMessage\u0022, ipAddress, message) != null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstring[] array = Oxide.Core.CommandLine.Split(message.Message);\n\t\t\tif (array.Length \u003E= 1)\n\t\t\t{\n\t\t\t\tstring obj = array[0].ToLower();\n\t\t\t\tstring[] obj2 = array.Skip(1).ToArray();\n\t\t\t\tif (Interface.CallHook(\u0022OnRconCommand\u0022, ipAddress, obj, obj2) != null)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string reason)",
    "MethodSignature": "OnPlayerDisconnected(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerDisconnected\u0022)]\n\tprivate void OnPlayerDisconnected(BasePlayer basePlayer, string reason)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserDisconnected\u0022, iPlayer, reason);\n\t\t}\n\t\tCovalence.PlayerManager.PlayerDisconnected(basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "CanUseUI(BasePlayer player, string json)",
    "MethodSignature": "AddUi(BasePlayer player, string json)",
    "MethodSourseCode": "\n\tpublic static bool AddUi(BasePlayer player, string json)\n\t{\n\t\tif (player?.net != null \u0026\u0026 Interface.CallHook(\u0022CanUseUI\u0022, player, json) == null)\n\t\t{\n\t\t\tCommunityEntity.ServerInstance.ClientRPCEx(new SendInfo\n\t\t\t{\n\t\t\t\tconnection = player.net.connection\n\t\t\t}, null, \u0022AddUI\u0022, json);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 3
  },
  {
    "HookSignature": "OnServerInitialized(bool false)",
    "MethodSignature": "OnPluginLoaded(Plugin plugin)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPluginLoaded\u0022)]\n\tprivate void OnPluginLoaded(Plugin plugin)\n\t{\n\t\tif (serverInitialized)\n\t\t{\n\t\t\tplugin.CallHook(\u0022OnServerInitialized\u0022, false);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 11
  },
  {
    "HookSignature": "CanUserLogin(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 23
  },
  {
    "HookSignature": "OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string message)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnPlayerUnbanned(string player?Name ?? \u0022Unnamed\u0022, ulong steamId, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "OnServerUserRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserRemove\u0022)]\n\tprivate void OnServerUserRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnUserUnbanned(string player?Name ?? \u0022Unnamed\u0022, string text, string player?Address ?? \u00220\u0022)",
    "MethodSignature": "OnServerUserRemove(ulong steamId)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserRemove\u0022)]\n\tprivate void OnServerUserRemove(ulong steamId)\n\t{\n\t\tif (serverInitialized \u0026\u0026 ServerUsers.users.ContainsKey(steamId) \u0026\u0026 ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, steamId, player?.Address ?? \u00220\u0022);\n\t\t\tInterface.CallHook(\u0022OnUserUnbanned\u0022, player?.Name ?? \u0022Unnamed\u0022, text, player?.Address ?? \u00220\u0022);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnPlayerConnected(BasePlayer basePlayer)",
    "MethodSignature": "IOnPlayerConnected(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerConnected\u0022)]\n\tprivate void IOnPlayerConnected(BasePlayer basePlayer)\n\t{\n\t\tlang.SetLanguage(basePlayer.net.connection.info.GetString(\u0022global.language\u0022, \u0022en\u0022), basePlayer.UserIDString);\n\t\tbasePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);\n\t\tCovalence.PlayerManager.PlayerConnected(basePlayer);\n\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);\n\t\tif (player != null)\n\t\t{\n\t\t\tbasePlayer.IPlayer = player;\n\t\t\tInterface.CallHook(\u0022OnUserConnected\u0022, player);\n\t\t}\n\t\tInterface.Oxide.CallHook(\u0022OnPlayerConnected\u0022, basePlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 13
  },
  {
    "HookSignature": "OnUserApproved(string username, string text, string obj)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 31
  },
  {
    "HookSignature": "OnUserBanned(string playerName, string text, string player?Address ?? \u00220\u0022, string reason, long expiry)",
    "MethodSignature": "OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserSet\u0022)]\n\tprivate void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(System.Environment.NewLine, \u0022 \u0022), System.Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 25
  },
  {
    "HookSignature": "OnLoseCondition(object[] array)",
    "MethodSignature": "IOnLoseCondition(Item item, float amount)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnLoseCondition\u0022)]\n\tprivate object IOnLoseCondition(Item item, float amount)\n\t{\n\t\tobject[] array = new object[2] { item, amount };\n\t\tInterface.CallHook(\u0022OnLoseCondition\u0022, array);\n\t\tamount = (float)array[1];\n\t\tfloat condition = item.condition;\n\t\titem.condition -= amount;\n\t\tif (item.condition \u003C= 0f \u0026\u0026 item.condition \u003C condition)\n\t\t{\n\t\t\titem.OnBroken();\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSignature": "IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBaseCombatEntityHurt\u0022)]\n\tprivate object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)\n\t{\n\t\tif (!(entity is BasePlayer))\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnEntityTakeDamage\u0022, entity, hitInfo);\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerLanguageChanged(BasePlayer basePlayer, string val)",
    "MethodSignature": "OnPlayerSetInfo(Connection connection, string key, string val)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerSetInfo\u0022)]\n\tprivate void OnPlayerSetInfo(Connection connection, string key, string val)\n\t{\n\t\tif (!(key == \u0022global.language\u0022))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tlang.SetLanguage(val, connection.userid.ToString());\n\t\tBasePlayer basePlayer = connection.player as BasePlayer;\n\t\tif (basePlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer, val);\n\t\t\tif (basePlayer.IPlayer != null)\n\t\t\t{\n\t\t\t\tInterface.CallHook(\u0022OnPlayerLanguageChanged\u0022, basePlayer.IPlayer, val);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnServerInitialized(bool serverInitialized)",
    "MethodSignature": "IOnServerInitialized()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerInitialized\u0022)]\n\tprivate void IOnServerInitialized()\n\t{\n\t\tif (!serverInitialized)\n\t\t{\n\t\t\tAnalytics.Collect();\n\t\t\tif (!Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tInterface.Oxide.LogWarning(\u0022The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section\u0022);\n\t\t\t}\n\t\t\tserverInitialized = true;\n\t\t\tInterface.CallHook(\u0022OnServerInitialized\u0022, serverInitialized);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnMessagePlayer(string text, BasePlayer player, ulong userId)",
    "MethodSignature": "Message(BasePlayer player, string message, string prefix, ulong userId, object[] args)",
    "MethodSourseCode": "\n\tpublic void Message(BasePlayer player, string message, string prefix, ulong userId = 0uL, params object[] args)\n\t{\n\t\tif (!string.IsNullOrEmpty(message))\n\t\t{\n\t\t\tmessage = ((args.Length != 0) ? string.Format(Formatter.ToUnity(message), args) : Formatter.ToUnity(message));\n\t\t\tstring text = ((prefix != null) ? (prefix \u002B \u0022 \u0022 \u002B message) : message);\n\t\t\tif (Interface.CallHook(\u0022OnMessagePlayer\u0022, text, player, userId) == null)\n\t\t\t{\n\t\t\t\tplayer.SendConsoleCommand(\u0022chat.add\u0022, 2, userId, text);\n\t\t\t}\n\t\t}\n\t}\n",
    "ClassName": "Player",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawned(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawned\u0022)]\n\tprivate void OnPlayerRespawned(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserRespawned\u0022, iPlayer);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 7
  },
  {
    "HookSignature": "OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer basePlayerIPlayer, string reason)",
    "MethodSignature": "OnPlayerKicked(BasePlayer basePlayer, string reason)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerKicked\u0022)]\n\tprivate void OnPlayerKicked(BasePlayer basePlayer, string reason)\n\t{\n\t\tif (basePlayer.IPlayer != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnUserKicked\u0022, basePlayer.IPlayer, reason);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "CanClientLogin(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 22
  },
  {
    "HookSignature": "OnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSignature": "IOnServerCommand(ConsoleSystem.Arg arg)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerCommand\u0022)]\n\tprivate object IOnServerCommand(ConsoleSystem.Arg arg)\n\t{\n\t\tif (arg == null || (arg.Connection != null \u0026\u0026 arg.Player() == null))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (arg.cmd.FullName == \u0022chat.say\u0022 || arg.cmd.FullName == \u0022chat.teamsay\u0022 || arg.cmd.FullName == \u0022chat.localsay\u0022)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnServerCommand\u0022, arg);\n\t\tobject obj2 = Interface.CallHook(\u0022OnServerCommand\u0022, arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer iPlayer)",
    "MethodSignature": "OnPlayerRespawn(BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnPlayerRespawn\u0022)]\n\tprivate object OnPlayerRespawn(BasePlayer basePlayer)\n\t{\n\t\tIPlayer iPlayer = basePlayer.IPlayer;\n\t\tif (iPlayer == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn Interface.CallHook(\u0022OnUserRespawn\u0022, iPlayer);\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 9
  },
  {
    "HookSignature": "OnUserApprove(Network.Connection connection)",
    "MethodSignature": "IOnUserApprove(Connection connection)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnUserApprove\u0022)]\n\tprivate object IOnUserApprove(Connection connection)\n\t{\n\t\tstring username = connection.username;\n\t\tstring text = connection.userid.ToString();\n\t\tstring obj = Regex.Replace(connection.ipaddress, ipPattern, \u0022\u0022);\n\t\tuint authLevel = connection.authLevel;\n\t\tif (permission.IsLoaded)\n\t\t{\n\t\t\tpermission.UpdateNickname(text, username);\n\t\t\tOxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;\n\t\t\tif (!permission.UserHasGroup(text, defaultGroups.Players))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Players);\n\t\t\t}\n\t\t\tif (authLevel \u003E= 2 \u0026\u0026 !permission.UserHasGroup(text, defaultGroups.Administrators))\n\t\t\t{\n\t\t\t\tpermission.AddUserGroup(text, defaultGroups.Administrators);\n\t\t\t}\n\t\t}\n\t\tCovalence.PlayerManager.PlayerJoin(connection.userid, username);\n\t\tobject obj2 = Interface.CallHook(\u0022CanClientLogin\u0022, connection);\n\t\tobject obj3 = Interface.CallHook(\u0022CanUserLogin\u0022, username, text, obj);\n\t\tobject obj4 = ((obj2 == null) ? obj3 : obj2);\n\t\tif (obj4 is string || (obj4 is bool \u0026\u0026 !(bool)obj4))\n\t\t{\n\t\t\tConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage(\u0022ConnectionRejected\u0022, this, text));\n\t\t\treturn true;\n\t\t}\n\t\tobject obj5 = Interface.CallHook(\u0022OnUserApprove\u0022, connection);\n\t\tobject result = Interface.CallHook(\u0022OnUserApproved\u0022, username, text, obj);\n\t\tif (obj5 != null)\n\t\t{\n\t\t\treturn obj5;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 30
  },
  {
    "HookSignature": "OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 10
  },
  {
    "HookSignature": "OnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSignature": "IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnEntitySaved\u0022)]\n\tprivate void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)\n\t{\n\t\tif (serverInitialized \u0026\u0026 saveInfo.forConnection != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnEntitySaved\u0022, baseNetworkable, saveInfo);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 6
  },
  {
    "HookSignature": "OnPlayerCommand(BasePlayer basePlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(System.Environment.NewLine, \u0022 \u0022), System.Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 24
  },
  {
    "HookSignature": "OnServerShutdown()",
    "MethodSignature": "IOnServerShutdown()",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnServerShutdown\u0022)]\n\tprivate void IOnServerShutdown()\n\t{\n\t\tInterface.Oxide.CallHook(\u0022OnServerShutdown\u0022);\n\t\tInterface.Oxide.OnShutdown();\n\t\tCovalence.PlayerManager.SavePlayerData();\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)",
    "MethodSignature": "IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerChat\u0022)]\n\tprivate object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)\n\t{\n\t\tif (string.IsNullOrEmpty(message) || message.Equals(\u0022text\u0022))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (basePlayer == null || !basePlayer.IsConnected)\n\t\t{\n\t\t\treturn Interface.CallHook(\u0022OnPlayerOfflineChat\u0022, playerId, playerName, message, channel);\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerChat\u0022, basePlayer, message, channel);\n\t\tobject result = Interface.CallHook(\u0022OnUserChat\u0022, basePlayer.IPlayer, message);\n\t\tif (obj != null)\n\t\t{\n\t\t\treturn obj;\n\t\t}\n\t\treturn result;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 12
  },
  {
    "HookSignature": "OnDestroyUI(BasePlayer player, string elem)",
    "MethodSignature": "DestroyUi(BasePlayer player, string elem)",
    "MethodSourseCode": "\n\tpublic static bool DestroyUi(BasePlayer player, string elem)\n\t{\n\t\tif (player?.net != null)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnDestroyUI\u0022, player, elem);\n\t\t\tCommunityEntity.ServerInstance.ClientRPCEx(new SendInfo\n\t\t\t{\n\t\t\t\tconnection = player.net.connection\n\t\t\t}, null, \u0022DestroyUI\u0022, elem);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n",
    "ClassName": "CuiHelper",
    "HookLineInvoke": 5
  },
  {
    "HookSignature": "OnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSignature": "IOnNpcTarget(BaseNpc npc, BaseEntity target)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnNpcTarget\u0022)]\n\tprivate object IOnNpcTarget(BaseNpc npc, BaseEntity target)\n\t{\n\t\tif (Interface.CallHook(\u0022OnNpcTarget\u0022, npc, target) != null)\n\t\t{\n\t\t\tnpc.SetFact(BaseNpc.Facts.HasEnemy, 0);\n\t\t\tnpc.SetFact(BaseNpc.Facts.EnemyRange, 3);\n\t\t\tnpc.SetFact(BaseNpc.Facts.AfraidRange, 1);\n\t\t\tnpc.playerTargetDecisionStartTime = 0f;\n\t\t\treturn 0f;\n\t\t}\n\t\treturn null;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  },
  {
    "HookSignature": "OnEntityTakeDamage(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSignature": "IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnBasePlayerAttacked\u0022)]\n\tprivate object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)\n\t{\n\t\tif (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tif (Interface.CallHook(\u0022OnEntityTakeDamage\u0022, basePlayer, hitInfo) != null)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tisPlayerTakingDamage = true;\n\t\ttry\n\t\t{\n\t\t\tbasePlayer.OnAttacked(hitInfo);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tisPlayerTakingDamage = false;\n\t\t}\n\t\treturn true;\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnPlayerBanned(string playerName, ulong steamId, string player?Address ?? \u00220\u0022, string reason, long expiry)",
    "MethodSignature": "OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022OnServerUserSet\u0022)]\n\tprivate void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)\n\t{\n\t\tif (serverInitialized \u0026\u0026 group == ServerUsers.UserGroup.Banned)\n\t\t{\n\t\t\tstring text = steamId.ToString();\n\t\t\tIPlayer player = Covalence.PlayerManager.FindPlayerById(text);\n\t\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, playerName, steamId, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t\tInterface.CallHook(\u0022OnUserBanned\u0022, playerName, text, player?.Address ?? \u00220\u0022, reason, expiry);\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 8
  },
  {
    "HookSignature": "OnApplicationCommand(BasePlayer basePlayer, string command, string[] args)",
    "MethodSignature": "IOnPlayerCommand(BasePlayer basePlayer, string message)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerCommand\u0022)]\n\tprivate void IOnPlayerCommand(BasePlayer basePlayer, string message)\n\t{\n\t\tif (basePlayer == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tstring text = message.Replace(\u0022\\n\u0022, \u0022\u0022).Replace(\u0022\\r\u0022, \u0022\u0022).Trim();\n\t\tif (string.IsNullOrEmpty(text) || text[0] != \u0027/\u0027 || text.Length \u003C= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tParseCommand(text.TrimStart(\u0027/\u0027), out var command, out var args);\n\t\tif (command == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (!basePlayer.IsConnected)\n\t\t{\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer, command, args);\n\t\t\tInterface.CallHook(\u0022OnApplicationCommand\u0022, basePlayer.IPlayer, command, args);\n\t\t\treturn;\n\t\t}\n\t\tobject obj = Interface.CallHook(\u0022OnPlayerCommand\u0022, basePlayer, command, args);\n\t\tobject obj2 = Interface.CallHook(\u0022OnUserCommand\u0022, basePlayer.IPlayer, command, args);\n\t\tif (((obj == null) ? obj2 : obj) != null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tif (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) \u0026\u0026 !cmdlib.HandleChatCommand(basePlayer, command, args) \u0026\u0026 Interface.Oxide.Config.Options.Modded)\n\t\t\t{\n\t\t\t\tbasePlayer.IPlayer.Reply(string.Format(lang.GetMessage(\u0022UnknownCommand\u0022, this, basePlayer.IPlayer.Id), command));\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tException ex2 = ex;\n\t\t\tstring text2 = string.Empty;\n\t\t\tstring empty = string.Empty;\n\t\t\tStringBuilder stringBuilder = new StringBuilder();\n\t\t\twhile (ex2 != null)\n\t\t\t{\n\t\t\t\tstring text3 = ex2.GetType().Name;\n\t\t\t\ttext2 = (text3 \u002B \u0022: \u0022 \u002B ex2.Message).TrimEnd(\u0027 \u0027, \u0027:\u0027);\n\t\t\t\tstringBuilder.AppendLine(ex2.StackTrace);\n\t\t\t\tif (ex2.InnerException != null)\n\t\t\t\t{\n\t\t\t\t\tstringBuilder.AppendLine(\u0022Rethrow as \u0022 \u002B text3);\n\t\t\t\t}\n\t\t\t\tex2 = ex2.InnerException;\n\t\t\t}\n\t\t\tStackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);\n\t\t\tfor (int i = 0; i \u003C stackTrace.FrameCount; i\u002B\u002B)\n\t\t\t{\n\t\t\t\tMethodBase method = stackTrace.GetFrame(i).GetMethod();\n\t\t\t\tif ((object)method != null \u0026\u0026 (object)method.DeclaringType != null \u0026\u0026 method.DeclaringType.Namespace == \u0022Oxide.Plugins\u0022)\n\t\t\t\t{\n\t\t\t\t\tempty = method.DeclaringType.Name;\n\t\t\t\t}\n\t\t\t}\n\t\t\tInterface.Oxide.LogError(string.Format(\u0022Failed to run command \u0027/{0}\u0027 on plugin \u0027{1}\u0027. ({2}){3}{4}\u0022, command, empty, text2.Replace(System.Environment.NewLine, \u0022 \u0022), System.Environment.NewLine, stackTrace));\n\t\t}\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 20
  },
  {
    "HookSignature": "OnPlayerBanned(Network.Connection connection, string status)",
    "MethodSignature": "IOnPlayerBanned(Connection connection, AuthResponse status)",
    "MethodSourseCode": "\n\t[HookMethod(\u0022IOnPlayerBanned\u0022)]\n\tprivate void IOnPlayerBanned(Connection connection, AuthResponse status)\n\t{\n\t\tInterface.CallHook(\u0022OnPlayerBanned\u0022, connection, status.ToString());\n\t}\n",
    "ClassName": "RustCore",
    "HookLineInvoke": 4
  }
]